(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["skatejsGithubIo"] = factory();
	else
		root["skatejsGithubIo"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonpskatejsGithubIo"];
/******/ 	window["webpackJsonpskatejsGithubIo"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + "." + ({}[chunkId]||chunkId) + "";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.App = undefined;
	
	__webpack_require__(1);
	
	var _index = __webpack_require__(2);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _index3 = __webpack_require__(50);
	
	var _index4 = _interopRequireDefault(_index3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.App = _index2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["skatejsWebComponents"] = factory();
		else
			root["skatejsWebComponents"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// We load the Safari fix first because the custom element polyfill overrides
		// attachShadow() to observe the shadow root.
		__webpack_require__(1);
		
		// We have to include this first so that it can patch native.
		__webpack_require__(2);
		
		// These must appear in this order. The ShadyCSS polyfill requires that the
		// ShadyDOM polyfill be loaded first.
		__webpack_require__(3);
		__webpack_require__(4);
		__webpack_require__(5);
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		var _window = window,
		    HTMLElement = _window.HTMLElement,
		    MutationObserver = _window.MutationObserver,
		    navigator = _window.navigator;
		var userAgent = navigator.userAgent;
		
		var safari = userAgent.indexOf('Safari/60') !== -1;
		var safariVersion = safari && userAgent.match(/Version\/([^\s]+)/)[1];
		var safariVersions = [0, 1].map(function (v) {
		  return '10.0.' + v;
		}).concat(['10.0']);
		var patch = safari && safariVersions.indexOf(safariVersion) > -1;
		
		// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331
		function fixSafari() {
		  var oldAttachShadow = HTMLElement.prototype.attachShadow;
		
		  // We observe a shadow root, but only need to know if the target that was mutated is a <style>
		  // element as this is the only scenario where styles aren't recalculated.
		  var moOpts = { childList: true, subtree: true };
		  var mo = new MutationObserver(function (muts) {
		    muts.forEach(function (mut) {
		      var target = mut.target;
		
		      if (target.tagName === 'STYLE') {
		        var nextSibling = target.nextSibling,
		            parentNode = target.parentNode;
		
		        // We actually have to remove and subsequently re-insert rather than doing insertBefore()
		        // as it seems that doesn't trigger a recalc.
		
		        parentNode.removeChild(target);
		        parentNode.insertBefore(target, nextSibling);
		      }
		    });
		  });
		
		  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes
		  // to it are observed so that we can take any <style> elements and re-insert them.
		  function newAttachShadow(opts) {
		    var sr = oldAttachShadow.call(this, opts);
		    mo.observe(sr, moOpts);
		    return sr;
		  }
		
		  // We have to define a property because Safari won't take the override if it is set directly.
		  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {
		    // Ensure polyfills can override it (hoping they call it back).
		    configurable: true,
		    enumerable: true,
		    value: newAttachShadow,
		    writable: true
		  });
		}
		
		// We target a specific version of Safari instead of trying to but detect as it seems to involve
		// contriving a breaking case and detecting computed styles. We can remove this code when Safari
		// fixes the bug.
		if (patch) {
		  fixSafari();
		}
		
		exports.default = patch;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
		"use strict";
		
		window.customElements && eval("/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements.\n *\n * ES5-style classes don't work with native Custom Elements because the\n * HTMLElement constructor uses the value of `new.target` to look up the custom\n * element definition for the currently called constructor. `new.target` is only\n * set when `new` is called and is only propagated via super() calls. super()\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\n * when extending other ES5-style classes, and does not propagate `new.target`.\n *\n * This shim allows the native HTMLElement constructor to work by generating and\n * registering a stand-in class instead of the users custom element class. This\n * stand-in class's constructor has an actual call to super().\n * `customElements.define()` and `customElements.get()` are both overridden to\n * hide this stand-in class from users.\n *\n * In order to create instance of the user-defined class, rather than the stand\n * in, the stand-in's constructor swizzles its instances prototype and invokes\n * the user-defined constructor. When the user-defined constructor is called\n * directly it creates an instance of the stand-in class to get a real extension\n * of HTMLElement and returns that.\n *\n * There are two important constructors: A patched HTMLElement constructor, and\n * the StandInElement constructor. They both will be called to create an element\n * but which is called first depends on whether the browser creates the element\n * or the user-defined constructor is called directly. The variables\n * `browserConstruction` and `userConstruction` control the flow between the\n * two constructors.\n *\n * This shim should be better than forcing the polyfill because:\n *   1. It's smaller\n *   2. All reaction timings are the same as native (mostly synchronous)\n *   3. All reaction triggering DOM operations are automatically supported\n *\n * There are some restrictions and requirements on ES5 constructors:\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\n *      they can be called with Function.call(). This effectively means that the\n *      whole application must be compiled to ES5.\n *   2. Constructors must return the value of the emulated super() call. Like\n *      `return SuperClass.call(this)`\n *   3. The `this` reference should not be used before the emulated super() call\n *      just like `this` is illegal to use before super() in ES6.\n *   4. Constructors should not create other custom elements before the emulated\n *      super() call. This is the same restriction as with native custom\n *      elements.\n *\n *  Compiling valid class-based custom elements to ES5 will satisfy these\n *  requirements with the latest version of popular transpilers.\n */\n(() => {\n  'use strict';\n\n  const NativeHTMLElement = window.HTMLElement;\n  const nativeDefine = window.customElements.define;\n  const nativeGet = window.customElements.get;\n\n  /**\n   * Map of user-provided constructors to tag names.\n   *\n   * @type {Map<Function, string>}\n   */\n  const tagnameByConstructor = new Map();\n\n  /**\n   * Map of tag anmes to user-provided constructors.\n   *\n   * @type {Map<string, Function>}\n   */\n  const constructorByTagname = new Map();\n\n\n  /**\n   * Whether the constructors are being called by a browser process, ie parsing\n   * or createElement.\n   */\n  let browserConstruction = false;\n\n  /**\n   * Whether the constructors are being called by a user-space process, ie\n   * calling an element constructor.\n   */\n  let userConstruction = false;\n\n  window.HTMLElement = function() {\n    if (!browserConstruction) {\n      const tagname = tagnameByConstructor.get(this.constructor);\n      const fakeClass = nativeGet.call(window.customElements, tagname);\n\n      // Make sure that the fake constructor doesn't call back to this constructor\n      userConstruction = true;\n      const instance = new (fakeClass)();\n      return instance;\n    }\n    // Else do nothing. This will be reached by ES5-style classes doing\n    // HTMLElement.call() during initialization\n    browserConstruction = false;\n  };\n\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\n\n  window.customElements.define = (tagname, elementClass) => {\n    const elementProto = elementClass.prototype;\n    const StandInElement = class extends NativeHTMLElement {\n      constructor() {\n        // Call the native HTMLElement constructor, this gives us the\n        // under-construction instance as `this`:\n        super();\n\n        // The prototype will be wrong up because the browser used our fake\n        // class, so fix it:\n        Object.setPrototypeOf(this, elementProto);\n\n        if (!userConstruction) {\n          // Make sure that user-defined constructor bottom's out to a do-nothing\n          // HTMLElement() call\n          browserConstruction = true;\n          // Call the user-defined constructor on our instance:\n          elementClass.call(this);\n        }\n        userConstruction = false;\n      }\n    };\n    const standInProto = StandInElement.prototype;\n    StandInElement.observedAttributes = elementClass.observedAttributes;\n    standInProto.connectedCallback = elementProto.connectedCallback;\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\n\n    tagnameByConstructor.set(elementClass, tagname);\n    constructorByTagname.set(tagname, elementClass);\n    nativeDefine.call(window.customElements, tagname, StandInElement);\n  };\n\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\n\n})();");
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		/*
		
		 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		 Code distributed by Google as part of the polymer project is also
		 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error("The element name '"+a+"' is not valid.")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}
		function n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q="annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&"function"!==typeof b)throw Error(c+
		" '"+a+"' is not a Function");return b}if("function"!==typeof b)throw new TypeError("constructor must be a Constructor");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error("An element with name '"+a+"' is already defined");if(this.j.has(b))throw Error("Definition failed for '"+a+"': The constructor is already used.");var c=a,f=b.prototype;if("object"!==typeof f)throw new TypeError("Definition failed for '"+a+"': constructor.prototype must be an object");var e=d("connectedCallback"),g=d("disconnectedCallback"),
		h=d("attributeChangedCallback");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=
		function(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,
		{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if("childList"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);
		e=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,
		b);"LINK"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(" ").indexOf("import")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener("load",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener("load",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);
		d=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=
		a.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if("attributes"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;
		c.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error("Unknown constructor. Did you call customElements.define()?");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=
		function(a,b){return"http://www.w3.org/1999/xhtml"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,"attachShadow",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;
		Element.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,"customElements",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();
		
		//# sourceMappingURL=custom-elements.min.js.map
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports) {
	
		(function () {
		'use strict';
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var settings = window.ShadyDOM || {};
		
		settings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);
		
		settings.inUse = settings.force || !settings.hasNativeShadowDOM;
		
		function isShadyRoot(obj) {
		  return Boolean(obj.__localName === 'ShadyRoot');
		}
		
		var p = Element.prototype;
		var matches = p.matches || p.matchesSelector ||
		  p.mozMatchesSelector || p.msMatchesSelector ||
		  p.oMatchesSelector || p.webkitMatchesSelector;
		
		function matchesSelector(element, selector) {
		  return matches.call(element, selector);
		}
		
		function copyOwnProperty(name, source, target) {
		  var pd = Object.getOwnPropertyDescriptor(source, name);
		  if (pd) {
		    Object.defineProperty(target, name, pd);
		  }
		}
		
		function extend(target, source) {
		  if (target && source) {
		    var n$ = Object.getOwnPropertyNames(source);
		    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {
		      copyOwnProperty(n, source, target);
		    }
		  }
		  return target || source;
		}
		
		function extendAll(target) {
		  var sources = [], len = arguments.length - 1;
		  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];
		
		  for (var i=0; i < sources.length; i++) {
		    extend(target, sources[i]);
		  }
		  return target;
		}
		
		function mixin(target, source) {
		  for (var i in source) {
		    target[i] = source[i];
		  }
		  return target;
		}
		
		var setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {
		  obj.__proto__ = proto;
		  return obj;
		}
		
		function patchPrototype(obj, mixin) {
		  var proto = Object.getPrototypeOf(obj);
		  if (!proto.hasOwnProperty('__patchProto')) {
		    var patchProto = Object.create(proto);
		    patchProto.__sourceProto = proto;
		    extend(patchProto, mixin);
		    proto.__patchProto = patchProto;
		  }
		  setPrototypeOf(obj, proto.__patchProto);
		}
		
		
		
		var common = {};
		
		// TODO(sorvell): actually rely on a real Promise polyfill...
		var promish;
		if (window.Promise) {
		  promish = Promise.resolve();
		} else {
		  promish = {
		    then: function(cb) {
		      var twiddle = document.createTextNode('');
		      var observer = new MutationObserver(function() {
		        observer.disconnect();
		        cb();
		      });
		      observer.observe(twiddle, {characterData: true});
		    }
		  }
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		function newSplice(index, removed, addedCount) {
		  return {
		    index: index,
		    removed: removed,
		    addedCount: addedCount
		  };
		}
		
		var EDIT_LEAVE = 0;
		var EDIT_UPDATE = 1;
		var EDIT_ADD = 2;
		var EDIT_DELETE = 3;
		
		var ArraySplice = {
		
		  // Note: This function is *based* on the computation of the Levenshtein
		  // "edit" distance. The one change is that "updates" are treated as two
		  // edits - not one. With Array splices, an update is really a delete
		  // followed by an add. By retaining this, we optimize for "keeping" the
		  // maximum array items in the original array. For example:
		  //
		  //   'xxxx123' -> '123yyyy'
		  //
		  // With 1-edit updates, the shortest path would be just to update all seven
		  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
		  // leaves the substring '123' intact.
		  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,
		                              old, oldStart, oldEnd) {
		    var this$1 = this;
		
		    // "Deletion" columns
		    var rowCount = oldEnd - oldStart + 1;
		    var columnCount = currentEnd - currentStart + 1;
		    var distances = new Array(rowCount);
		
		    // "Addition" rows. Initialize null column.
		    for (var i = 0; i < rowCount; i++) {
		      distances[i] = new Array(columnCount);
		      distances[i][0] = i;
		    }
		
		    // Initialize null row
		    for (var j = 0; j < columnCount; j++)
		      distances[0][j] = j;
		
		    for (var i$1 = 1; i$1 < rowCount; i$1++) {
		      for (var j$1 = 1; j$1 < columnCount; j$1++) {
		        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))
		          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];
		        else {
		          var north = distances[i$1 - 1][j$1] + 1;
		          var west = distances[i$1][j$1 - 1] + 1;
		          distances[i$1][j$1] = north < west ? north : west;
		        }
		      }
		    }
		
		    return distances;
		  },
		
		  // This starts at the final weight, and walks "backward" by finding
		  // the minimum previous weight recursively until the origin of the weight
		  // matrix.
		  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
		    var i = distances.length - 1;
		    var j = distances[0].length - 1;
		    var current = distances[i][j];
		    var edits = [];
		    while (i > 0 || j > 0) {
		      if (i == 0) {
		        edits.push(EDIT_ADD);
		        j--;
		        continue;
		      }
		      if (j == 0) {
		        edits.push(EDIT_DELETE);
		        i--;
		        continue;
		      }
		      var northWest = distances[i - 1][j - 1];
		      var west = distances[i - 1][j];
		      var north = distances[i][j - 1];
		
		      var min;
		      if (west < north)
		        min = west < northWest ? west : northWest;
		      else
		        min = north < northWest ? north : northWest;
		
		      if (min == northWest) {
		        if (northWest == current) {
		          edits.push(EDIT_LEAVE);
		        } else {
		          edits.push(EDIT_UPDATE);
		          current = northWest;
		        }
		        i--;
		        j--;
		      } else if (min == west) {
		        edits.push(EDIT_DELETE);
		        i--;
		        current = west;
		      } else {
		        edits.push(EDIT_ADD);
		        j--;
		        current = north;
		      }
		    }
		
		    edits.reverse();
		    return edits;
		  },
		
		  /**
		   * Splice Projection functions:
		   *
		   * A splice map is a representation of how a previous array of items
		   * was transformed into a new array of items. Conceptually it is a list of
		   * tuples of
		   *
		   *   <index, removed, addedCount>
		   *
		   * which are kept in ascending index order of. The tuple represents that at
		   * the |index|, |removed| sequence of items were removed, and counting forward
		   * from |index|, |addedCount| items were added.
		   */
		
		  /**
		   * Lacking individual splice mutation information, the minimal set of
		   * splices can be synthesized given the previous state and final state of an
		   * array. The basic approach is to calculate the edit distance matrix and
		   * choose the shortest path through it.
		   *
		   * Complexity: O(l * p)
		   *   l: The length of the current array
		   *   p: The length of the old array
		   */
		  calcSplices: function calcSplices(current, currentStart, currentEnd,
		                        old, oldStart, oldEnd) {
		    var prefixCount = 0;
		    var suffixCount = 0;
		    var splice;
		
		    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
		    if (currentStart == 0 && oldStart == 0)
		      prefixCount = this.sharedPrefix(current, old, minLength);
		
		    if (currentEnd == current.length && oldEnd == old.length)
		      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
		
		    currentStart += prefixCount;
		    oldStart += prefixCount;
		    currentEnd -= suffixCount;
		    oldEnd -= suffixCount;
		
		    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
		      return [];
		
		    if (currentStart == currentEnd) {
		      splice = newSplice(currentStart, [], 0);
		      while (oldStart < oldEnd)
		        splice.removed.push(old[oldStart++]);
		
		      return [ splice ];
		    } else if (oldStart == oldEnd)
		      return [ newSplice(currentStart, [], currentEnd - currentStart) ];
		
		    var ops = this.spliceOperationsFromEditDistances(
		        this.calcEditDistances(current, currentStart, currentEnd,
		                               old, oldStart, oldEnd));
		
		    splice = undefined;
		    var splices = [];
		    var index = currentStart;
		    var oldIndex = oldStart;
		    for (var i = 0; i < ops.length; i++) {
		      switch(ops[i]) {
		        case EDIT_LEAVE:
		          if (splice) {
		            splices.push(splice);
		            splice = undefined;
		          }
		
		          index++;
		          oldIndex++;
		          break;
		        case EDIT_UPDATE:
		          if (!splice)
		            splice = newSplice(index, [], 0);
		
		          splice.addedCount++;
		          index++;
		
		          splice.removed.push(old[oldIndex]);
		          oldIndex++;
		          break;
		        case EDIT_ADD:
		          if (!splice)
		            splice = newSplice(index, [], 0);
		
		          splice.addedCount++;
		          index++;
		          break;
		        case EDIT_DELETE:
		          if (!splice)
		            splice = newSplice(index, [], 0);
		
		          splice.removed.push(old[oldIndex]);
		          oldIndex++;
		          break;
		      }
		    }
		
		    if (splice) {
		      splices.push(splice);
		    }
		    return splices;
		  },
		
		  sharedPrefix: function sharedPrefix(current, old, searchLength) {
		    var this$1 = this;
		
		    for (var i = 0; i < searchLength; i++)
		      if (!this$1.equals(current[i], old[i]))
		        return i;
		    return searchLength;
		  },
		
		  sharedSuffix: function sharedSuffix(current, old, searchLength) {
		    var index1 = current.length;
		    var index2 = old.length;
		    var count = 0;
		    while (count < searchLength && this.equals(current[--index1], old[--index2]))
		      count++;
		
		    return count;
		  },
		
		  calculateSplices: function calculateSplices$1(current, previous) {
		    return this.calcSplices(current, 0, current.length, previous, 0,
		                            previous.length);
		  },
		
		  equals: function equals(currentValue, previousValue) {
		    return currentValue === previousValue;
		  }
		
		};
		
		var calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		// TODO(sorvell): circular (patch loads tree and tree loads patch)
		// for now this is stuck on `utils`
		//import {patchNode} from './patch'
		// native add/remove
		var nativeInsertBefore = Element.prototype.insertBefore;
		var nativeAppendChild = Element.prototype.appendChild;
		var nativeRemoveChild = Element.prototype.removeChild;
		
		/**
		 * `tree` is a dom manipulation library used by ShadyDom to
		 * manipulate composed and logical trees.
		 */
		var tree = {
		
		  // sad but faster than slice...
		  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {
		    var copy=[], i=0;
		    for (var n=parent.firstChild; n; n=n.nextSibling) {
		      copy[i++] = n;
		    }
		    return copy;
		  },
		
		  arrayCopyChildren: function arrayCopyChildren(parent) {
		    var copy=[], i=0;
		    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {
		      copy[i++] = n;
		    }
		    return copy;
		  },
		
		  arrayCopy: function arrayCopy(a$) {
		    var l = a$.length;
		    var copy = new Array(l);
		    for (var i=0; i < l; i++) {
		      copy[i] = a$[i];
		    }
		    return copy;
		  },
		
		  saveChildNodes: function saveChildNodes(node) {
		    tree.Logical.saveChildNodes(node);
		    if (!tree.Composed.hasParentNode(node)) {
		      tree.Composed.saveComposedData(node);
		      //tree.Composed.saveParentNode(node);
		    }
		    tree.Composed.saveChildNodes(node);
		  }
		
		};
		
		tree.Logical = {
		
		  hasParentNode: function hasParentNode(node) {
		    return Boolean(node.__dom && node.__dom.parentNode);
		  },
		
		  hasChildNodes: function hasChildNodes(node) {
		    return Boolean(node.__dom && node.__dom.childNodes !== undefined);
		  },
		
		  getChildNodes: function getChildNodes(node) {
		    // note: we're distinguishing here between undefined and false-y:
		    // hasChildNodes uses undefined check to see if this element has logical
		    // children; the false-y check indicates whether or not we should rebuild
		    // the cached childNodes array.
		    return this.hasChildNodes(node) ? this._getChildNodes(node) :
		      tree.Composed.getChildNodes(node);
		  },
		
		  _getChildNodes: function _getChildNodes(node) {
		    if (!node.__dom.childNodes) {
		      node.__dom.childNodes = [];
		      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {
		        node.__dom.childNodes.push(n);
		      }
		    }
		    return node.__dom.childNodes;
		  },
		
		  // NOTE: __dom can be created under 2 conditions: (1) an element has a
		  // logical tree, or (2) an element is in a logical tree. In case (1), the
		  // element will store firstChild/lastChild, and in case (2), the element
		  // will store parentNode, nextSibling, previousSibling. This means that
		  // the mere existence of __dom is not enough to know if the requested
		  // logical data is available and instead we do an explicit undefined check.
		  getParentNode: function getParentNode(node) {
		    return node.__dom && node.__dom.parentNode !== undefined ?
		      node.__dom.parentNode : tree.Composed.getParentNode(node);
		  },
		
		  getFirstChild: function getFirstChild(node) {
		    return node.__dom && node.__dom.firstChild !== undefined ?
		      node.__dom.firstChild : tree.Composed.getFirstChild(node);
		  },
		
		  getLastChild: function getLastChild(node) {
		    return node.__dom && node.__dom.lastChild  !== undefined ?
		      node.__dom.lastChild : tree.Composed.getLastChild(node);
		  },
		
		  getNextSibling: function getNextSibling(node) {
		    return node.__dom && node.__dom.nextSibling  !== undefined ?
		      node.__dom.nextSibling : tree.Composed.getNextSibling(node);
		  },
		
		  getPreviousSibling: function getPreviousSibling(node) {
		    return node.__dom && node.__dom.previousSibling  !== undefined ?
		      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);
		  },
		
		  getFirstElementChild: function getFirstElementChild(node) {
		    return node.__dom && node.__dom.firstChild !== undefined ?
		      this._getFirstElementChild(node) :
		      tree.Composed.getFirstElementChild(node);
		  },
		
		  _getFirstElementChild: function _getFirstElementChild(node) {
		    var n = node.__dom.firstChild;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = n.__dom.nextSibling;
		    }
		    return n;
		  },
		
		  getLastElementChild: function getLastElementChild(node) {
		    return node.__dom && node.__dom.lastChild !== undefined ?
		      this._getLastElementChild(node) :
		      tree.Composed.getLastElementChild(node);
		  },
		
		  _getLastElementChild: function _getLastElementChild(node) {
		    var n = node.__dom.lastChild;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = n.__dom.previousSibling;
		    }
		    return n;
		  },
		
		  getNextElementSibling: function getNextElementSibling(node) {
		    return node.__dom && node.__dom.nextSibling !== undefined ?
		      this._getNextElementSibling(node) :
		      tree.Composed.getNextElementSibling(node);
		  },
		
		  _getNextElementSibling: function _getNextElementSibling(node) {
		    var this$1 = this;
		
		    var n = node.__dom.nextSibling;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = this$1.getNextSibling(n);
		    }
		    return n;
		  },
		
		  getPreviousElementSibling: function getPreviousElementSibling(node) {
		    return node.__dom && node.__dom.previousSibling !== undefined ?
		      this._getPreviousElementSibling(node) :
		      tree.Composed.getPreviousElementSibling(node);
		  },
		
		  _getPreviousElementSibling: function _getPreviousElementSibling(node) {
		    var this$1 = this;
		
		    var n = node.__dom.previousSibling;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = this$1.getPreviousSibling(n);
		    }
		    return n;
		  },
		
		  // Capture the list of light children. It's important to do this before we
		  // start transforming the DOM into "rendered" state.
		  // Children may be added to this list dynamically. It will be treated as the
		  // source of truth for the light children of the element. This element's
		  // actual children will be treated as the rendered state once this function
		  // has been called.
		  saveChildNodes: function saveChildNodes$1(node) {
		    if (!this.hasChildNodes(node)) {
		      node.__dom = node.__dom || {};
		      node.__dom.firstChild = node.firstChild;
		      node.__dom.lastChild = node.lastChild;
		      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);
		      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {
		        n.__dom = n.__dom || {};
		        n.__dom.parentNode = node;
		        n.__dom.nextSibling = c$[i+1] || null;
		        n.__dom.previousSibling = c$[i-1] || null;
		        common.patchNode(n);
		      }
		    }
		  },
		
		  // TODO(sorvell): may need to patch saveChildNodes iff the tree has
		  // already been distributed.
		  // NOTE: ensure `node` is patched...
		  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {
		    var this$1 = this;
		
		    container.__dom.childNodes = null;
		    // handle document fragments
		    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		      var c$ = tree.arrayCopyChildNodes(node);
		      for (var i=0; i < c$.length; i++) {
		        this$1._linkNode(c$[i], container, ref_node);
		      }
		      // cleanup logical dom in doc fragment.
		      node.__dom = node.__dom || {};
		      node.__dom.firstChild = node.__dom.lastChild = null;
		      node.__dom.childNodes = null;
		    } else {
		      this._linkNode(node, container, ref_node);
		    }
		  },
		
		  _linkNode: function _linkNode(node, container, ref_node) {
		    common.patchNode(node);
		    ref_node = ref_node || null;
		    node.__dom = node.__dom || {};
		    container.__dom = container.__dom || {};
		    if (ref_node) {
		      ref_node.__dom = ref_node.__dom || {};
		    }
		    // update ref_node.previousSibling <-> node
		    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :
		      container.__dom.lastChild;
		    if (node.__dom.previousSibling) {
		      node.__dom.previousSibling.__dom.nextSibling = node;
		    }
		    // update node <-> ref_node
		    node.__dom.nextSibling = ref_node;
		    if (node.__dom.nextSibling) {
		      node.__dom.nextSibling.__dom.previousSibling = node;
		    }
		    // update node <-> container
		    node.__dom.parentNode = container;
		    if (ref_node) {
		      if (ref_node === container.__dom.firstChild) {
		        container.__dom.firstChild = node;
		      }
		    } else {
		      container.__dom.lastChild = node;
		      if (!container.__dom.firstChild) {
		        container.__dom.firstChild = node;
		      }
		    }
		    // remove caching of childNodes
		    container.__dom.childNodes = null;
		  },
		
		  recordRemoveChild: function recordRemoveChild(node, container) {
		    node.__dom = node.__dom || {};
		    container.__dom = container.__dom || {};
		    if (node === container.__dom.firstChild) {
		      container.__dom.firstChild = node.__dom.nextSibling;
		    }
		    if (node === container.__dom.lastChild) {
		      container.__dom.lastChild = node.__dom.previousSibling;
		    }
		    var p = node.__dom.previousSibling;
		    var n = node.__dom.nextSibling;
		    if (p) {
		      p.__dom = p.__dom || {};
		      p.__dom.nextSibling = n;
		    }
		    if (n) {
		      n.__dom = n.__dom || {};
		      n.__dom.previousSibling = p;
		    }
		    // When an element is removed, logical data is no longer tracked.
		    // Explicitly set `undefined` here to indicate this. This is disginguished
		    // from `null` which is set if info is null.
		    node.__dom.parentNode = node.__dom.previousSibling =
		      node.__dom.nextSibling = null;
		    // remove caching of childNodes
		    container.__dom.childNodes = null;
		  }
		
		}
		
		
		// TODO(sorvell): composed tree manipulation is made available
		// (1) to maninpulate the composed tree, and (2) to track changes
		// to the tree for optional patching pluggability.
		tree.Composed = {
		
		  hasParentNode: function hasParentNode$1(node) {
		    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);
		  },
		
		  hasChildNodes: function hasChildNodes$1(node) {
		    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);
		  },
		
		  getChildNodes: function getChildNodes$1(node) {
		    return this.hasChildNodes(node) ? this._getChildNodes(node) :
		      (!node.__patched && tree.arrayCopy(node.childNodes));
		  },
		
		  _getChildNodes: function _getChildNodes$1(node) {
		    if (!node.__dom.$childNodes) {
		      node.__dom.$childNodes = [];
		      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {
		        node.__dom.$childNodes.push(n);
		      }
		    }
		    return node.__dom.$childNodes;
		  },
		
		  getComposedChildNodes: function getComposedChildNodes(node) {
		    return node.__dom.$childNodes;
		  },
		
		  getParentNode: function getParentNode$1(node) {
		    return this.hasParentNode(node) ? node.__dom.$parentNode :
		      (!node.__patched && node.parentNode);
		  },
		
		  getFirstChild: function getFirstChild$1(node) {
		    return node.__patched ? node.__dom.$firstChild : node.firstChild;
		  },
		
		  getLastChild: function getLastChild$1(node) {
		    return node.__patched ? node.__dom.$lastChild : node.lastChild;
		  },
		
		  getNextSibling: function getNextSibling$1(node) {
		    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;
		  },
		
		  getPreviousSibling: function getPreviousSibling$1(node) {
		    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;
		  },
		
		  getFirstElementChild: function getFirstElementChild$1(node) {
		    return node.__patched ? this._getFirstElementChild(node) :
		      node.firstElementChild;
		  },
		
		  _getFirstElementChild: function _getFirstElementChild$1(node) {
		    var n = node.__dom.$firstChild;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = n.__dom.$nextSibling;
		    }
		    return n;
		  },
		
		  getLastElementChild: function getLastElementChild$1(node) {
		    return node.__patched ? this._getLastElementChild(node) :
		      node.lastElementChild;
		  },
		
		  _getLastElementChild: function _getLastElementChild$1(node) {
		    var n = node.__dom.$lastChild;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = n.__dom.$previousSibling;
		    }
		    return n;
		  },
		
		  getNextElementSibling: function getNextElementSibling$1(node) {
		    return node.__patched ? this._getNextElementSibling(node) :
		      node.nextElementSibling;
		  },
		
		  _getNextElementSibling: function _getNextElementSibling$1(node) {
		    var this$1 = this;
		
		    var n = node.__dom.$nextSibling;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = this$1.getNextSibling(n);
		    }
		    return n;
		  },
		
		  getPreviousElementSibling: function getPreviousElementSibling$1(node) {
		    return node.__patched ? this._getPreviousElementSibling(node) :
		      node.previousElementSibling;
		  },
		
		  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {
		    var this$1 = this;
		
		    var n = node.__dom.$previousSibling;
		    while (n && n.nodeType !== Node.ELEMENT_NODE) {
		      n = this$1.getPreviousSibling(n);
		    }
		    return n;
		  },
		
		  saveChildNodes: function saveChildNodes$2(node) {
		    var this$1 = this;
		
		    if (!this.hasChildNodes(node)) {
		      node.__dom = node.__dom || {};
		      node.__dom.$firstChild = node.firstChild;
		      node.__dom.$lastChild = node.lastChild;
		      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);
		      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {
		        this$1.saveComposedData(n);
		      }
		    }
		  },
		
		  saveComposedData: function saveComposedData(node) {
		    node.__dom = node.__dom || {};
		    if (node.__dom.$parentNode === undefined) {
		      node.__dom.$parentNode = node.parentNode;
		    }
		    if (node.__dom.$nextSibling === undefined) {
		      node.__dom.$nextSibling = node.nextSibling;
		    }
		    if (node.__dom.$previousSibling === undefined) {
		      node.__dom.$previousSibling = node.previousSibling;
		    }
		  },
		
		  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {
		    var this$1 = this;
		
		    container.__dom.$childNodes = null;
		    // handle document fragments
		    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		      // TODO(sorvell): remember this for patching:
		      // the act of setting this info can affect patched nodes
		      // getters; therefore capture childNodes before patching.
		      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {
		        this$1._linkNode(n, container, ref_node);
		      }
		    } else {
		      this._linkNode(node, container, ref_node);
		    }
		  },
		
		  _linkNode: function _linkNode$1(node, container, ref_node) {
		    node.__dom = node.__dom || {};
		    container.__dom = container.__dom || {};
		    if (ref_node) {
		      ref_node.__dom = ref_node.__dom || {};
		    }
		    // update ref_node.previousSibling <-> node
		    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :
		      container.__dom.$lastChild;
		    if (node.__dom.$previousSibling) {
		      node.__dom.$previousSibling.__dom.$nextSibling = node;
		    }
		    // update node <-> ref_node
		    node.__dom.$nextSibling = ref_node;
		    if (node.__dom.$nextSibling) {
		      node.__dom.$nextSibling.__dom.$previousSibling = node;
		    }
		    // update node <-> container
		    node.__dom.$parentNode = container;
		    if (ref_node) {
		      if (ref_node === container.__dom.$firstChild) {
		        container.__dom.$firstChild = node;
		      }
		    } else {
		      container.__dom.$lastChild = node;
		      if (!container.__dom.$firstChild) {
		        container.__dom.$firstChild = node;
		      }
		    }
		    // remove caching of childNodes
		    container.__dom.$childNodes = null;
		  },
		
		  recordRemoveChild: function recordRemoveChild$1(node, container) {
		    node.__dom = node.__dom || {};
		    container.__dom = container.__dom || {};
		    if (node === container.__dom.$firstChild) {
		      container.__dom.$firstChild = node.__dom.$nextSibling;
		    }
		    if (node === container.__dom.$lastChild) {
		      container.__dom.$lastChild = node.__dom.$previousSibling;
		    }
		    var p = node.__dom.$previousSibling;
		    var n = node.__dom.$nextSibling;
		    if (p) {
		      p.__dom = p.__dom || {};
		      p.__dom.$nextSibling = n;
		    }
		    if (n) {
		      n.__dom = n.__dom || {};
		      n.__dom.$previousSibling = p;
		    }
		    node.__dom.$parentNode = node.__dom.$previousSibling =
		      node.__dom.$nextSibling = null;
		    // remove caching of childNodes
		    container.__dom.$childNodes = null;
		  },
		
		  clearChildNodes: function clearChildNodes(node) {
		    var this$1 = this;
		
		    var c$ = this.getChildNodes(node);
		    for (var i=0, c; i < c$.length; i++) {
		      c = c$[i];
		      this$1.recordRemoveChild(c, node);
		      nativeRemoveChild.call(node, c)
		    }
		  },
		
		  saveParentNode: function saveParentNode(node) {
		    node.__dom = node.__dom || {};
		    node.__dom.$parentNode = node.parentNode;
		  },
		
		  insertBefore: function insertBefore(parentNode, newChild, refChild) {
		    this.saveChildNodes(parentNode);
		    // remove from current location.
		    this._addChild(parentNode, newChild, refChild);
		    return nativeInsertBefore.call(parentNode, newChild, refChild || null);
		  },
		
		  appendChild: function appendChild(parentNode, newChild) {
		    this.saveChildNodes(parentNode);
		    this._addChild(parentNode, newChild);
		    return nativeAppendChild.call(parentNode, newChild);
		  },
		
		  removeChild: function removeChild(parentNode, node) {
		    var currentParent = this.getParentNode(node);
		    this.saveChildNodes(parentNode);
		    this._removeChild(parentNode, node);
		    if (currentParent === parentNode) {
		      return nativeRemoveChild.call(parentNode, node);
		    }
		  },
		
		  _addChild: function _addChild(parentNode, newChild, refChild) {
		    var this$1 = this;
		
		    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);
		    var oldParent = this.getParentNode(newChild);
		    if (oldParent) {
		      this._removeChild(oldParent, newChild);
		    }
		    if (isFrag) {
		      var c$ = this.getChildNodes(newChild);
		      for (var i=0; i < c$.length; i++) {
		        var c = c$[i];
		        // unlink document fragment children
		        this$1._removeChild(newChild, c);
		        this$1.recordInsertBefore(c, parentNode, refChild);
		      }
		    } else {
		      this.recordInsertBefore(newChild, parentNode, refChild);
		    }
		  },
		
		  _removeChild: function _removeChild(parentNode, node) {
		    this.recordRemoveChild(node, parentNode);
		  }
		
		};
		
		// for testing...
		var descriptors = {};
		function getNativeProperty(element, property) {
		  if (!descriptors[property]) {
		    descriptors[property] = Object.getOwnPropertyDescriptor(
		      HTMLElement.prototype, property) ||
		    Object.getOwnPropertyDescriptor(
		      Element.prototype, property) ||
		    Object.getOwnPropertyDescriptor(
		      Node.prototype, property);
		  }
		  return descriptors[property].get.call(element);
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		// NOTE: normalize event contruction where necessary (IE11)
		var NormalizedEvent = typeof Event === 'function' ? Event :
		  function(inType, params) {
		    params = params || {};
		    var e = document.createEvent('Event');
		    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
		    return e;
		  };
		
		var Distributor = (function () {
		  function anonymous(root) {
		    this.root = root;
		    this.insertionPointTag = 'slot';
		  }
		
		  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {
		    return this.root.querySelectorAll(this.insertionPointTag);
		  };
		
		  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {
		    return Boolean(this.root._insertionPoints &&
		      this.root._insertionPoints.length);
		  };
		
		  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {
		    return node.localName && node.localName == this.insertionPointTag;
		  };
		
		  anonymous.prototype.distribute = function distribute () {
		    if (this.hasInsertionPoint()) {
		      return this.distributePool(this.root, this.collectPool());
		    }
		    return [];
		  };
		
		  // Gather the pool of nodes that should be distributed. We will combine
		  // these with the "content root" to arrive at the composed tree.
		  anonymous.prototype.collectPool = function collectPool () {
		    return tree.arrayCopy(
		      tree.Logical.getChildNodes(this.root.host));
		  };
		
		  // perform "logical" distribution; note, no actual dom is moved here,
		  // instead elements are distributed into storage
		  // array where applicable.
		  anonymous.prototype.distributePool = function distributePool (node, pool) {
		    var this$1 = this;
		
		    var dirtyRoots = [];
		    var p$ = this.root._insertionPoints;
		    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {
		      this$1.distributeInsertionPoint(p, pool);
		      // provoke redistribution on insertion point parents
		      // must do this on all candidate hosts since distribution in this
		      // scope invalidates their distribution.
		      // only get logical parent.
		      var parent = tree.Logical.getParentNode(p);
		      if (parent && parent.shadyRoot &&
		          this$1.hasInsertionPoint(parent.shadyRoot)) {
		        dirtyRoots.push(parent.shadyRoot);
		      }
		    }
		    for (var i$1=0; i$1 < pool.length; i$1++) {
		      var p$1 = pool[i$1];
		      if (p$1) {
		        p$1._assignedSlot = undefined;
		        // remove undistributed elements from physical dom.
		        var parent$1 = tree.Composed.getParentNode(p$1);
		        if (parent$1) {
		          tree.Composed.removeChild(parent$1, p$1);
		        }
		      }
		    }
		    return dirtyRoots;
		  };
		
		  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {
		    var this$1 = this;
		
		    var prevAssignedNodes = insertionPoint._assignedNodes;
		    if (prevAssignedNodes) {
		      this.clearAssignedSlots(insertionPoint, true);
		    }
		    insertionPoint._assignedNodes = [];
		    var needsSlotChange = false;
		    // distribute nodes from the pool that this selector matches
		    var anyDistributed = false;
		    for (var i=0, l=pool.length, node; i < l; i++) {
		      node=pool[i];
		      // skip nodes that were already used
		      if (!node) {
		        continue;
		      }
		      // distribute this node if it matches
		      if (this$1.matchesInsertionPoint(node, insertionPoint)) {
		        if (node.__prevAssignedSlot != insertionPoint) {
		          needsSlotChange = true;
		        }
		        this$1.distributeNodeInto(node, insertionPoint)
		        // remove this node from the pool
		        pool[i] = undefined;
		        // since at least one node matched, we won't need fallback content
		        anyDistributed = true;
		      }
		    }
		    // Fallback content if nothing was distributed here
		    if (!anyDistributed) {
		      var children = tree.Logical.getChildNodes(insertionPoint);
		      for (var j = 0, node$1; j < children.length; j++) {
		        node$1 = children[j];
		        if (node$1.__prevAssignedSlot != insertionPoint) {
		          needsSlotChange = true;
		        }
		        this$1.distributeNodeInto(node$1, insertionPoint);
		      }
		    }
		    // we're already dirty if a node was newly added to the slot
		    // and we're also dirty if the assigned count decreased.
		    if (prevAssignedNodes) {
		      // TODO(sorvell): the tracking of previously assigned slots
		      // could instead by done with a Set and then we could
		      // avoid needing to iterate here to clear the info.
		      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {
		        prevAssignedNodes[i$1].__prevAssignedSlot = null;
		      }
		      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {
		        needsSlotChange = true;
		      }
		    }
		    this.setDistributedNodesOnInsertionPoint(insertionPoint);
		    if (needsSlotChange) {
		      this._fireSlotChange(insertionPoint);
		    }
		  };
		
		  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {
		    var n$ = slot._assignedNodes;
		    if (n$) {
		      for (var i=0; i < n$.length; i++) {
		        var n = n$[i];
		        if (savePrevious) {
		          n.__prevAssignedSlot = n._assignedSlot;
		        }
		        // only clear if it was previously set to this slot;
		        // this helps ensure that if the node has otherwise been distributed
		        // ignore it.
		        if (n._assignedSlot === slot) {
		          n._assignedSlot = null;
		        }
		      }
		    }
		  };
		
		  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {
		    var slotName = insertionPoint.getAttribute('name');
		    slotName = slotName ? slotName.trim() : '';
		    var slot = node.getAttribute && node.getAttribute('slot');
		    slot = slot ? slot.trim() : '';
		    return (slot == slotName);
		  };
		
		  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {
		    insertionPoint._assignedNodes.push(child);
		    child._assignedSlot = insertionPoint;
		  };
		
		  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {
		    var this$1 = this;
		
		    var n$ = insertionPoint._assignedNodes;
		    insertionPoint._distributedNodes = [];
		    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {
		      if (this$1.isInsertionPoint(n)) {
		        var d$ = n._distributedNodes;
		        if (d$) {
		          for (var j=0; j < d$.length; j++) {
		            insertionPoint._distributedNodes.push(d$[j]);
		          }
		        }
		      } else {
		        insertionPoint._distributedNodes.push(n$[i]);
		      }
		    }
		  };
		
		  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {
		    // NOTE: cannot bubble correctly here so not setting bubbles: true
		    // Safari tech preview does not bubble but chrome does
		    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)
		    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));
		    if (insertionPoint._assignedSlot) {
		      this._fireSlotChange(insertionPoint._assignedSlot);
		    }
		  };
		
		  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {
		    return !(insertionPoint._assignedSlot);
		  };
		
		  return anonymous;
		}())
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		/**
		  Implements a pared down version of ShadowDOM's scoping, which is easy to
		  polyfill across browsers.
		*/
		var ShadyRoot = function ShadyRoot(host) {
		  if (!host) {
		    throw 'Must provide a host';
		  }
		  // NOTE: this strange construction is necessary because
		  // DocumentFragment cannot be subclassed on older browsers.
		  var frag = document.createDocumentFragment();
		  frag.__proto__ = ShadyFragmentMixin;
		  frag._init(host);
		  return frag;
		};
		
		var ShadyMixin = {
		
		  _init: function _init(host) {
		    // NOTE: set a fake local name so this element can be
		    // distinguished from a DocumentFragment when patching.
		    // FF doesn't allow this to be `localName`
		    this.__localName = 'ShadyRoot';
		    // root <=> host
		    host.shadyRoot = this;
		    this.host = host;
		    // logical dom setup
		    tree.Logical.saveChildNodes(host);
		    tree.Logical.saveChildNodes(this);
		    // state flags
		    this._clean = true;
		    this._hasRendered = false;
		    this._distributor = new Distributor(this);
		    this.update();
		  },
		
		  // async render the "top" distributor (this is all that is needed to
		  // distribute this host).
		  update: function update() {
		    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.
		    // Then, in `render`, the top most (in the distribution tree) "dirty" root should be rendered.
		    var distributionRoot = this._findDistributionRoot(this.host);
		    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);
		    if (distributionRoot._clean) {
		      distributionRoot._clean = false;
		      enqueue(function() {
		        distributionRoot.render();
		      });
		    }
		  },
		
		  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)
		  // this should only return a shadowRoot.
		  // returns the host that's the top of this host's distribution tree
		  _findDistributionRoot: function _findDistributionRoot(element) {
		    var root = element.shadyRoot;
		    while (element && this._elementNeedsDistribution(element)) {
		      root = element.getRootNode();
		      element = root && root.host;
		    }
		    return root;
		  },
		
		  // Return true if a host's children includes
		  // an insertion point that selects selectively
		  _elementNeedsDistribution: function _elementNeedsDistribution(element) {
		    var this$1 = this;
		
		    var c$ = tree.Logical.getChildNodes(element);
		    for (var i=0, c; i < c$.length; i++) {
		      c = c$[i];
		      if (this$1._distributor.isInsertionPoint(c)) {
		        return element.getRootNode();
		      }
		    }
		  },
		
		  render: function render() {
		    if (!this._clean) {
		      this._clean = true;
		      if (!this._skipUpdateInsertionPoints) {
		        this.updateInsertionPoints();
		      } else if (!this._hasRendered) {
		        this._insertionPoints = [];
		      }
		      this._skipUpdateInsertionPoints = false;
		      // TODO(sorvell): previous ShadyDom had a fast path here
		      // that would avoid distribution for initial render if
		      // no insertion points exist. We cannot currently do this because
		      // it relies on elements being in the physical shadowRoot element
		      // so that native methods will be used. The current append code
		      // simply provokes distribution in this case and does not put the
		      // nodes in the shadowRoot. This could be done but we'll need to
		      // consider if the special processing is worth the perf gain.
		      // if (!this._hasRendered && !this._insertionPoints.length) {
		      //   tree.Composed.clearChildNodes(this.host);
		      //   tree.Composed.appendChild(this.host, this);
		      // } else {
		      // logical
		      this.distribute();
		      // physical
		      this.compose();
		      this._hasRendered = true;
		    }
		  },
		
		  forceRender: function forceRender() {
		    this._clean = false;
		    this.render();
		  },
		
		  distribute: function distribute() {
		    var dirtyRoots = this._distributor.distribute();
		    for (var i=0; i<dirtyRoots.length; i++) {
		      dirtyRoots[i].forceRender();
		    }
		  },
		
		  updateInsertionPoints: function updateInsertionPoints() {
		    var this$1 = this;
		
		    var i$ = this.__insertionPoints;
		    // if any insertion points have been removed, clear their distribution info
		    if (i$) {
		      for (var i=0, c; i < i$.length; i++) {
		        c = i$[i];
		        if (c.getRootNode() !== this$1) {
		          this$1._distributor.clearAssignedSlots(c);
		        }
		      }
		    }
		    i$ = this._insertionPoints = this._distributor.getInsertionPoints();
		    // ensure insertionPoints's and their parents have logical dom info.
		    // save logical tree info
		    // a. for shadyRoot
		    // b. for insertion points (fallback)
		    // c. for parents of insertion points
		    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {
		      c$1 = i$[i$1];
		      tree.Logical.saveChildNodes(c$1);
		      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));
		    }
		  },
		
		  get _insertionPoints() {
		    if (!this.__insertionPoints) {
		      this.updateInsertionPoints();
		    }
		    return this.__insertionPoints || (this.__insertionPoints = []);
		  },
		
		  set _insertionPoints(insertionPoints) {
		    this.__insertionPoints = insertionPoints;
		  },
		
		  hasInsertionPoint: function hasInsertionPoint() {
		    return this._distributor.hasInsertionPoint();
		  },
		
		  compose: function compose() {
		    // compose self
		    // note: it's important to mark this clean before distribution
		    // so that attachment that provokes additional distribution (e.g.
		    // adding something to your parentNode) works
		    this._composeTree();
		    // TODO(sorvell): See fast paths here in Polymer v1
		    // (these seem unnecessary)
		  },
		
		  // Reify dom such that it is at its correct rendering position
		  // based on logical distribution.
		  _composeTree: function _composeTree() {
		    var this$1 = this;
		
		    this._updateChildNodes(this.host, this._composeNode(this.host));
		    var p$ = this._insertionPoints || [];
		    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {
		      parent = tree.Logical.getParentNode(p);
		      if ((parent !== this$1.host) && (parent !== this$1)) {
		        this$1._updateChildNodes(parent, this$1._composeNode(parent));
		      }
		    }
		  },
		
		  // Returns the list of nodes which should be rendered inside `node`.
		  _composeNode: function _composeNode(node) {
		    var this$1 = this;
		
		    var children = [];
		    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);
		    for (var i = 0; i < c$.length; i++) {
		      var child = c$[i];
		      if (this$1._distributor.isInsertionPoint(child)) {
		        var distributedNodes = child._distributedNodes ||
		          (child._distributedNodes = []);
		        for (var j = 0; j < distributedNodes.length; j++) {
		          var distributedNode = distributedNodes[j];
		          if (this$1.isFinalDestination(child, distributedNode)) {
		            children.push(distributedNode);
		          }
		        }
		      } else {
		        children.push(child);
		      }
		    }
		    return children;
		  },
		
		  isFinalDestination: function isFinalDestination(insertionPoint, node) {
		    return this._distributor.isFinalDestination(
		      insertionPoint, node);
		  },
		
		  // Ensures that the rendered node list inside `container` is `children`.
		  _updateChildNodes: function _updateChildNodes(container, children) {
		    var composed = tree.Composed.getChildNodes(container);
		    var splices = calculateSplices(children, composed);
		    // process removals
		    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {
		      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
		        // check if the node is still where we expect it is before trying
		        // to remove it; this can happen if we move a node and
		        // then schedule its previous host for distribution resulting in
		        // the node being removed here.
		        if (tree.Composed.getParentNode(n) === container) {
		          tree.Composed.removeChild(container, n);
		        }
		        composed.splice(s.index + d, 1);
		      }
		      d -= s.addedCount;
		    }
		    // process adds
		    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare
		      next = composed[s$1.index];
		      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {
		        n$1 = children[j$1];
		        tree.Composed.insertBefore(container, n$1, next);
		        // TODO(sorvell): is this splice strictly needed?
		        composed.splice(j$1, 0, n$1);
		      }
		    }
		  },
		
		  getInsertionPointTag: function getInsertionPointTag() {
		    return this._distributor.insertionPointTag;
		  }
		
		}
		
		var ShadyFragmentMixin = Object.create(DocumentFragment.prototype);
		extend(ShadyFragmentMixin, ShadyMixin);
		
		// let needsUpgrade = window.CustomElements && !CustomElements.useNative;
		
		// function upgradeLogicalChildren(children) {
		//   if (needsUpgrade && children) {
		//     for (let i=0; i < children.length; i++) {
		//       CustomElements.upgrade(children[i]);
		//     }
		//   }
		// }
		
		// render enqueuer/flusher
		var customElements = window.customElements;
		var flushList = [];
		var scheduled;
		var flushCount = 0;
		var flushMax = 100;
		function enqueue(callback) {
		  if (!scheduled) {
		    scheduled = true;
		    promish.then(flush$1);
		  }
		  flushList.push(callback);
		}
		
		function flush$1() {
		  scheduled = false;
		  flushCount++;
		  while (flushList.length) {
		    flushList.shift()();
		  }
		  if (customElements && customElements.flush) {
		    customElements.flush();
		  }
		  // continue flushing after elements are upgraded...
		  var isFlushedMaxed = (flushCount > flushMax);
		  if (flushList.length && !isFlushedMaxed) {
		      flush$1();
		  }
		  flushCount = 0;
		  if (isFlushedMaxed) {
		    throw new Error('Loop detected in ShadyDOM distribution, aborting.')
		  }
		}
		
		flush$1.list = flushList;
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		// Cribbed from ShadowDOM polyfill
		// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28
		/////////////////////////////////////////////////////////////////////////////
		// innerHTML and outerHTML
		
		// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
		var escapeAttrRegExp = /[&\u00A0"]/g;
		var escapeDataRegExp = /[&\u00A0<>]/g;
		
		function escapeReplace(c) {
		  switch (c) {
		    case '&':
		      return '&amp;';
		    case '<':
		      return '&lt;';
		    case '>':
		      return '&gt;';
		    case '"':
		      return '&quot;';
		    case '\u00A0':
		      return '&nbsp;';
		  }
		}
		
		function escapeAttr(s) {
		  return s.replace(escapeAttrRegExp, escapeReplace);
		}
		
		function escapeData(s) {
		  return s.replace(escapeDataRegExp, escapeReplace);
		}
		
		function makeSet(arr) {
		  var set = {};
		  for (var i = 0; i < arr.length; i++) {
		    set[arr[i]] = true;
		  }
		  return set;
		}
		
		// http://www.whatwg.org/specs/web-apps/current-work/#void-elements
		var voidElements = makeSet([
		  'area',
		  'base',
		  'br',
		  'col',
		  'command',
		  'embed',
		  'hr',
		  'img',
		  'input',
		  'keygen',
		  'link',
		  'meta',
		  'param',
		  'source',
		  'track',
		  'wbr'
		]);
		
		var plaintextParents = makeSet([
		  'style',
		  'script',
		  'xmp',
		  'iframe',
		  'noembed',
		  'noframes',
		  'plaintext',
		  'noscript'
		]);
		
		function getOuterHTML(node, parentNode, composed) {
		  switch (node.nodeType) {
		    case Node.ELEMENT_NODE: {
		      var tagName = node.localName;
		      var s = '<' + tagName;
		      var attrs = node.attributes;
		      for (var i = 0, attr; (attr = attrs[i]); i++) {
		        s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
		      }
		      s += '>';
		      if (voidElements[tagName]) {
		        return s;
		      }
		      return s + getInnerHTML(node, composed) + '</' + tagName + '>';
		    }
		    case Node.TEXT_NODE: {
		      var data = node.data;
		      if (parentNode && plaintextParents[parentNode.localName]) {
		        return data;
		      }
		      return escapeData(data);
		    }
		    case Node.COMMENT_NODE: {
		      return '<!--' + node.data + '-->';
		    }
		    default: {
		      window.console.error(node);
		      throw new Error('not implemented');
		    }
		  }
		}
		
		function getInnerHTML(node, composed) {
		  if (node.localName === 'template') {
		    node = node.content;
		  }
		  var s = '';
		  var c$ = composed ? composed(node) : node.childNodes;
		  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {
		    s += getOuterHTML(child, node, composed);
		  }
		  return s;
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var mixinImpl = {
		
		  // Try to add node. Record logical info, track insertion points, perform
		  // distribution iff needed. Return true if the add is handled.
		  addNode: function addNode(container, node, ref_node) {
		    var ownerRoot = this.ownerShadyRootForNode(container);
		    if (ownerRoot) {
		      // optimization: special insertion point tracking
		      if (node.__noInsertionPoint && ownerRoot._clean) {
		        ownerRoot._skipUpdateInsertionPoints = true;
		      }
		      // note: we always need to see if an insertion point is added
		      // since this saves logical tree info; however, invalidation state
		      // needs
		      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);
		      // invalidate insertion points IFF not already invalid!
		      if (ipAdded) {
		        ownerRoot._skipUpdateInsertionPoints = false;
		      }
		    }
		    if (tree.Logical.hasChildNodes(container)) {
		      tree.Logical.recordInsertBefore(node, container, ref_node);
		    }
		    // if not distributing and not adding to host, do a fast path addition
		    var handled = this._maybeDistribute(node, container, ownerRoot) ||
		      container.shadyRoot;
		    return handled;
		  },
		
		  // Try to remove node: update logical info and perform distribution iff
		  // needed. Return true if the removal has been handled.
		  // note that it's possible for both the node's host and its parent
		  // to require distribution... both cases are handled here.
		  removeNode: function removeNode(node) {
		    // important that we want to do this only if the node has a logical parent
		    var logicalParent = tree.Logical.hasParentNode(node) &&
		      tree.Logical.getParentNode(node);
		    var distributed;
		    var ownerRoot = this.ownerShadyRootForNode(node);
		    if (logicalParent) {
		      // distribute node's parent iff needed
		      distributed = this.maybeDistributeParent(node);
		      tree.Logical.recordRemoveChild(node, logicalParent);
		      // remove node from root and distribute it iff needed
		      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||
		        logicalParent.localName === ownerRoot.getInsertionPointTag())) {
		        ownerRoot._skipUpdateInsertionPoints = false;
		        ownerRoot.update();
		      }
		    }
		    this._removeOwnerShadyRoot(node);
		    return distributed;
		  },
		
		
		  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {
		    var observer = node.__dom && node.__dom.observer;
		    if (observer) {
		      if (addedNode) {
		        observer.addedNodes.push(addedNode);
		      }
		      if (removedNode) {
		        observer.removedNodes.push(removedNode);
		      }
		      observer.schedule();
		    }
		  },
		
		  removeNodeFromParent: function removeNodeFromParent(node, parent) {
		    if (parent) {
		      this._scheduleObserver(parent, null, node);
		      this.removeNode(node);
		    } else {
		      this._removeOwnerShadyRoot(node);
		    }
		  },
		
		  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {
		    return Boolean(node.__ownerShadyRoot !== undefined);
		  },
		
		  getRootNode: function getRootNode$1(node) {
		    if (!node || !node.nodeType) {
		      return;
		    }
		    var root = node.__ownerShadyRoot;
		    if (root === undefined) {
		      if (isShadyRoot(node)) {
		        root = node;
		      } else {
		        var parent = tree.Logical.getParentNode(node);
		        root = parent ? this.getRootNode(parent) : node;
		      }
		      // memo-ize result for performance but only memo-ize
		      // result if node is in the document. This avoids a problem where a root
		      // can be cached while an element is inside a fragment.
		      // If this happens and we cache the result, the value can become stale
		      // because for perf we avoid processing the subtree of added fragments.
		      if (document.documentElement.contains(node)) {
		        node.__ownerShadyRoot = root;
		      }
		    }
		    return root;
		  },
		
		  ownerShadyRootForNode: function ownerShadyRootForNode(node) {
		    var root = this.getRootNode(node);
		    if (isShadyRoot(root)) {
		      return root;
		    }
		  },
		
		  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {
		    // TODO(sorvell): technically we should check non-fragment nodes for
		    // <content> children but since this case is assumed to be exceedingly
		    // rare, we avoid the cost and will address with some specific api
		    // when the need arises.  For now, the user must call
		    // distributeContent(true), which updates insertion points manually
		    // and forces distribution.
		    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';
		    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&
		      !node.__noInsertionPoint &&
		      insertionPointTag && node.querySelector(insertionPointTag);
		    var wrappedContent = fragContent &&
		      (tree.Logical.getParentNode(fragContent).nodeType !==
		      Node.DOCUMENT_FRAGMENT_NODE);
		    var hasContent = fragContent || (node.localName === insertionPointTag);
		    // There are 3 possible cases where a distribution may need to occur:
		    // 1. <content> being inserted (the host of the shady root where
		    //    content is inserted needs distribution)
		    // 2. children being inserted into parent with a shady root (parent
		    //    needs distribution)
		    // 3. container is an insertionPoint
		    if (hasContent || (container.localName === insertionPointTag)) {
		      if (ownerRoot) {
		        // note, insertion point list update is handled after node
		        // mutations are complete
		        ownerRoot.update();
		      }
		    }
		    var needsDist = this._nodeNeedsDistribution(container);
		    if (needsDist) {
		      container.shadyRoot.update();
		    }
		    // Return true when distribution will fully handle the composition
		    // Note that if a content was being inserted that was wrapped by a node,
		    // and the parent does not need distribution, return false to allow
		    // the nodes to be added directly, after which children may be
		    // distributed and composed into the wrapping node(s)
		    return needsDist || (hasContent && !wrappedContent);
		  },
		
		  /* note: parent argument is required since node may have an out
		  of date parent at this point; returns true if a <content> is being added */
		  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {
		    var this$1 = this;
		
		    var added;
		    var insertionPointTag = root.getInsertionPointTag();
		    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&
		      !node.__noInsertionPoint) {
		      var c$ = node.querySelectorAll(insertionPointTag);
		      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {
		        np = tree.Logical.getParentNode(n);
		        // don't allow node's parent to be fragment itself
		        if (np === node) {
		          np = parent;
		        }
		        na = this$1._maybeAddInsertionPoint(n, np, root);
		        added = added || na;
		      }
		    } else if (node.localName === insertionPointTag) {
		      tree.Logical.saveChildNodes(parent);
		      tree.Logical.saveChildNodes(node);
		      added = true;
		    }
		    return added;
		  },
		
		  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {
		    return node && node.shadyRoot &&
		      node.shadyRoot.hasInsertionPoint();
		  },
		
		  _removeDistributedChildren: function _removeDistributedChildren(root, container) {
		    var this$1 = this;
		
		    var hostNeedsDist;
		    var ip$ = root._insertionPoints;
		    for (var i=0; i<ip$.length; i++) {
		      var insertionPoint = ip$[i];
		      if (this$1._contains(container, insertionPoint)) {
		        var dc$ = insertionPoint.assignedNodes({flatten: true});
		        for (var j=0; j<dc$.length; j++) {
		          hostNeedsDist = true;
		          var node = dc$[j];
		          var parent = tree.Composed.getParentNode(node);
		          if (parent) {
		            tree.Composed.removeChild(parent, node);
		          }
		        }
		      }
		    }
		    return hostNeedsDist;
		  },
		
		  _contains: function _contains(container, node) {
		    while (node) {
		      if (node == container) {
		        return true;
		      }
		      node = tree.Logical.getParentNode(node);
		    }
		  },
		
		  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {
		    var this$1 = this;
		
		    // optimization: only reset the tree if node is actually in a root
		    if (this._hasCachedOwnerRoot(node)) {
		      var c$ = tree.Logical.getChildNodes(node);
		      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {
		        this$1._removeOwnerShadyRoot(n);
		      }
		    }
		    node.__ownerShadyRoot = undefined;
		  },
		
		  // TODO(sorvell): This will fail if distribution that affects this
		  // question is pending; this is expected to be exceedingly rare, but if
		  // the issue comes up, we can force a flush in this case.
		  firstComposedNode: function firstComposedNode(insertionPoint) {
		    var n$ = insertionPoint.assignedNodes({flatten: true});
		    var root = this.getRootNode(insertionPoint);
		    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
		      // means that we're composed to this spot.
		      if (root.isFinalDestination(insertionPoint, n)) {
		        return n;
		      }
		    }
		  },
		
		  clearNode: function clearNode(node) {
		    while (node.firstChild) {
		      node.removeChild(node.firstChild);
		    }
		  },
		
		  maybeDistributeParent: function maybeDistributeParent(node) {
		    var parent = tree.Logical.getParentNode(node);
		    if (this._nodeNeedsDistribution(parent)) {
		      parent.shadyRoot.update();
		      return true;
		    }
		  },
		
		  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {
		    if (name === 'slot') {
		      this.maybeDistributeParent(node);
		    } else if (node.localName === 'slot' && name === 'name') {
		      var root = this.ownerShadyRootForNode(node);
		      if (root) {
		        root.update();
		      }
		    }
		  },
		
		  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,
		  // but it's also generally useful to recurse through the element tree
		  // and is used by Polymer's styling system.
		  query: function query(node, matcher, halter) {
		    var list = [];
		    this._queryElements(tree.Logical.getChildNodes(node), matcher,
		      halter, list);
		    return list;
		  },
		
		  _queryElements: function _queryElements(elements, matcher, halter, list) {
		    var this$1 = this;
		
		    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {
		      if (c.nodeType === Node.ELEMENT_NODE &&
		          this$1._queryElement(c, matcher, halter, list)) {
		        return true;
		      }
		    }
		  },
		
		  _queryElement: function _queryElement(node, matcher, halter, list) {
		    var result = matcher(node);
		    if (result) {
		      list.push(node);
		    }
		    if (halter && halter(result)) {
		      return result;
		    }
		    this._queryElements(tree.Logical.getChildNodes(node), matcher,
		      halter, list);
		  },
		
		  activeElementForNode: function activeElementForNode(node) {
		    var this$1 = this;
		
		    var active = document.activeElement;
		    if (!active) {
		      return null;
		    }
		    var isShadyRoot$$1 = !!(isShadyRoot(node));
		    if (node !== document) {
		      // If this node isn't a document or shady root, then it doesn't have
		      // an active element.
		      if (!isShadyRoot$$1) {
		        return null;
		      }
		      // If this shady root's host is the active element or the active
		      // element is not a descendant of the host (in the composed tree),
		      // then it doesn't have an active element.
		      if (node.host === active ||
		          !node.host.contains(active)) {
		        return null;
		      }
		    }
		    // This node is either the document or a shady root of which the active
		    // element is a (composed) descendant of its host; iterate upwards to
		    // find the active element's most shallow host within it.
		    var activeRoot = this.ownerShadyRootForNode(active);
		    while (activeRoot && activeRoot !== node) {
		      active = activeRoot.host;
		      activeRoot = this$1.ownerShadyRootForNode(active);
		    }
		    if (node === document) {
		      // This node is the document, so activeRoot should be null.
		      return activeRoot ? null : active;
		    } else {
		      // This node is a non-document shady root, and it should be
		      // activeRoot.
		      return activeRoot === node ? active : null;
		    }
		  }
		
		};
		
		var nativeCloneNode = Element.prototype.cloneNode;
		var nativeImportNode = Document.prototype.importNode;
		var nativeSetAttribute = Element.prototype.setAttribute;
		var nativeRemoveAttribute = Element.prototype.removeAttribute;
		
		var setAttribute = function(attr, value) {
		  if (window.ShadyCSS && attr === 'class') {
		    window.ShadyCSS.setElementClass(this, value);
		  } else {
		    nativeSetAttribute.call(this, attr, value);
		  }
		}
		
		var NodeMixin = {};
		
		Object.defineProperties(NodeMixin, {
		
		  parentElement: {
		    get: function get() {
		      return tree.Logical.getParentNode(this);
		    },
		    configurable: true
		  },
		
		  parentNode: {
		    get: function get$1() {
		      return tree.Logical.getParentNode(this);
		    },
		    configurable: true
		  },
		
		  nextSibling: {
		    get: function get$2() {
		      return tree.Logical.getNextSibling(this);
		    },
		    configurable: true
		  },
		
		  previousSibling: {
		    get: function get$3() {
		      return tree.Logical.getPreviousSibling(this);
		    },
		    configurable: true
		  },
		
		  nextElementSibling: {
		    get: function get$4() {
		      return tree.Logical.getNextElementSibling(this);
		    },
		    configurable: true
		  },
		
		  previousElementSibling: {
		    get: function get$5() {
		      return tree.Logical.getPreviousElementSibling(this);
		    },
		    configurable: true
		  },
		
		  assignedSlot: {
		    get: function get$6() {
		      return this._assignedSlot;
		    },
		    configurable: true
		  }
		});
		
		var FragmentMixin = {
		
		  appendChild: function appendChild(node) {
		    return this.insertBefore(node);
		  },
		
		  // cases in which we may not be able to just do standard native call
		  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot
		  // has an insertion point)
		  // 2. container is a shadyRoot (don't distribute, instead set
		  // container to container.host.
		  // 3. node is <content> (host of container needs distribution)
		  insertBefore: function insertBefore(node, ref_node) {
		    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {
		      throw Error('The ref_node to be inserted before is not a child ' +
		        'of this node');
		    }
		    // remove node from its current position iff it's in a tree.
		    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
		      var parent = tree.Logical.getParentNode(node);
		      mixinImpl.removeNodeFromParent(node, parent);
		    }
		    if (!mixinImpl.addNode(this, node, ref_node)) {
		      if (ref_node) {
		        // if ref_node is an insertion point replace with first distributed node
		        var root = mixinImpl.ownerShadyRootForNode(ref_node);
		        if (root) {
		          ref_node = ref_node.localName === root.getInsertionPointTag() ?
		            mixinImpl.firstComposedNode(ref_node) : ref_node;
		        }
		      }
		      // if adding to a shadyRoot, add to host instead
		      var container = isShadyRoot(this) ?
		        this.host : this;
		      if (ref_node) {
		        tree.Composed.insertBefore(container, node, ref_node);
		      } else {
		        tree.Composed.appendChild(container, node);
		      }
		    }
		    mixinImpl._scheduleObserver(this, node);
		    return node;
		  },
		
		  /**
		    Removes the given `node` from the element's `lightChildren`.
		    This method also performs dom composition.
		  */
		  removeChild: function removeChild(node) {
		    if (tree.Logical.getParentNode(node) !== this) {
		      throw Error('The node to be removed is not a child of this node: ' +
		        node);
		    }
		    if (!mixinImpl.removeNode(node)) {
		      // if removing from a shadyRoot, remove form host instead
		      var container = isShadyRoot(this) ?
		        this.host :
		        this;
		      // not guaranteed to physically be in container; e.g.
		      // undistributed nodes.
		      var parent = tree.Composed.getParentNode(node);
		      if (container === parent) {
		        tree.Composed.removeChild(container, node);
		      }
		    }
		    mixinImpl._scheduleObserver(this, null, node);
		    return node;
		  },
		
		  replaceChild: function replaceChild(node, ref_node) {
		    this.insertBefore(node, ref_node);
		    this.removeChild(ref_node);
		    return node;
		  },
		
		  // TODO(sorvell): consider doing native QSA and filtering results.
		  querySelector: function querySelector(selector) {
		    // match selector and halt on first result.
		    var result = mixinImpl.query(this, function(n) {
		      return matchesSelector(n, selector);
		    }, function(n) {
		      return Boolean(n);
		    })[0];
		    return result || null;
		  },
		
		  querySelectorAll: function querySelectorAll(selector) {
		    return mixinImpl.query(this, function(n) {
		      return matchesSelector(n, selector);
		    });
		  },
		
		  cloneNode: function cloneNode(deep) {
		    if (this.localName == 'template') {
		      return nativeCloneNode.call(this, deep);
		    } else {
		      var n = nativeCloneNode.call(this, false);
		      if (deep) {
		        var c$ = this.childNodes;
		        for (var i=0, nc; i < c$.length; i++) {
		          nc = c$[i].cloneNode(true);
		          n.appendChild(nc);
		        }
		      }
		      return n;
		    }
		  },
		
		  importNode: function importNode(externalNode, deep) {
		    // for convenience use this node's ownerDoc if the node isn't a document
		    var doc = this instanceof Document ? this :
		      this.ownerDocument;
		    var n = nativeImportNode.call(doc, externalNode, false);
		    if (deep) {
		      var c$ = tree.Logical.getChildNodes(externalNode);
		      common.patchNode(n);
		      for (var i=0, nc; i < c$.length; i++) {
		        nc = doc.importNode(c$[i], true);
		        n.appendChild(nc);
		      }
		    }
		    return n;
		  }
		};
		
		Object.defineProperties(FragmentMixin, {
		
		  childNodes: {
		    get: function get$7() {
		      var c$ = tree.Logical.getChildNodes(this);
		      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);
		    },
		    configurable: true
		  },
		
		  children: {
		    get: function get$8() {
		      if (tree.Logical.hasChildNodes(this)) {
		        return Array.prototype.filter.call(this.childNodes, function(n) {
		          return (n.nodeType === Node.ELEMENT_NODE);
		        });
		      } else {
		        return tree.arrayCopyChildren(this);
		      }
		    },
		    configurable: true
		  },
		
		  firstChild: {
		    get: function get$9() {
		      return tree.Logical.getFirstChild(this);
		    },
		    configurable: true
		  },
		
		  lastChild: {
		    get: function get$10() {
		      return tree.Logical.getLastChild(this);
		    },
		    configurable: true
		  },
		
		  firstElementChild: {
		    get: function get$11() {
		      return tree.Logical.getFirstElementChild(this);
		    },
		    configurable: true
		  },
		
		  lastElementChild: {
		    get: function get$12() {
		      return tree.Logical.getLastElementChild(this);
		    },
		    configurable: true
		  },
		
		  // TODO(srovell): strictly speaking fragments do not have textContent
		  // or innerHTML but ShadowRoots do and are not easily distinguishable.
		  // textContent / innerHTML
		  textContent: {
		    get: function get$13() {
		      if (this.childNodes) {
		        var tc = [];
		        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {
		          if (c.nodeType !== Node.COMMENT_NODE) {
		            tc.push(c.textContent);
		          }
		        }
		        return tc.join('');
		      }
		      return '';
		    },
		    set: function set(text) {
		      mixinImpl.clearNode(this);
		      if (text) {
		        this.appendChild(document.createTextNode(text));
		      }
		    },
		    configurable: true
		  },
		
		  innerHTML: {
		    get: function get$14() {
		      return getInnerHTML(this);
		    },
		    set: function set$1(text) {
		      var this$1 = this;
		
		      mixinImpl.clearNode(this);
		      var d = document.createElement('div');
		      d.innerHTML = text;
		      // here, appendChild may move nodes async so we cannot rely
		      // on node position when copying
		      var c$ = tree.arrayCopyChildNodes(d);
		      for (var i=0; i < c$.length; i++) {
		        this$1.appendChild(c$[i]);
		      }
		    },
		    configurable: true
		  }
		
		});
		
		var ElementMixin = {
		
		  // TODO(sorvell): should only exist on <slot>
		  assignedNodes: function assignedNodes(options) {
		    return (options && options.flatten ? this._distributedNodes :
		      this._assignedNodes) || [];
		  },
		
		
		  setAttribute: function setAttribute$1(name, value) {
		    setAttribute.call(this, name, value);
		    mixinImpl.maybeDistributeAttributeChange(this, name);
		  },
		
		  removeAttribute: function removeAttribute(name) {
		    nativeRemoveAttribute.call(this, name);
		    mixinImpl.maybeDistributeAttributeChange(this, name);
		  }
		
		};
		
		Object.defineProperties(ElementMixin, {
		
		  shadowRoot: {
		    get: function get$15() {
		      return this.shadyRoot;
		    }
		  },
		
		  slot: {
		    get: function get$16() {
		      return this.getAttribute('slot');
		    },
		    set: function set$2(value) {
		      this.setAttribute('slot', value);
		    }
		  }
		
		});
		
		var activeElementDescriptor = {
		  get: function get$17() {
		    return mixinImpl.activeElementForNode(this);
		  }
		}
		
		var ActiveElementMixin = {};
		Object.defineProperties(ActiveElementMixin, {
		  activeElement: activeElementDescriptor
		});
		
		var UnderActiveElementMixin = {};
		Object.defineProperties(UnderActiveElementMixin, {
		  _activeElement: activeElementDescriptor
		});
		
		var Mixins = {
		
		  Node: extendAll({__patched: 'Node'}, NodeMixin),
		
		  Fragment: extendAll({__patched: 'Fragment'},
		    NodeMixin, FragmentMixin, ActiveElementMixin),
		
		  Element: extendAll({__patched: 'Element'},
		    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),
		
		  // Note: activeElement cannot be patched on document!
		  Document: extendAll({__patched: 'Document'},
		    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)
		
		};
		
		var getRootNode = function(node) {
		  return mixinImpl.getRootNode(node);
		}
		
		function filterMutations(mutations, target) {
		  var targetRootNode = getRootNode(target);
		  return mutations.filter(function(mutation) {
		    var mutationInScope = (targetRootNode === getRootNode(mutation.target));
		    if (mutationInScope && mutation.addedNodes) {
		      var nodes = Array.from(mutation.addedNodes).filter(function(n) {
		        return (targetRootNode === getRootNode(n));
		      });
		      Object.defineProperty(mutation, 'addedNodes', {
		        value: nodes,
		        configurable: true
		      });
		    }
		    return mutationInScope &&
		      (!mutation.addedNodes || mutation.addedNodes.length);
		  });
		}
		
		// const promise = Promise.resolve();
		
		var AsyncObserver = function AsyncObserver() {
		  this._scheduled = false;
		  this.addedNodes = [];
		  this.removedNodes = [];
		  this.callbacks = new Set();
		};
		
		AsyncObserver.prototype.schedule = function schedule () {
		    var this$1 = this;
		
		  if (!this._scheduled) {
		    this._scheduled = true;
		    promish.then(function () {
		      this$1.flush();
		    });
		  }
		};
		
		AsyncObserver.prototype.flush = function flush () {
		  if (this._scheduled) {
		    this._scheduled = false;
		    var mutations = this.takeRecords();
		    if (mutations.length) {
		      this.callbacks.forEach(function(cb) {
		        cb(mutations);
		      });
		    }
		  }
		};
		
		AsyncObserver.prototype.takeRecords = function takeRecords () {
		  if (this.addedNodes.length || this.removedNodes.length) {
		    var mutations = [{
		      addedNodes: this.addedNodes,
		      removedNodes: this.removedNodes
		    }];
		    this.addedNodes = [];
		    this.removedNodes = [];
		    return mutations;
		  }
		  return [];
		};
		
		// TODO(sorvell): consider instead polyfilling MutationObserver
		// directly so that users do not have to fork their code.
		// Supporting the entire api may be challenging: e.g. filtering out
		// removed nodes in the wrong scope and seeing non-distributing
		// subtree child mutations.
		var observeChildren = function(node, callback) {
		  common.patchNode(node);
		  if (!node.__dom.observer) {
		    node.__dom.observer = new AsyncObserver();
		  }
		  node.__dom.observer.callbacks.add(callback);
		  var observer = node.__dom.observer;
		  return {
		    _callback: callback,
		    _observer: observer,
		    _node: node,
		    takeRecords: function takeRecords() {
		      return observer.takeRecords()
		    }
		  };
		}
		
		var unobserveChildren = function(handle) {
		  var observer = handle && handle._observer;
		  if (observer) {
		    observer.callbacks.delete(handle._callback);
		    if (!observer.callbacks.size) {
		      handle._node.__dom.observer = null;
		    }
		  }
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		/**
		 * Patches elements that interacts with ShadyDOM
		 * such that tree traversal and mutation apis act like they would under
		 * ShadowDOM.
		 *
		 * This import enables seemless interaction with ShadyDOM powered
		 * custom elements, enabling better interoperation with 3rd party code,
		 * libraries, and frameworks that use DOM tree manipulation apis.
		 */
		
		var patchedCount = 0;
		
		var log = false;
		
		var patchImpl = {
		
		  canPatchNode: function(node) {
		    switch (node) {
		      case document.head:
		      case document.documentElement:
		        return false;
		      default:
		        return true;
		    }
		  },
		
		  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(
		    window.Node.prototype, 'textContent')),
		
		  patch: function(node) {
		    patchedCount++;
		    log && window.console.warn('patch node', node);
		    if (this.hasPrototypeDescriptors) {
		      patchPrototype(node, this.mixinForObject(node));
		    } else {
		      window.console.warn('Patching instance rather than prototype', node);
		      extend(node, this.mixinForNode(node));
		    }
		  },
		
		  mixinForObject: function(obj) {
		    switch (obj.nodeType) {
		      case Node.ELEMENT_NODE:
		        return Mixins.Element;
		      case Node.DOCUMENT_FRAGMENT_NODE:
		        return Mixins.Fragment;
		      case Node.DOCUMENT_NODE:
		        return Mixins.Document;
		      case Node.TEXT_NODE:
		      case Node.COMMENT_NODE:
		        return Mixins.Node;
		    }
		  },
		
		  unpatch: function(obj) {
		    if (obj.__sourceProto) {
		      obj.__proto__ = obj.__sourceProto;
		
		    }
		    // TODO(sorvell): implement unpatching for non-proto patchable browsers
		  }
		
		};
		
		function patchNode(node) {
		  if (!settings.inUse) {
		    return;
		  }
		  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {
		    tree.saveChildNodes(node);
		    patchImpl.patch(node);
		  }
		}
		
		function unpatchNode(node) {
		  patchImpl.unpatch(node);
		}
		
		function isNodePatched(node) {
		  return Boolean(node.__patched);
		}
		
		// TODO(sorvell): fake export
		common.patchNode = patchNode;
		common.isNodePatched = isNodePatched;
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var origAddEventListener = Element.prototype.addEventListener;
		var origRemoveEventListener = Element.prototype.removeEventListener;
		
		// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937
		var alwaysComposed = {
		  blur: true,
		  focus: true,
		  focusin: true,
		  focusout: true,
		  click: true,
		  dblclick: true,
		  mousedown: true,
		  mouseenter: true,
		  mouseleave: true,
		  mousemove: true,
		  mouseout: true,
		  mouseover: true,
		  mouseup: true,
		  wheel: true,
		  beforeinput: true,
		  input: true,
		  keydown: true,
		  keyup: true,
		  compositionstart: true,
		  compositionupdate: true,
		  compositionend: true,
		  touchstart: true,
		  touchend: true,
		  touchmove: true,
		  touchcancel: true,
		  pointerover: true,
		  pointerenter: true,
		  pointerdown: true,
		  pointermove: true,
		  pointerup: true,
		  pointercancel: true,
		  pointerout: true,
		  pointerleave: true,
		  gotpointercapture: true,
		  lostpointercapture: true,
		  dragstart: true,
		  drag: true,
		  dragenter: true,
		  dragleave: true,
		  dragover: true,
		  drop: true,
		  dragend: true,
		  DOMActivate: true,
		  DOMFocusIn: true,
		  DOMFocusOut: true,
		  keypress: true
		};
		
		function pathComposer(startNode, composed) {
		  var composedPath = [];
		  var current = startNode;
		  var startRoot = startNode === window ? window : startNode.getRootNode();
		  while (current) {
		    composedPath.push(current);
		    if (current.assignedSlot) {
		      current = current.assignedSlot;
		    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {
		      current = current.host;
		    } else {
		      current = current.parentNode;
		    }
		  }
		  // event composedPath includes window when startNode's ownerRoot is document
		  if (composedPath[composedPath.length - 1] === document) {
		    composedPath.push(window);
		  }
		  return composedPath;
		}
		
		function retarget(refNode, path) {
		  if (!isShadyRoot) {
		    return refNode;
		  }
		  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
		  // shadow-including inclusive ancestor, return ANCESTOR.
		  var refNodePath = pathComposer(refNode, true);
		  var p$ = path;
		  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
		    ancestor = p$[i];
		    root = ancestor === window ? window : ancestor.getRootNode();
		    if (root !== lastRoot) {
		      rootIdx = refNodePath.indexOf(root);
		      lastRoot = root;
		    }
		    if (!isShadyRoot(root) || rootIdx > -1) {
		      return ancestor;
		    }
		  }
		}
		
		var EventMixin = {
		
		  __patched: 'Event',
		
		  get composed() {
		    if (this.isTrusted && this.__composed === undefined) {
		      this.__composed = alwaysComposed[this.type];
		    }
		    return this.__composed || false;
		  },
		
		  composedPath: function composedPath() {
		    if (!this.__composedPath) {
		      this.__composedPath = pathComposer(this.__target, this.composed);
		    }
		    return this.__composedPath;
		  },
		
		  get target() {
		    return retarget(this.currentTarget, this.composedPath());
		  },
		
		  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting
		  get relatedTarget() {
		    if (!this.__relatedTarget) {
		      return null;
		    }
		    if (!this.__relatedTargetComposedPath) {
		      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);
		    }
		    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget
		    return retarget(this.currentTarget, this.__relatedTargetComposedPath);
		  },
		  stopPropagation: function stopPropagation() {
		    Event.prototype.stopPropagation.call(this);
		    this.__propagationStopped = true;
		  },
		  stopImmediatePropagation: function stopImmediatePropagation() {
		    Event.prototype.stopImmediatePropagation.call(this);
		    this.__immediatePropagationStopped = true;
		    this.__propagationStopped = true;
		  }
		
		};
		
		function mixinComposedFlag(Base) {
		  // NOTE: avoiding use of `class` here so that transpiled output does not
		  // try to do `Base.call` with a dom construtor.
		  var klazz = function(type, options) {
		    var event = new Base(type, options);
		    event.__composed = options && Boolean(options.composed);
		    return event;
		  }
		  // put constructor properties on subclass
		  mixin(klazz, Base);
		  klazz.prototype = Base.prototype;
		  return klazz;
		}
		
		var nonBubblingEventsToRetarget = {
		  focus: true,
		  blur: true
		};
		
		function fireHandlers(event, node, phase) {
		  var hs = node.__handlers && node.__handlers[event.type] &&
		    node.__handlers[event.type][phase];
		  if (hs) {
		    for (var i = 0, fn; (fn = hs[i]); i++) {
		      fn.call(node, event);
		      if (event.__immediatePropagationStopped) {
		        return;
		      }
		    }
		  }
		}
		
		function retargetNonBubblingEvent(e) {
		  var path = e.composedPath();
		  var node;
		  // override `currentTarget` to let patched `target` calculate correctly
		  Object.defineProperty(e, 'currentTarget', {
		    get: function() {
		      return node;
		    },
		    configurable: true
		  });
		  for (var i = path.length - 1; i >= 0; i--) {
		    node = path[i];
		    // capture phase fires all capture handlers
		    fireHandlers(e, node, 'capture');
		    if (e.__propagationStopped) {
		      return;
		    }
		  }
		
		  // set the event phase to `AT_TARGET` as in spec
		  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});
		
		  // the event only needs to be fired when owner roots change when iterating the event path
		  // keep track of the last seen owner root
		  var lastFiredRoot;
		  for (var i$1 = 0; i$1 < path.length; i$1++) {
		    node = path[i$1];
		    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {
		      fireHandlers(e, node, 'bubble');
		      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway
		      if (node !== window) {
		        lastFiredRoot = node.getRootNode();
		      }
		      if (e.__propagationStopped) {
		        return;
		      }
		    }
		  }
		}
		
		function addEventListener(type, fn, optionsOrCapture) {
		  var this$1 = this;
		
		  if (!fn) {
		    return;
		  }
		
		  // The callback `fn` might be used for multiple nodes/events. Since we generate
		  // a wrapper function, we need to keep track of it when we remove the listener.
		  // It's more efficient to store the node/type/options information as Array in
		  // `fn` itself rather than the node (we assume that the same callback is used
		  // for few nodes at most, whereas a node will likely have many event listeners).
		  // NOTE(valdrin) invoking external functions is costly, inline has better perf.
		  var capture, once, passive;
		  if (typeof optionsOrCapture === 'object') {
		    capture = Boolean(optionsOrCapture.capture);
		    once = Boolean(optionsOrCapture.once);
		    passive = Boolean(optionsOrCapture.passive);
		  } else {
		    capture = Boolean(optionsOrCapture);
		    once = false;
		    passive = false;
		  }
		  if (fn.__eventWrappers) {
		    // Stop if the wrapper function has already been created.
		    for (var i = 0; i < fn.__eventWrappers.length; i++) {
		      if (fn.__eventWrappers[i].node === this$1 &&
		          fn.__eventWrappers[i].type === type &&
		          fn.__eventWrappers[i].capture === capture &&
		          fn.__eventWrappers[i].once === once &&
		          fn.__eventWrappers[i].passive === passive) {
		        return;
		      }
		    }
		  } else {
		    fn.__eventWrappers = [];
		  }
		
		  var wrapperFn = function(e) {
		    // Support `once` option.
		    if (once) {
		      this.removeEventListener(type, fn, optionsOrCapture);
		    }
		    if (!e.__target) {
		      e.__target = e.target;
		      e.__relatedTarget = e.relatedTarget;
		      patchPrototype(e, EventMixin);
		    }
		    // There are two critera that should stop events from firing on this node
		    // 1. the event is not composed and the current node is not in the same root as the target
		    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node
		    if (e.composed || e.composedPath().indexOf(this) > -1) {
		      if (e.eventPhase === Event.BUBBLING_PHASE) {
		        if (e.target === e.relatedTarget) {
		          e.stopImmediatePropagation();
		          return;
		        }
		      }
		      return fn(e);
		    }
		  };
		  // Store the wrapper information.
		  fn.__eventWrappers.push({
		    node: this,
		    type: type,
		    capture: capture,
		    once: once,
		    passive: passive,
		    wrapperFn: wrapperFn
		  });
		
		  if (nonBubblingEventsToRetarget[type]) {
		    this.__handlers = this.__handlers || {};
		    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};
		    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);
		  } else {
		    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
		  }
		}
		
		function removeEventListener(type, fn, optionsOrCapture) {
		  var this$1 = this;
		
		  if (!fn) {
		    return;
		  }
		
		  // NOTE(valdrin) invoking external functions is costly, inline has better perf.
		  var capture, once, passive;
		  if (typeof optionsOrCapture === 'object') {
		    capture = Boolean(optionsOrCapture.capture);
		    once = Boolean(optionsOrCapture.once);
		    passive = Boolean(optionsOrCapture.passive);
		  } else {
		    capture = Boolean(optionsOrCapture);
		    once = false;
		    passive = false;
		  }
		  // Search the wrapped function.
		  var wrapperFn = undefined;
		  if (fn.__eventWrappers) {
		    for (var i = 0; i < fn.__eventWrappers.length; i++) {
		      if (fn.__eventWrappers[i].node === this$1 &&
		          fn.__eventWrappers[i].type === type &&
		          fn.__eventWrappers[i].capture === capture &&
		          fn.__eventWrappers[i].once === once &&
		          fn.__eventWrappers[i].passive === passive) {
		        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;
		        // Cleanup.
		        if (!fn.__eventWrappers.length) {
		          fn.__eventWrappers = undefined;
		        }
		        break;
		      }
		    }
		  }
		
		  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);
		  if (wrapperFn && nonBubblingEventsToRetarget[type] &&
		      this.__handlers && this.__handlers[type]) {
		    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];
		    var idx = arr.indexOf(wrapperFn);
		    if (idx > -1) {
		      arr.splice(idx, 1);
		    }
		  }
		}
		
		function activateFocusEventOverrides() {
		  for (var ev in nonBubblingEventsToRetarget) {
		    window.addEventListener(ev, function(e) {
		      if (!e.__target) {
		        e.__target = e.target;
		        e.__relatedTarget = e.relatedTarget;
		        patchPrototype(e, EventMixin);
		        retargetNonBubblingEvent(e);
		        e.stopImmediatePropagation();
		      }
		    }, true);
		  }
		}
		
		
		var PatchedEvent = mixinComposedFlag(Event);
		var PatchedCustomEvent = mixinComposedFlag(CustomEvent);
		var PatchedMouseEvent = mixinComposedFlag(MouseEvent);
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		/**
		 * Patches elements that interacts with ShadyDOM
		 * such that tree traversal and mutation apis act like they would under
		 * ShadowDOM.
		 *
		 * This import enables seemless interaction with ShadyDOM powered
		 * custom elements, enabling better interoperation with 3rd party code,
		 * libraries, and frameworks that use DOM tree manipulation apis.
		 */
		
		if (settings.inUse) {
		
		  window.ShadyDOM = {
		    tree: tree,
		    getNativeProperty: getNativeProperty,
		    patch: patchNode,
		    isPatched: isNodePatched,
		    unpatch: unpatchNode,
		    isShadyRoot: isShadyRoot,
		    enqueue: enqueue,
		    flush: flush$1,
		    inUse: settings.inUse,
		    filterMutations: filterMutations,
		    observeChildren: observeChildren,
		    unobserveChildren: unobserveChildren
		  };
		
		  var createRootAndEnsurePatched = function(node) {
		    // TODO(sorvell): need to ensure ancestors are patched but this introduces
		    // a timing problem with gathering composed children.
		    // (1) currently the child list is crawled and patched when patching occurs
		    // (this needs to change)
		    // (2) we can only patch when an element has received its parsed children
		    // because we cannot detect them when inserted by parser.
		    // let ancestor = node;
		    // while (ancestor) {
		    //   patchNode(ancestor);
		    //   ancestor = ancestor.parentNode || ancestor.host;
		    // }
		    patchNode(node);
		    var root = new ShadyRoot(node);
		    patchNode(root);
		    return root;
		  }
		
		  Element.prototype.attachShadow = function() {
		    return createRootAndEnsurePatched(this);
		  }
		
		  Node.prototype.addEventListener = addEventListener;
		  Node.prototype.removeEventListener = removeEventListener;
		  Event = PatchedEvent;
		  CustomEvent = PatchedCustomEvent;
		  MouseEvent = PatchedMouseEvent;
		  activateFocusEventOverrides();
		
		  Object.defineProperty(Node.prototype, 'isConnected', {
		    get: function get() {
		      return document.documentElement.contains(this);
		    },
		    configurable: true
		  });
		
		  Node.prototype.getRootNode = function(options) {
		    return getRootNode(this, options);
		  }
		
		  Object.defineProperty(Element.prototype, 'slot', {
		    get: function get$1() {
		      return this.getAttribute('slot');
		    },
		    set: function set(value) {
		      this.setAttribute('slot', value);
		    },
		    configurable: true
		  });
		
		  Object.defineProperty(Node.prototype, 'assignedSlot', {
		    get: function get$2() {
		      return this._assignedSlot || null;
		    },
		    configurable: true
		  });
		
		  Element.prototype.setAttribute = setAttribute;
		
		  Object.defineProperty(Element.prototype, 'className', {
		    get: function get$3() {
		      return this.getAttribute('class');
		    },
		    set: function set$1(value) {
		      this.setAttribute('class', value);
		    },
		    configurable: true
		  });
		
		  // TODO(sorvell): super experimental auto patching of document fragment
		  // via appendChild. This either needs to be expanded or contracted.
		  // DocumentFragment.prototype.appendChild = function(node) {
		  //   patchNode(this);
		  //   return this.appendChild(node);
		  // }
		
		}
		
		}());
		
		//# sourceMappingURL=shadydom.min.js.map
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		(function () {
		'use strict';
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		/*
		Extremely simple css parser. Intended to be not more than what we need
		and definitely not necessarily correct =).
		*/
		
		// given a string of css, return a simple rule tree
		
		function parse(text) {
		  text = clean(text);
		  return parseCss(lex(text), text);
		}
		
		// remove stuff we don't care about that may hinder parsing
		function clean(cssText) {
		  return cssText.replace(RX.comments, '').replace(RX.port, '');
		}
		
		// super simple {...} lexer that returns a node tree
		function lex(text) {
		  var root = {
		    start: 0,
		    end: text.length
		  };
		  var n = root;
		  for (var i = 0, l = text.length; i < l; i++) {
		    if (text[i] === OPEN_BRACE) {
		      if (!n.rules) {
		        n.rules = [];
		      }
		      var p = n;
		      var previous = p.rules[p.rules.length - 1];
		      n = {
		        start: i + 1,
		        parent: p,
		        previous: previous
		      };
		      p.rules.push(n);
		    } else if (text[i] === CLOSE_BRACE) {
		      n.end = i + 1;
		      n = n.parent || root;
		    }
		  }
		  return root;
		}
		
		// add selectors/cssText to node tree
		function parseCss(node, text) {
		  var t = text.substring(node.start, node.end - 1);
		  node.parsedCssText = node.cssText = t.trim();
		  if (node.parent) {
		    var ss = node.previous ? node.previous.end : node.parent.start;
		    t = text.substring(ss, node.start - 1);
		    t = _expandUnicodeEscapes(t);
		    t = t.replace(RX.multipleSpaces, ' ');
		    // TODO(sorvell): ad hoc; make selector include only after last ;
		    // helps with mixin syntax
		    t = t.substring(t.lastIndexOf(';') + 1);
		    var s = node.parsedSelector = node.selector = t.trim();
		    node.atRule = s.indexOf(AT_START) === 0;
		    // note, support a subset of rule types...
		    if (node.atRule) {
		      if (s.indexOf(MEDIA_START) === 0) {
		        node.type = types.MEDIA_RULE;
		      } else if (s.match(RX.keyframesRule)) {
		        node.type = types.KEYFRAMES_RULE;
		        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();
		      }
		    } else {
		      if (s.indexOf(VAR_START) === 0) {
		        node.type = types.MIXIN_RULE;
		      } else {
		        node.type = types.STYLE_RULE;
		      }
		    }
		  }
		  var r$ = node.rules;
		  if (r$) {
		    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
		      parseCss(r, text);
		    }
		  }
		  return node;
		}
		
		// conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
		// expanded form that doesn't require trailing space `\000033`
		function _expandUnicodeEscapes(s) {
		  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
		    var code = arguments[1],
		        repeat = 6 - code.length;
		    while (repeat--) {
		      code = '0' + code;
		    }
		    return '\\' + code;
		  });
		}
		
		// stringify parsed css.
		function stringify(node, preserveProperties, text) {
		  text = text || '';
		  // calc rule cssText
		  var cssText = '';
		  if (node.cssText || node.rules) {
		    var r$ = node.rules;
		    if (r$ && !_hasMixinRules(r$)) {
		      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
		        cssText = stringify(r, preserveProperties, cssText);
		      }
		    } else {
		      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);
		      cssText = cssText.trim();
		      if (cssText) {
		        cssText = '  ' + cssText + '\n';
		      }
		    }
		  }
		  // emit rule if there is cssText
		  if (cssText) {
		    if (node.selector) {
		      text += node.selector + ' ' + OPEN_BRACE + '\n';
		    }
		    text += cssText;
		    if (node.selector) {
		      text += CLOSE_BRACE + '\n\n';
		    }
		  }
		  return text;
		}
		
		function _hasMixinRules(rules) {
		  return rules[0].selector.indexOf(VAR_START) === 0;
		}
		
		function removeCustomProps(cssText) {
		  cssText = removeCustomPropAssignment(cssText);
		  return removeCustomPropApply(cssText);
		}
		
		function removeCustomPropAssignment(cssText) {
		  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
		}
		
		function removeCustomPropApply(cssText) {
		  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
		}
		
		var types = {
		  STYLE_RULE: 1,
		  KEYFRAMES_RULE: 7,
		  MEDIA_RULE: 4,
		  MIXIN_RULE: 1000
		};
		
		var OPEN_BRACE = '{';
		var CLOSE_BRACE = '}';
		
		// helper regexp's
		var RX = {
		  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
		  port: /@import[^;]*;/gim,
		  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
		  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
		  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
		  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
		  keyframesRule: /^@[^\s]*keyframes/,
		  multipleSpaces: /\s+/g
		};
		
		var VAR_START = '--';
		var MEDIA_START = '@media';
		var AT_START = '@';
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);
		// chrome 49 has semi-working css vars, check if box-shadow works
		// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
		var nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
		
		// experimental support for native @apply
		function detectNativeApply() {
		  var style = document.createElement('style');
		  style.textContent = '.foo { @apply --foo }';
		  document.head.appendChild(style);
		  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;
		  document.head.removeChild(style);
		  return nativeCssApply;
		}
		
		var nativeCssApply = false && detectNativeApply();
		
		function parseSettings(settings) {
		  if (settings) {
		    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;
		    nativeShadow = nativeShadow && !settings.shimshadow;
		  }
		}
		
		if (window.ShadyCSS) {
		  parseSettings(window.ShadyCSS);
		} else if (window.WebComponents) {
		  parseSettings(window.WebComponents.flags);
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		function toCssText(rules, callback) {
		  if (typeof rules === 'string') {
		    rules = parse(rules);
		  }
		  if (callback) {
		    forEachRule(rules, callback);
		  }
		  return stringify(rules, nativeCssVariables);
		}
		
		function rulesForStyle(style) {
		  if (!style.__cssRules && style.textContent) {
		    style.__cssRules = parse(style.textContent);
		  }
		  return style.__cssRules;
		}
		
		// Tests if a rule is a keyframes selector, which looks almost exactly
		// like a normal selector but is not (it has nothing to do with scoping
		// for example).
		function isKeyframesSelector(rule) {
		  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;
		}
		
		function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
		  if (!node) {
		    return;
		  }
		  var skipRules = false;
		  if (onlyActiveRules) {
		    if (node.type === types.MEDIA_RULE) {
		      var matchMedia = node.selector.match(rx.MEDIA_MATCH);
		      if (matchMedia) {
		        // if rule is a non matching @media rule, skip subrules
		        if (!window.matchMedia(matchMedia[1]).matches) {
		          skipRules = true;
		        }
		      }
		    }
		  }
		  if (node.type === types.STYLE_RULE) {
		    styleRuleCallback(node);
		  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {
		    keyframesRuleCallback(node);
		  } else if (node.type === types.MIXIN_RULE) {
		    skipRules = true;
		  }
		  var r$ = node.rules;
		  if (r$ && !skipRules) {
		    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
		      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
		    }
		  }
		}
		
		// add a string of cssText to the document.
		function applyCss(cssText, moniker, target, contextNode) {
		  var style = createScopeStyle(cssText, moniker);
		  return applyStyle$1(style, target, contextNode);
		}
		
		function applyStyle$1(style, target, contextNode) {
		  target = target || document.head;
		  var after = contextNode && contextNode.nextSibling || target.firstChild;
		  lastHeadApplyNode = style;
		  return target.insertBefore(style, after);
		}
		
		function createScopeStyle(cssText, moniker) {
		  var style = document.createElement('style');
		  if (moniker) {
		    style.setAttribute('scope', moniker);
		  }
		  style.textContent = cssText;
		  return style;
		}
		
		var lastHeadApplyNode = null;
		
		// insert a comment node as a styling position placeholder.
		function applyStylePlaceHolder(moniker) {
		  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
		  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;
		  var scope = document.head;
		  scope.insertBefore(placeHolder, after || scope.firstChild);
		  lastHeadApplyNode = placeHolder;
		  return placeHolder;
		}
		
		
		
		// cssBuildTypeForModule: function (module) {
		//   let dm = Polymer.DomModule.import(module);
		//   if (dm) {
		//     return getCssBuildType(dm);
		//   }
		// },
		//
		
		
		// Walk from text[start] matching parens
		// returns position of the outer end paren
		function findMatchingParen(text, start) {
		  var level = 0;
		  for (var i = start, l = text.length; i < l; i++) {
		    if (text[i] === '(') {
		      level++;
		    } else if (text[i] === ')') {
		      if (--level === 0) {
		        return i;
		      }
		    }
		  }
		  return -1;
		}
		
		function processVariableAndFallback(str, callback) {
		  // find 'var('
		  var start = str.indexOf('var(');
		  if (start === -1) {
		    // no var?, everything is prefix
		    return callback(str, '', '', '');
		  }
		  //${prefix}var(${inner})${suffix}
		  var end = findMatchingParen(str, start + 3);
		  var inner = str.substring(start + 4, end);
		  var prefix = str.substring(0, start);
		  // suffix may have other variables
		  var suffix = processVariableAndFallback(str.substring(end + 1), callback);
		  var comma = inner.indexOf(',');
		  // value and fallback args should be trimmed to match in property lookup
		  if (comma === -1) {
		    // variable, no fallback
		    return callback(prefix, inner.trim(), '', suffix);
		  }
		  // var(${value},${fallback})
		  var value = inner.substring(0, comma).trim();
		  var fallback = inner.substring(comma + 1).trim();
		  return callback(prefix, value, fallback, suffix);
		}
		
		var rx = {
		  VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
		  MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
		  VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
		  ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
		  MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
		  IS_VAR: /^--/,
		  BRACKETED: /\{[^}]*\}/g,
		  HOST_PREFIX: '(?:^|[^.#[:])',
		  HOST_SUFFIX: '($|[.:[\\s>+~])'
		};
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		/* Transforms ShadowDOM styling into ShadyDOM styling
		
		* scoping:
		
		  * elements in scope get scoping selector class="x-foo-scope"
		  * selectors re-written as follows:
		
		    div button -> div.x-foo-scope button.x-foo-scope
		
		* :host -> scopeName
		
		* :host(...) -> scopeName...
		
		* ::slotted(...) -> scopeName > ...
		
		* ...:dir(ltr|rtl) -> [dir="ltr|rtl"] ..., ...[dir="ltr|rtl"]
		
		* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir="rtl"] scopeName, scopeName[dir="rtl"]
		
		*/
		var SCOPE_NAME = 'style-scope';
		
		var StyleTransformer = {
		
		  // Given a node and scope name, add a scoping class to each node
		  // in the tree. This facilitates transforming css into scoped rules.
		  dom: function dom(node, scope, shouldRemoveScope) {
		    // one time optimization to skip scoping...
		    if (node.__styleScoped) {
		      node.__styleScoped = null;
		    } else {
		      this._transformDom(node, scope || '', shouldRemoveScope);
		    }
		  },
		
		  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {
		    if (node.classList) {
		      this.element(node, selector, shouldRemoveScope);
		    }
		    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;
		    if (c$) {
		      for (var i = 0; i < c$.length; i++) {
		        this._transformDom(c$[i], selector, shouldRemoveScope);
		      }
		    }
		  },
		
		  element: function element(_element, scope, shouldRemoveScope) {
		    // note: if using classes, we add both the general 'style-scope' class
		    // as well as the specific scope. This enables easy filtering of all
		    // `style-scope` elements
		    if (scope) {
		      // note: svg on IE does not have classList so fallback to class
		      if (_element.classList) {
		        if (shouldRemoveScope) {
		          _element.classList.remove(SCOPE_NAME);
		          _element.classList.remove(scope);
		        } else {
		          _element.classList.add(SCOPE_NAME);
		          _element.classList.add(scope);
		        }
		      } else if (_element.getAttribute) {
		        var c = _element.getAttribute(CLASS);
		        if (shouldRemoveScope) {
		          if (c) {
		            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
		          }
		        } else {
		          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
		        }
		      }
		    }
		  },
		
		  elementStyles: function elementStyles(element, styleRules, callback) {
		    var cssBuildType = element.__cssBuild;
		    // no need to shim selectors if settings.useNativeShadow, also
		    // a shady css build will already have transformed selectors
		    // NOTE: This method may be called as part of static or property shimming.
		    // When there is a targeted build it will not be called for static shimming,
		    // but when the property shim is used it is called and should opt out of
		    // static shimming work when a proper build exists.
		    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\n\n';
		    return cssText.trim();
		  },
		
		  // Given a string of cssText and a scoping string (scope), returns
		  // a string of scoped css where each selector is transformed to include
		  // a class created from the scope. ShadowDOM selectors are also transformed
		  // (e.g. :host) to use the scoping selector.
		  css: function css(rules, scope, ext, callback) {
		    var hostScope = this._calcHostScope(scope, ext);
		    scope = this._calcElementScope(scope);
		    var self = this;
		    return toCssText(rules, function (rule) {
		      if (!rule.isScoped) {
		        self.rule(rule, scope, hostScope);
		        rule.isScoped = true;
		      }
		      if (callback) {
		        callback(rule, scope, hostScope);
		      }
		    });
		  },
		
		  _calcElementScope: function _calcElementScope(scope) {
		    if (scope) {
		      return CSS_CLASS_PREFIX + scope;
		    } else {
		      return '';
		    }
		  },
		
		  _calcHostScope: function _calcHostScope(scope, ext) {
		    return ext ? '[is=' + scope + ']' : scope;
		  },
		
		  rule: function rule(_rule, scope, hostScope) {
		    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);
		  },
		
		  // transforms a css rule to a scoped rule.
		  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {
		    // NOTE: save transformedSelector for subsequent matching of elements
		    // against selectors (e.g. when calculating style properties)
		    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
		  },
		
		  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {
		    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
		    // we want to skip transformation of rules that appear in keyframes,
		    // because they are keyframe selectors, not element selectors.
		    if (!isKeyframesSelector(rule)) {
		      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
		        p$[i] = transformer.call(this, p, scope, hostScope);
		      }
		    }
		    return p$.join(COMPLEX_SELECTOR_SEP);
		  },
		
		  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {
		    var _this = this;
		
		    var stop = false;
		    selector = selector.trim();
		    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP
		    selector = selector.replace(NTH, function (m, type, inner) {
		      return ':' + type + '(' + inner.replace(/\s/g, '') + ')';
		    });
		    selector = selector.replace(SLOTTED_START, HOST + ' $1');
		    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
		      if (!stop) {
		        var info = _this._transformCompoundSelector(s, c, scope, hostScope);
		        stop = stop || info.stop;
		        c = info.combinator;
		        s = info.value;
		      }
		      return c + s;
		    });
		    return selector;
		  },
		
		  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {
		    // replace :host with host scoping class
		    var slottedIndex = selector.indexOf(SLOTTED);
		    if (selector.indexOf(HOST) >= 0) {
		      selector = this._transformHostSelector(selector, hostScope);
		      // replace other selectors with scoping class
		    } else if (slottedIndex !== 0) {
		      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
		    }
		    // mark ::slotted() scope jump to replace with descendant selector + arg
		    // also ignore left-side combinator
		    var slotted = false;
		    if (slottedIndex >= 0) {
		      combinator = '';
		      slotted = true;
		    }
		    // process scope jumping selectors up to the scope jump and then stop
		    var stop = void 0;
		    if (slotted) {
		      stop = true;
		      if (slotted) {
		        // .zonk ::slotted(.foo) -> .zonk.scope > .foo
		        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {
		          return ' > ' + paren;
		        });
		      }
		    }
		    selector = selector.replace(DIR_PAREN, function (m, before, dir) {
		      return '[dir="' + dir + '"] ' + before + ', ' + before + '[dir="' + dir + '"]';
		    });
		    return { value: selector, combinator: combinator, stop: stop };
		  },
		
		  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {
		    var p$ = selector.split(PSEUDO_PREFIX);
		    p$[0] += scope;
		    return p$.join(PSEUDO_PREFIX);
		  },
		
		  // :host(...) -> scopeName...
		  _transformHostSelector: function _transformHostSelector(selector, hostScope) {
		    var m = selector.match(HOST_PAREN);
		    var paren = m && m[2].trim() || '';
		    if (paren) {
		      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
		        // paren starts with a type selector
		        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
		        // if the type selector is our hostScope then avoid pre-pending it
		        if (typeSelector === hostScope) {
		          return paren;
		          // otherwise, this selector should not match in this scope so
		          // output a bogus selector.
		        } else {
		          return SELECTOR_NO_MATCH;
		        }
		      } else {
		        // make sure to do a replace here to catch selectors like:
		        // `:host(.foo)::before`
		        return selector.replace(HOST_PAREN, function (m, host, paren) {
		          return hostScope + paren;
		        });
		      }
		      // if no paren, do a straight :host replacement.
		      // TODO(sorvell): this should not strictly be necessary but
		      // it's needed to maintain support for `:host[foo]` type selectors
		      // which have been improperly used under Shady DOM. This should be
		      // deprecated.
		    } else {
		      return selector.replace(HOST, hostScope);
		    }
		  },
		
		  documentRule: function documentRule(rule) {
		    // reset selector in case this is redone.
		    rule.selector = rule.parsedSelector;
		    this.normalizeRootSelector(rule);
		    this._transformRule(rule, this._transformDocumentSelector);
		  },
		
		  normalizeRootSelector: function normalizeRootSelector(rule) {
		    if (rule.selector === ROOT) {
		      rule.selector = 'html';
		    }
		  },
		
		  _transformDocumentSelector: function _transformDocumentSelector(selector) {
		    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
		  },
		  SCOPE_NAME: SCOPE_NAME
		};
		
		var NTH = /:(nth[-\w]+)\(([^)]+)\)/;
		var SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';
		var COMPLEX_SELECTOR_SEP = ',';
		var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
		var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
		var HOST = ':host';
		var ROOT = ':root';
		var SLOTTED = '::slotted';
		var SLOTTED_START = new RegExp('^(' + SLOTTED + ')');
		// NOTE: this supports 1 nested () pair for things like
		// :host(:not([selected]), more general support requires
		// parsing which seems like overkill
		var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
		// similar to HOST_PAREN
		var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
		var DIR_PAREN = /(.*):dir\((?:(ltr|rtl))\)/;
		var CSS_CLASS_PREFIX = '.';
		var PSEUDO_PREFIX = ':';
		var CLASS = 'class';
		var SELECTOR_NO_MATCH = 'should_not_match';
		
		var classCallCheck = function (instance, Constructor) {
		  if (!(instance instanceof Constructor)) {
		    throw new TypeError("Cannot call a class as a function");
		  }
		};
		
		var createClass = function () {
		  function defineProperties(target, props) {
		    for (var i = 0; i < props.length; i++) {
		      var descriptor = props[i];
		      descriptor.enumerable = descriptor.enumerable || false;
		      descriptor.configurable = true;
		      if ("value" in descriptor) descriptor.writable = true;
		      Object.defineProperty(target, descriptor.key, descriptor);
		    }
		  }
		
		  return function (Constructor, protoProps, staticProps) {
		    if (protoProps) defineProperties(Constructor.prototype, protoProps);
		    if (staticProps) defineProperties(Constructor, staticProps);
		    return Constructor;
		  };
		}();
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		var set$1 = function set$1(object, property, value, receiver) {
		  var desc = Object.getOwnPropertyDescriptor(object, property);
		
		  if (desc === undefined) {
		    var parent = Object.getPrototypeOf(object);
		
		    if (parent !== null) {
		      set$1(parent, property, value, receiver);
		    }
		  } else if ("value" in desc && desc.writable) {
		    desc.value = value;
		  } else {
		    var setter = desc.set;
		
		    if (setter !== undefined) {
		      setter.call(receiver, value);
		    }
		  }
		
		  return value;
		};
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		var toConsumableArray = function (arr) {
		  if (Array.isArray(arr)) {
		    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
		
		    return arr2;
		  } else {
		    return Array.from(arr);
		  }
		};
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var StyleInfo = function () {
		  createClass(StyleInfo, null, [{
		    key: 'get',
		    value: function get(node) {
		      return node.__styleInfo;
		    }
		  }, {
		    key: 'set',
		    value: function set(node, styleInfo) {
		      node.__styleInfo = styleInfo;
		      return styleInfo;
		    }
		  }]);
		
		  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {
		    classCallCheck(this, StyleInfo);
		
		    this.styleRules = ast || null;
		    this.placeholder = placeholder || null;
		    this.ownStylePropertyNames = ownStylePropertyNames || [];
		    this.overrideStyleProperties = {};
		    this.elementName = elementName || '';
		    this.cssBuild = cssBuild || '';
		    this.typeExtension = typeExtension || '';
		    this.styleProperties = null;
		    this.scopeSelector = null;
		    this.customStyle = null;
		  }
		
		  return StyleInfo;
		}();
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		// TODO: dedupe with shady
		var p = window.Element.prototype;
		var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
		
		var IS_IE = navigator.userAgent.match('Trident');
		
		var StyleProperties = {
		
		  // decorates styles with rule info and returns an array of used style
		  // property names
		  decorateStyles: function decorateStyles(rules) {
		    var self = this,
		        props = {},
		        keyframes = [],
		        ruleIndex = 0;
		    forEachRule(rules, function (rule) {
		      self.decorateRule(rule);
		      // mark in-order position of ast rule in styles block, used for cache key
		      rule.index = ruleIndex++;
		      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
		    }, function onKeyframesRule(rule) {
		      keyframes.push(rule);
		    });
		    // Cache all found keyframes rules for later reference:
		    rules._keyframes = keyframes;
		    // return this list of property names *consumes* in these styles.
		    var names = [];
		    for (var i in props) {
		      names.push(i);
		    }
		    return names;
		  },
		
		  // decorate a single rule with property info
		  decorateRule: function decorateRule(rule) {
		    if (rule.propertyInfo) {
		      return rule.propertyInfo;
		    }
		    var info = {},
		        properties = {};
		    var hasProperties = this.collectProperties(rule, properties);
		    if (hasProperties) {
		      info.properties = properties;
		      // TODO(sorvell): workaround parser seeing mixins as additional rules
		      rule.rules = null;
		    }
		    info.cssText = this.collectCssText(rule);
		    rule.propertyInfo = info;
		    return info;
		  },
		
		  // collects the custom properties from a rule's cssText
		  collectProperties: function collectProperties(rule, properties) {
		    var info = rule.propertyInfo;
		    if (info) {
		      if (info.properties) {
		        Object.assign(properties, info.properties);
		        return true;
		      }
		    } else {
		      var m = void 0,
		          rx$$1 = this.rx.VAR_ASSIGN;
		      var cssText = rule.parsedCssText;
		      var value = void 0;
		      var any = void 0;
		      while (m = rx$$1.exec(cssText)) {
		        // note: group 2 is var, 3 is mixin
		        value = (m[2] || m[3]).trim();
		        // value of 'inherit' or 'unset' is equivalent to not setting the property here
		        if (value !== 'inherit' || value !== 'unset') {
		          properties[m[1].trim()] = value;
		        }
		        any = true;
		      }
		      return any;
		    }
		  },
		
		  // returns cssText of properties that consume variables/mixins
		  collectCssText: function collectCssText(rule) {
		    return this.collectConsumingCssText(rule.parsedCssText);
		  },
		
		  // NOTE: we support consumption inside mixin assignment
		  // but not production, so strip out {...}
		  collectConsumingCssText: function collectConsumingCssText(cssText) {
		    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
		  },
		
		  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {
		    var m = void 0;
		    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
		      var name = m[1];
		      // This regex catches all variable names, and following non-whitespace char
		      // If next char is not ':', then variable is a consumer
		      if (m[2] !== ':') {
		        props[name] = true;
		      }
		    }
		  },
		
		  // turns custom properties into realized values.
		  reify: function reify(props) {
		    // big perf optimization here: reify only *own* properties
		    // since this object has __proto__ of the element's scope properties
		    var names = Object.getOwnPropertyNames(props);
		    for (var i = 0, n; i < names.length; i++) {
		      n = names[i];
		      props[n] = this.valueForProperty(props[n], props);
		    }
		  },
		
		  // given a property value, returns the reified value
		  // a property value may be:
		  // (1) a literal value like: red or 5px;
		  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or
		  // var(--a, var(--b));
		  // (3) a literal mixin value like { properties }. Each of these properties
		  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.
		  valueForProperty: function valueForProperty(property, props) {
		    var _this = this;
		
		    // case (1) default
		    // case (3) defines a mixin and we have to reify the internals
		    if (property) {
		      if (property.indexOf(';') >= 0) {
		        property = this.valueForProperties(property, props);
		      } else {
		        (function () {
		          // case (2) variable
		          var self = _this;
		          var fn = function fn(prefix, value, fallback, suffix) {
		            if (!value) {
		              return prefix + suffix;
		            }
		            var propertyValue = self.valueForProperty(props[value], props);
		            // if value is "initial", then the variable should be treated as unset
		            if (!propertyValue || propertyValue === 'initial') {
		              // fallback may be --a or var(--a) or literal
		              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
		            } else if (propertyValue === 'apply-shim-inherit') {
		              // CSS build will replace `inherit` with `apply-shim-inherit`
		              // for use with native css variables.
		              // Since we have full control, we can use `inherit` directly.
		              propertyValue = 'inherit';
		            }
		            return prefix + (propertyValue || '') + suffix;
		          };
		          property = processVariableAndFallback(property, fn);
		        })();
		      }
		    }
		    return property && property.trim() || '';
		  },
		
		  // note: we do not yet support mixin within mixin
		  valueForProperties: function valueForProperties(property, props) {
		    var parts = property.split(';');
		    for (var i = 0, _p, m; i < parts.length; i++) {
		      if (_p = parts[i]) {
		        this.rx.MIXIN_MATCH.lastIndex = 0;
		        m = this.rx.MIXIN_MATCH.exec(_p);
		        if (m) {
		          _p = this.valueForProperty(props[m[1]], props);
		        } else {
		          var colon = _p.indexOf(':');
		          if (colon !== -1) {
		            var pp = _p.substring(colon);
		            pp = pp.trim();
		            pp = this.valueForProperty(pp, props) || pp;
		            _p = _p.substring(0, colon) + pp;
		          }
		        }
		        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?
		        // strip trailing ;
		        _p.slice(0, -1) : _p || '';
		      }
		    }
		    return parts.join(';');
		  },
		
		  applyProperties: function applyProperties(rule, props) {
		    var output = '';
		    // dynamically added sheets may not be decorated so ensure they are.
		    if (!rule.propertyInfo) {
		      this.decorateRule(rule);
		    }
		    if (rule.propertyInfo.cssText) {
		      output = this.valueForProperties(rule.propertyInfo.cssText, props);
		    }
		    rule.cssText = output;
		  },
		
		  // Apply keyframe transformations to the cssText of a given rule. The
		  // keyframeTransforms object is a map of keyframe names to transformer
		  // functions which take in cssText and spit out transformed cssText.
		  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {
		    var input = rule.cssText;
		    var output = rule.cssText;
		    if (rule.hasAnimations == null) {
		      // Cache whether or not the rule has any animations to begin with:
		      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
		    }
		    // If there are no animations referenced, we can skip transforms:
		    if (rule.hasAnimations) {
		      var transform = void 0;
		      // If we haven't transformed this rule before, we iterate over all
		      // transforms:
		      if (rule.keyframeNamesToTransform == null) {
		        rule.keyframeNamesToTransform = [];
		        for (var keyframe in keyframeTransforms) {
		          transform = keyframeTransforms[keyframe];
		          output = transform(input);
		          // If the transform actually changed the CSS text, we cache the
		          // transform name for future use:
		          if (input !== output) {
		            input = output;
		            rule.keyframeNamesToTransform.push(keyframe);
		          }
		        }
		      } else {
		        // If we already have a list of keyframe names that apply to this
		        // rule, we apply only those keyframe name transforms:
		        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
		          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
		          input = transform(input);
		        }
		        output = input;
		      }
		    }
		    rule.cssText = output;
		  },
		
		  // Test if the rules in these styles matches the given `element` and if so,
		  // collect any custom properties into `props`.
		  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {
		    var props = {},
		        self = this;
		    // generates a unique key for these matches
		    var o = [];
		    // note: active rules excludes non-matching @media rules
		    forEachRule(rules, function (rule) {
		      // TODO(sorvell): we could trim the set of rules at declaration
		      // time to only include ones that have properties
		      if (!rule.propertyInfo) {
		        self.decorateRule(rule);
		      }
		      // match element against transformedSelector: selector may contain
		      // unwanted uniquification and parsedSelector does not directly match
		      // for :host selectors.
		      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
		      if (element && rule.propertyInfo.properties && selectorToMatch) {
		        if (matchesSelector.call(element, selectorToMatch)) {
		          self.collectProperties(rule, props);
		          // produce numeric key for these matches for lookup
		          addToBitMask(rule.index, o);
		        }
		      }
		    }, null, true);
		    return { properties: props, key: o };
		  },
		
		  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {
		    if (!rule.propertyInfo) {
		      this.decorateRule(rule);
		    }
		    if (!rule.propertyInfo.properties) {
		      return;
		    }
		    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
		    var parsedSelector = rule.parsedSelector;
		    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
		    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;
		    // build info is either in scope (when scope is an element) or in the style
		    // when scope is the default scope; note: this allows default scope to have
		    // mixed mode built and unbuilt styles.
		    if (cssBuild === 'shady') {
		      // :root -> x-foo > *.x-foo for elements and html for custom-style
		      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;
		      // :host -> x-foo for elements, but sub-rules have .x-foo in them
		      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
		    }
		    if (cssBuild === 'shadow') {
		      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
		      isHost = isHost && !isRoot;
		    }
		    if (!isRoot && !isHost) {
		      return;
		    }
		    var selectorToMatch = hostScope;
		    if (isHost) {
		      // need to transform :host under ShadowDOM because `:host` does not work with `matches`
		      if (nativeShadow && !rule.transformedSelector) {
		        // transform :host into a matchable selector
		        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);
		      }
		      selectorToMatch = rule.transformedSelector || hostScope;
		    }
		    callback({
		      selector: selectorToMatch,
		      isHost: isHost,
		      isRoot: isRoot
		    });
		  },
		
		  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {
		    var hostProps = {},
		        rootProps = {},
		        self = this;
		    // note: active rules excludes non-matching @media rules
		    var cssBuild = rules && rules.__cssBuild;
		    forEachRule(rules, function (rule) {
		      // if scope is StyleDefaults, use _element for matchesSelector
		      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {
		        var element = scope._element || scope;
		        if (matchesSelector.call(element, info.selector)) {
		          if (info.isHost) {
		            self.collectProperties(rule, hostProps);
		          } else {
		            self.collectProperties(rule, rootProps);
		          }
		        }
		      });
		    }, null, true);
		    return { rootProps: rootProps, hostProps: hostProps };
		  },
		
		  transformStyles: function transformStyles(element, properties, scopeSelector) {
		    var self = this;
		    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);
		    var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
		    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
		    var rules = StyleInfo.get(element).styleRules;
		    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);
		    return StyleTransformer.elementStyles(element, rules, function (rule) {
		      self.applyProperties(rule, properties);
		      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {
		        // NOTE: keyframe transforms only scope munge animation names, so it
		        // is not necessary to apply them in ShadowDOM.
		        self.applyKeyframeTransforms(rule, keyframeTransforms);
		        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);
		      }
		    });
		  },
		
		  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {
		    var keyframesRules = rules._keyframes;
		    var keyframeTransforms = {};
		    if (!nativeShadow && keyframesRules) {
		      // For non-ShadowDOM, we transform all known keyframes rules in
		      // advance for the current scope. This allows us to catch keyframes
		      // rules that appear anywhere in the stylesheet:
		      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
		        this._scopeKeyframes(keyframesRule, scopeSelector);
		        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
		      }
		    }
		    return keyframeTransforms;
		  },
		
		  // Generate a factory for transforming a chunk of CSS text to handle a
		  // particular scoped keyframes rule.
		  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {
		    return function (cssText) {
		      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
		    };
		  },
		
		  // Transforms `@keyframes` names to be unique for the current host.
		  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0
		  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {
		    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
		    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
		    rule.transformedSelector = rule.transformedSelector || rule.selector;
		    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
		  },
		
		  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):
		  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo
		  // host selector: x-foo.wide -> .x-foo-42.wide
		  // note: we use only the scope class (.x-foo-42) and not the hostSelector
		  // (x-foo) to scope :host rules; this helps make property host rules
		  // have low specificity. They are overrideable by class selectors but,
		  // unfortunately, not by type selectors (e.g. overriding via
		  // `.special` is ok, but not by `x-foo`).
		  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {
		    rule.transformedSelector = rule.transformedSelector || rule.selector;
		    var selector = rule.transformedSelector;
		    var scope = '.' + scopeId;
		    var parts = selector.split(',');
		    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {
		      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;
		    }
		    rule.selector = parts.join(',');
		  },
		
		  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {
		    var c = element.getAttribute('class') || '';
		    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
		    if (c !== v) {
		      element.setAttribute('class', v);
		    }
		  },
		
		  applyElementStyle: function applyElementStyle(element, properties, selector, style) {
		    // calculate cssText to apply
		    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
		    // if shady and we have a cached style that is not style, decrement
		    var styleInfo = StyleInfo.get(element);
		    var s = styleInfo.customStyle;
		    if (s && !nativeShadow && s !== style) {
		      s._useCount--;
		      if (s._useCount <= 0 && s.parentNode) {
		        s.parentNode.removeChild(s);
		      }
		    }
		    // apply styling always under native or if we generated style
		    // or the cached style is not in document(!)
		    if (nativeShadow) {
		      // update existing style only under native
		      if (styleInfo.customStyle) {
		        styleInfo.customStyle.textContent = cssText;
		        style = styleInfo.customStyle;
		        // otherwise, if we have css to apply, do so
		      } else if (cssText) {
		        // apply css after the scope style of the element to help with
		        // style precedence rules.
		        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);
		      }
		    } else {
		      // shady and no cache hit
		      if (!style) {
		        // apply css after the scope style of the element to help with
		        // style precedence rules.
		        if (cssText) {
		          style = applyCss(cssText, selector, null, styleInfo.placeholder);
		        }
		        // shady and cache hit but not in document
		      } else if (!style.parentNode) {
		        applyStyle$1(style, null, styleInfo.placeholder);
		      }
		    }
		    // ensure this style is our custom style and increment its use count.
		    if (style) {
		      style._useCount = style._useCount || 0;
		      // increment use count if we changed styles
		      if (styleInfo.customStyle != style) {
		        style._useCount++;
		      }
		      styleInfo.customStyle = style;
		    }
		    // @media rules may be stale in IE 10 and 11
		    if (IS_IE) {
		      style.textContent = style.textContent;
		    }
		    return style;
		  },
		
		  applyCustomStyle: function applyCustomStyle(style, properties) {
		    var rules = rulesForStyle(style);
		    var self = this;
		    style.textContent = toCssText(rules, function (rule) {
		      var css = rule.cssText = rule.parsedCssText;
		      if (rule.propertyInfo && rule.propertyInfo.cssText) {
		        // remove property assignments
		        // so next function isn't confused
		        // NOTE: we have 3 categories of css:
		        // (1) normal properties,
		        // (2) custom property assignments (--foo: red;),
		        // (3) custom property usage: border: var(--foo); @apply(--foo);
		        // In elements, 1 and 3 are separated for efficiency; here they
		        // are not and this makes this case unique.
		        css = removeCustomPropAssignment(css);
		        // replace with reified properties, scenario is same as mixin
		        rule.cssText = self.valueForProperties(css, properties);
		      }
		    });
		  },
		
		  rx: rx,
		  XSCOPE_NAME: 'x-scope'
		};
		
		function addToBitMask(n, bits) {
		  var o = parseInt(n / 32);
		  var v = 1 << n % 32;
		  bits[o] = (bits[o] || 0) | v;
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var templateMap = {};
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var placeholderMap = {};
		
		var ce = window.customElements;
		if (ce && !nativeShadow) {
		  (function () {
		    var origDefine = ce.define;
		    ce.define = function (name, clazz, options) {
		      placeholderMap[name] = applyStylePlaceHolder(name);
		      return origDefine.call(ce, name, clazz, options);
		    };
		  })();
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		var StyleCache = function () {
		  function StyleCache() {
		    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
		    classCallCheck(this, StyleCache);
		
		    // map element name -> [{properties, styleElement, scopeSelector}]
		    this.cache = {};
		    this.typeMax = typeMax;
		  }
		
		  createClass(StyleCache, [{
		    key: '_validate',
		    value: function _validate(cacheEntry, properties, ownPropertyNames) {
		      for (var idx = 0; idx < ownPropertyNames.length; idx++) {
		        var pn = ownPropertyNames[idx];
		        if (cacheEntry.properties[pn] !== properties[pn]) {
		          return false;
		        }
		      }
		      return true;
		    }
		  }, {
		    key: 'store',
		    value: function store(tagname, properties, styleElement, scopeSelector) {
		      var list = this.cache[tagname] || [];
		      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });
		      if (list.length > this.typeMax) {
		        list.shift();
		      }
		      this.cache[tagname] = list;
		    }
		  }, {
		    key: 'fetch',
		    value: function fetch(tagname, properties, ownPropertyNames) {
		      var list = this.cache[tagname];
		      if (!list) {
		        return;
		      }
		      // reverse list for most-recent lookups
		      for (var idx = list.length - 1; idx >= 0; idx--) {
		        var entry = list[idx];
		        if (this._validate(entry, properties, ownPropertyNames)) {
		          return entry;
		        }
		      }
		    }
		  }]);
		  return StyleCache;
		}();
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		/**
		 * The apply shim simulates the behavior of `@apply` proposed at
		 * https://tabatkins.github.io/specs/css-apply-rule/.
		 * The approach is to convert a property like this:
		 *
		 *    --foo: {color: red; background: blue;}
		 *
		 * to this:
		 *
		 *    --foo_-_color: red;
		 *    --foo_-_background: blue;
		 *
		 * Then where `@apply --foo` is used, that is converted to:
		 *
		 *    color: var(--foo_-_color);
		 *    background: var(--foo_-_background);
		 *
		 * This approach generally works but there are some issues and limitations.
		 * Consider, for example, that somewhere *between* where `--foo` is set and used,
		 * another element sets it to:
		 *
		 *    --foo: { border: 2px solid red; }
		 *
		 * We must now ensure that the color and background from the previous setting
		 * do not apply. This is accomplished by changing the property set to this:
		 *
		 *    --foo_-_border: 2px solid red;
		 *    --foo_-_color: initial;
		 *    --foo_-_background: initial;
		 *
		 * This works but introduces one new issue.
		 * Consider this setup at the point where the `@apply` is used:
		 *
		 *    background: orange;
		 *    @apply --foo;
		 *
		 * In this case the background will be unset (initial) rather than the desired
		 * `orange`. We address this by altering the property set to use a fallback
		 * value like this:
		 *
		 *    color: var(--foo_-_color);
		 *    background: var(--foo_-_background, orange);
		 *    border: var(--foo_-_border);
		 *
		 * Note that the default is retained in the property set and the `background` is
		 * the desired `orange`. This leads us to a limitation.
		 *
		 * Limitation 1:
		
		 * Only properties in the rule where the `@apply`
		 * is used are considered as default values.
		 * If another rule matches the element and sets `background` with
		 * less specificity than the rule in which `@apply` appears,
		 * the `background` will not be set.
		 *
		 * Limitation 2:
		 *
		 * When using Polymer's `updateStyles` api, new properties may not be set for
		 * `@apply` properties.
		
		*/
		
		var MIXIN_MATCH = rx.MIXIN_MATCH;
		var VAR_ASSIGN = rx.VAR_ASSIGN;
		
		var APPLY_NAME_CLEAN = /;\s*/m;
		var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
		
		// separator used between mixin-name and mixin-property-name when producing properties
		// NOTE: plain '-' may cause collisions in user styles
		var MIXIN_VAR_SEP = '_-_';
		
		// map of mixin to property names
		// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}
		
		var MixinMap = function () {
		  function MixinMap() {
		    classCallCheck(this, MixinMap);
		
		    this._map = {};
		  }
		
		  createClass(MixinMap, [{
		    key: 'set',
		    value: function set(name, props) {
		      name = name.trim();
		      this._map[name] = {
		        properties: props,
		        dependants: {}
		      };
		    }
		  }, {
		    key: 'get',
		    value: function get(name) {
		      name = name.trim();
		      return this._map[name];
		    }
		  }]);
		  return MixinMap;
		}();
		
		var ApplyShim = function () {
		  function ApplyShim() {
		    var _this = this;
		
		    classCallCheck(this, ApplyShim);
		
		    this._currentTemplate = null;
		    this._measureElement = null;
		    this._map = new MixinMap();
		    this._separator = MIXIN_VAR_SEP;
		    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {
		      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);
		    };
		  }
		
		  createClass(ApplyShim, [{
		    key: 'transformStyle',
		    value: function transformStyle(style, elementName) {
		      var ast = rulesForStyle(style);
		      this.transformRules(ast, elementName);
		      return ast;
		    }
		  }, {
		    key: 'transformRules',
		    value: function transformRules(rules, elementName) {
		      var _this2 = this;
		
		      this._currentTemplate = templateMap[elementName];
		      forEachRule(rules, function (r) {
		        _this2.transformRule(r);
		      });
		      if (this._currentTemplate) {
		        this._currentTemplate.__applyShimInvalid = false;
		      }
		      this._currentTemplate = null;
		    }
		  }, {
		    key: 'transformRule',
		    value: function transformRule(rule) {
		      rule.cssText = this.transformCssText(rule.parsedCssText);
		      // :root was only used for variable assignment in property shim,
		      // but generates invalid selectors with real properties.
		      // replace with `:host > *`, which serves the same effect
		      if (rule.selector === ':root') {
		        rule.selector = ':host > *';
		      }
		    }
		  }, {
		    key: 'transformCssText',
		    value: function transformCssText(cssText) {
		      // produce variables
		      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);
		      // consume mixins
		      return this._consumeCssProperties(cssText);
		    }
		  }, {
		    key: '_getInitialValueForProperty',
		    value: function _getInitialValueForProperty(property) {
		      if (!this._measureElement) {
		        this._measureElement = document.createElement('meta');
		        this._measureElement.style.all = 'initial';
		        document.head.appendChild(this._measureElement);
		      }
		      return window.getComputedStyle(this._measureElement).getPropertyValue(property);
		    }
		    // replace mixin consumption with variable consumption
		
		  }, {
		    key: '_consumeCssProperties',
		    value: function _consumeCssProperties(text) {
		      var m = void 0;
		      // loop over text until all mixins with defintions have been applied
		      while (m = MIXIN_MATCH.exec(text)) {
		        var matchText = m[0];
		        var mixinName = m[1];
		        var idx = m.index;
		        // collect properties before apply to be "defaults" if mixin might override them
		        // match includes a "prefix", so find the start and end positions of @apply
		        var applyPos = idx + matchText.indexOf('@apply');
		        var afterApplyPos = idx + matchText.length;
		        // find props defined before this @apply
		        var textBeforeApply = text.slice(0, applyPos);
		        var textAfterApply = text.slice(afterApplyPos);
		        var defaults$$1 = this._cssTextToMap(textBeforeApply);
		        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);
		        // use regex match position to replace mixin, keep linear processing time
		        text = [textBeforeApply, replacement, textAfterApply].join('');
		        // move regex search to _after_ replacement
		        MIXIN_MATCH.lastIndex = idx + replacement.length;
		      }
		      return text;
		    }
		    // produce variable consumption at the site of mixin consumption
		    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
		    // Example:
		    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
		
		  }, {
		    key: '_atApplyToCssProperties',
		    value: function _atApplyToCssProperties(mixinName, fallbacks) {
		      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
		      var vars = [];
		      var mixinEntry = this._map.get(mixinName);
		      // if we depend on a mixin before it is created
		      // make a sentinel entry in the map to add this element as a dependency for when it is defined.
		      if (!mixinEntry) {
		        this._map.set(mixinName, {});
		        mixinEntry = this._map.get(mixinName);
		      }
		      if (mixinEntry) {
		        if (this._currentTemplate) {
		          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;
		        }
		        var p = void 0,
		            parts = void 0,
		            f = void 0;
		        for (p in mixinEntry.properties) {
		          f = fallbacks && fallbacks[p];
		          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
		          if (f) {
		            parts.push(',', f);
		          }
		          parts.push(')');
		          vars.push(parts.join(''));
		        }
		      }
		      return vars.join('; ');
		    }
		  }, {
		    key: '_replaceInitialOrInherit',
		    value: function _replaceInitialOrInherit(property, value) {
		      var match = INITIAL_INHERIT.exec(value);
		      if (match) {
		        if (match[1]) {
		          // initial
		          // replace `initial` with the concrete initial value for this property
		          value = ApplyShim._getInitialValueForProperty(property);
		        } else {
		          // inherit
		          // with this purposfully illegal value, the variable will be invalid at
		          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
		          // and for inheriting values, will behave similarly
		          // we cannot support the same behavior for non inheriting values like 'border'
		          value = 'apply-shim-inherit';
		        }
		      }
		      return value;
		    }
		
		    // "parse" a mixin definition into a map of properties and values
		    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
		
		  }, {
		    key: '_cssTextToMap',
		    value: function _cssTextToMap(text) {
		      var props = text.split(';');
		      var property = void 0,
		          value = void 0;
		      var out = {};
		      for (var i = 0, p, sp; i < props.length; i++) {
		        p = props[i];
		        if (p) {
		          sp = p.split(':');
		          // ignore lines that aren't definitions like @media
		          if (sp.length > 1) {
		            property = sp[0].trim();
		            // some properties may have ':' in the value, like data urls
		            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
		            out[property] = value;
		          }
		        }
		      }
		      return out;
		    }
		  }, {
		    key: '_invalidateMixinEntry',
		    value: function _invalidateMixinEntry(mixinEntry) {
		      for (var elementName in mixinEntry.dependants) {
		        if (elementName !== this._currentTemplate) {
		          mixinEntry.dependants[elementName].__applyShimInvalid = true;
		        }
		      }
		    }
		  }, {
		    key: '_produceCssProperties',
		    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
		      var _this3 = this;
		
		      // handle case where property value is a mixin
		      if (valueProperty) {
		        // form: --mixin2: var(--mixin1), where --mixin1 is in the map
		        processVariableAndFallback(valueProperty, function (prefix, value) {
		          if (value && _this3._map.get(value)) {
		            valueMixin = '@apply ' + value + ';';
		          }
		        });
		      }
		      if (!valueMixin) {
		        return matchText;
		      }
		      var mixinAsProperties = this._consumeCssProperties(valueMixin);
		      var prefix = matchText.slice(0, matchText.indexOf('--'));
		      var mixinValues = this._cssTextToMap(mixinAsProperties);
		      var combinedProps = mixinValues;
		      var mixinEntry = this._map.get(propertyName);
		      var oldProps = mixinEntry && mixinEntry.properties;
		      if (oldProps) {
		        // NOTE: since we use mixin, the map of properties is updated here
		        // and this is what we want.
		        combinedProps = Object.assign(Object.create(oldProps), mixinValues);
		      } else {
		        this._map.set(propertyName, combinedProps);
		      }
		      var out = [];
		      var p = void 0,
		          v = void 0;
		      // set variables defined by current mixin
		      var needToInvalidate = false;
		      for (p in combinedProps) {
		        v = mixinValues[p];
		        // if property not defined by current mixin, set initial
		        if (v === undefined) {
		          v = 'initial';
		        }
		        if (oldProps && !(p in oldProps)) {
		          needToInvalidate = true;
		        }
		        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
		      }
		      if (needToInvalidate) {
		        this._invalidateMixinEntry(mixinEntry);
		      }
		      if (mixinEntry) {
		        mixinEntry.properties = combinedProps;
		      }
		      // because the mixinMap is global, the mixin might conflict with
		      // a different scope's simple variable definition:
		      // Example:
		      // some style somewhere:
		      // --mixin1:{ ... }
		      // --mixin2: var(--mixin1);
		      // some other element:
		      // --mixin1: 10px solid red;
		      // --foo: var(--mixin1);
		      // In this case, we leave the original variable definition in place.
		      if (valueProperty) {
		        prefix = matchText + ';' + prefix;
		      }
		      return prefix + out.join('; ') + ';';
		    }
		  }]);
		  return ApplyShim;
		}();
		
		var applyShim = new ApplyShim();
		window['ApplyShim'] = applyShim;
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		var flush = function flush() {};
		
		if (!nativeShadow) {
		  (function () {
		    var handler = function handler(mxns) {
		      for (var x = 0; x < mxns.length; x++) {
		        var mxn = mxns[x];
		        for (var i = 0; i < mxn.addedNodes.length; i++) {
		          var n = mxn.addedNodes[i];
		          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {
		            var root = n.getRootNode();
		            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		              // may no longer be in a shadowroot
		              var host = root.host;
		              if (host) {
		                var scope = host.is || host.localName;
		                StyleTransformer.dom(n, scope);
		              }
		            }
		          }
		        }
		        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {
		          var _n = mxn.removedNodes[_i];
		          if (_n.nodeType === Node.ELEMENT_NODE) {
		            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);
		            if (classIdx >= 0) {
		              // NOTE: relies on the scoping class always being adjacent to the
		              // SCOPE_NAME class.
		              var _scope = _n.classList[classIdx + 1];
		              if (_scope) {
		                StyleTransformer.dom(_n, _scope, true);
		              }
		            }
		          }
		        }
		      }
		    };
		
		    var observer = new MutationObserver(handler);
		    var startState = 'interactive';
		
		    var start = function start() {
		      return observer.observe(document.body, { childList: true, subtree: true });
		    };
		    if (window.HTMLImports) {
		      window.HTMLImports.whenReady(start);
		    } else if (document.readyState === startState) {
		      requestAnimationFrame(start);
		    } else {
		      document.addEventListener('readystatechange', function () {
		        if (document.readyState === startState) {
		          start();
		        }
		      });
		    }
		
		    flush = function flush() {
		      handler(observer.takeRecords());
		    };
		  })();
		}
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		// TODO(dfreedm): consider spliting into separate global
		var styleCache = new StyleCache();
		
		var ShadyCSS = {
		  flush: flush,
		  scopeCounter: {},
		  nativeShadow: nativeShadow,
		  nativeCss: nativeCssVariables,
		  nativeCssApply: nativeCssApply,
		  _documentOwner: document.documentElement,
		  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),
		  _generateScopeSelector: function _generateScopeSelector(name) {
		    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;
		    return name + '-' + id;
		  },
		  getStyleAst: function getStyleAst(style) {
		    return rulesForStyle(style);
		  },
		  styleAstToString: function styleAstToString(ast) {
		    return toCssText(ast);
		  },
		  _gatherStyles: function _gatherStyles(template) {
		    var styles = template.content.querySelectorAll('style');
		    var cssText = [];
		    for (var i = 0; i < styles.length; i++) {
		      var s = styles[i];
		      cssText.push(s.textContent);
		      s.parentNode.removeChild(s);
		    }
		    return cssText.join('').trim();
		  },
		  _getCssBuild: function _getCssBuild(template) {
		    var style = template.content.querySelector('style');
		    if (!style) {
		      return '';
		    }
		    return style.getAttribute('css-build') || '';
		  },
		  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {
		    if (template._prepared) {
		      return;
		    }
		    template._prepared = true;
		    template.name = elementName;
		    template.extends = typeExtension;
		    templateMap[elementName] = template;
		    var cssBuild = this._getCssBuild(template);
		    var cssText = this._gatherStyles(template);
		    var info = {
		      is: elementName,
		      extends: typeExtension,
		      __cssBuild: cssBuild
		    };
		    if (!this.nativeShadow) {
		      StyleTransformer.dom(template.content, elementName);
		    }
		    var ast = parse(cssText);
		    if (this.nativeCss && !this.nativeCssApply) {
		      applyShim.transformRules(ast, elementName);
		    }
		    template._styleAst = ast;
		
		    var ownPropertyNames = [];
		    if (!this.nativeCss) {
		      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);
		    }
		    if (!ownPropertyNames.length || this.nativeCss) {
		      var root = this.nativeShadow ? template.content : null;
		      var placeholder = placeholderMap[elementName];
		      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);
		      template._style = style;
		    }
		    template._ownPropertyNames = ownPropertyNames;
		  },
		  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {
		    var cssText = StyleTransformer.elementStyles(info, rules);
		    if (cssText.length) {
		      return applyCss(cssText, info.is, shadowroot, placeholder);
		    }
		  },
		  _prepareHost: function _prepareHost(host) {
		    var is = host.getAttribute('is') || host.localName;
		    var typeExtension = void 0;
		    if (is !== host.localName) {
		      typeExtension = host.localName;
		    }
		    var placeholder = placeholderMap[is];
		    var template = templateMap[is];
		    var ast = void 0;
		    var ownStylePropertyNames = void 0;
		    var cssBuild = void 0;
		    if (template) {
		      ast = template._styleAst;
		      ownStylePropertyNames = template._ownPropertyNames;
		      cssBuild = template._cssBuild;
		    }
		    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));
		  },
		  applyStyle: function applyStyle(host, overrideProps) {
		    var is = host.getAttribute('is') || host.localName;
		    if (window.CustomStyle) {
		      var CS = window.CustomStyle;
		      if (CS._documentDirty) {
		        CS.findStyles();
		        if (!this.nativeCss) {
		          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);
		        } else if (!this.nativeCssApply) {
		          CS._revalidateApplyShim();
		        }
		        CS.applyStyles();
		        CS._documentDirty = false;
		      }
		    }
		    var styleInfo = StyleInfo.get(host);
		    if (!styleInfo) {
		      styleInfo = this._prepareHost(host);
		    }
		    Object.assign(styleInfo.overrideStyleProperties, overrideProps);
		    if (this.nativeCss) {
		      var template = templateMap[is];
		      if (template && template.__applyShimInvalid && template._style) {
		        // update template
		        applyShim.transformRules(template._styleAst, is);
		        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);
		        // update instance if native shadowdom
		        if (this.nativeShadow) {
		          var style = host.shadowRoot.querySelector('style');
		          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);
		        }
		        styleInfo.styleRules = template._styleAst;
		      }
		      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);
		    } else {
		      this._updateProperties(host, styleInfo);
		      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {
		        // TODO: use caching
		        this._applyStyleProperties(host, styleInfo);
		      }
		    }
		    var root = this._isRootOwner(host) ? host : host.shadowRoot;
		    // note: some elements may not have a root!
		    if (root) {
		      this._applyToDescendants(root);
		    }
		  },
		  _applyToDescendants: function _applyToDescendants(root) {
		    var c$ = root.children;
		    for (var i = 0, c; i < c$.length; i++) {
		      c = c$[i];
		      if (c.shadowRoot) {
		        this.applyStyle(c);
		      }
		      this._applyToDescendants(c);
		    }
		  },
		  _styleOwnerForNode: function _styleOwnerForNode(node) {
		    var root = node.getRootNode();
		    var host = root.host;
		    if (host) {
		      if (StyleInfo.get(host)) {
		        return host;
		      } else {
		        return this._styleOwnerForNode(host);
		      }
		    }
		    return this._documentOwner;
		  },
		  _isRootOwner: function _isRootOwner(node) {
		    return node === this._documentOwner;
		  },
		  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {
		    var is = host.getAttribute('is') || host.localName;
		    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);
		    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;
		    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;
		    var oldScopeSelector = styleInfo.scopeSelector;
		    // only generate new scope if cached style is not found
		    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);
		    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);
		    if (!this.nativeShadow) {
		      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);
		    }
		    if (!cacheEntry) {
		      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);
		    }
		    return style;
		  },
		  _updateProperties: function _updateProperties(host, styleInfo) {
		    var owner = this._styleOwnerForNode(host);
		    var ownerStyleInfo = StyleInfo.get(owner);
		    var ownerProperties = ownerStyleInfo.styleProperties;
		    var props = Object.create(ownerProperties || null);
		    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);
		    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);
		    var propertiesMatchingHost = propertyData.properties;
		    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);
		    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);
		    StyleProperties.reify(props);
		    styleInfo.styleProperties = props;
		  },
		  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {
		    for (var p in overrides) {
		      var v = overrides[p];
		      // skip override props if they are not truthy or 0
		      // in order to fall back to inherited values
		      if (v || v === 0) {
		        props[p] = v;
		      }
		    }
		  },
		  _updateNativeProperties: function _updateNativeProperties(element, properties) {
		    // remove previous properties
		    for (var p in properties) {
		      // NOTE: for bc with shim, don't apply null values.
		      if (p === null) {
		        element.style.removeProperty(p);
		      } else {
		        element.style.setProperty(p, properties[p]);
		      }
		    }
		  },
		  updateStyles: function updateStyles(properties) {
		    if (window.CustomStyle) {
		      window.CustomStyle._documentDirty = true;
		    }
		    this.applyStyle(this._documentOwner, properties);
		  },
		
		  /* Custom Style operations */
		  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {
		    var _this = this;
		
		    var ast = rulesForStyle(style);
		    forEachRule(ast, function (rule) {
		      if (nativeShadow) {
		        StyleTransformer.normalizeRootSelector(rule);
		      } else {
		        StyleTransformer.documentRule(rule);
		      }
		      if (_this.nativeCss && !_this.nativeCssApply) {
		        applyShim.transformRule(rule);
		      }
		    });
		    if (this.nativeCss) {
		      style.textContent = toCssText(ast);
		    } else {
		      this._documentOwnerStyleInfo.styleRules.rules.push(ast);
		    }
		  },
		  _revalidateApplyShim: function _revalidateApplyShim(style) {
		    if (this.nativeCss && !this.nativeCssApply) {
		      var ast = rulesForStyle(style);
		      applyShim.transformRules(ast);
		      style.textContent = toCssText(ast);
		    }
		  },
		  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {
		    if (!this.nativeCss) {
		      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);
		    }
		  },
		  getComputedStyleValue: function getComputedStyleValue(element, property) {
		    var value = void 0;
		    if (!this.nativeCss) {
		      // element is either a style host, or an ancestor of a style host
		      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));
		      value = styleInfo.styleProperties[property];
		    }
		    // fall back to the property value from the computed styling
		    value = value || window.getComputedStyle(element).getPropertyValue(property);
		    // trim whitespace that can come after the `:` in css
		    // example: padding: 2px -> " 2px"
		    return value.trim();
		  },
		
		  // given an element and a classString, replaces
		  // the element's class with the provided classString and adds
		  // any necessary ShadyCSS static and property based scoping selectors
		  // NOTE: this method is suitable to be called in an environment in which
		  // setAttribute('class', ...) and className setter have been overridden so
		  // it cannot rely on those methods.
		  setElementClass: function setElementClass(element, classString) {
		    var _element$classList;
		
		    // use classList to clear existing classes
		    while (element.classList.length) {
		      element.classList.remove(element.classList[0]);
		    }
		    // add user classString
		    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));
		    // add static scoping: scope by shadyRoot
		    var root = element.getRootNode();
		    if (root.host) {
		      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);
		    }
		    // add property scoping: scope by special selector
		    if (!this.nativeCss) {
		      var styleInfo = StyleInfo.get(element);
		      if (styleInfo && styleInfo.scopeSelector) {
		        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);
		      }
		    }
		  },
		  _styleInfoForNode: function _styleInfoForNode(node) {
		    return StyleInfo.get(node);
		  }
		};
		
		window['ShadyCSS'] = ShadyCSS;
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		
		/*
		Wrapper over <style> elements to co-operate with ShadyCSS
		
		Example:
		<shady-style>
		  <style>
		  ...
		  </style>
		</shady-style>
		*/
		
		var ShadyCSS$1 = window.ShadyCSS;
		
		var enqueued = false;
		
		var customStyles = [];
		
		var hookFn = null;
		
		/*
		If a page only has <custom-style> elements, it will flash unstyled content,
		as all the instances will boot asynchronously after page load.
		
		Calling ShadyCSS.updateStyles() will force the work to happen synchronously
		*/
		function enqueueDocumentValidation() {
		  if (enqueued) {
		    return;
		  }
		  enqueued = true;
		  if (window.HTMLImports) {
		    window.HTMLImports.whenReady(validateDocument);
		  } else if (document.readyState === 'complete') {
		    requestAnimationFrame(validateDocument);
		  } else {
		    document.addEventListener('readystatechange', function () {
		      if (document.readyState === 'complete') {
		        validateDocument();
		      }
		    });
		  }
		}
		
		// NOTE: Make sure to enqueue eagerly. This is an optimization that
		// helps ensure that the first run of validateDocument will actually
		// have access to all the custom-style's created via loading imports.
		// If the first created custom-style calls enqueue and HTMLImports.ready
		// is true at that time (which is the case when HTMLImports are polyfilled),
		// then the enqueue immediately calls validateDocument and work that could be
		// batched is not.
		enqueueDocumentValidation();
		
		function validateDocument() {
		  if (enqueued) {
		    ShadyCSS$1.updateStyles();
		    enqueued = false;
		  }
		}
		
		function CustomStyle() {
		  /*
		  Use Reflect to invoke the HTMLElement constructor, or rely on the
		  CustomElement polyfill replacement that can be `.call`ed
		  */
		  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);
		  customStyles.push(self);
		  enqueueDocumentValidation();
		  return self;
		}
		
		Object.defineProperties(CustomStyle, {
		  /*
		  CustomStyle.processHook is provided to customize the <style> element child of
		  a <custom-style> element before the <style> is processed by ShadyCSS
		   The function must take a <style> element as input, and return nothing.
		  */
		  processHook: {
		    get: function get() {
		      return hookFn;
		    },
		    set: function set(fn) {
		      hookFn = fn;
		      return fn;
		    }
		  },
		  _customStyles: {
		    get: function get() {
		      return customStyles;
		    }
		  },
		  _documentDirty: {
		    get: function get() {
		      return enqueued;
		    },
		    set: function set(value) {
		      enqueued = value;
		      return value;
		    }
		  }
		});
		
		CustomStyle.findStyles = function () {
		  for (var i = 0; i < customStyles.length; i++) {
		    customStyles[i]._findStyle();
		  }
		};
		
		CustomStyle._revalidateApplyShim = function () {
		  for (var i = 0; i < customStyles.length; i++) {
		    var s = customStyles[i];
		    if (s._style) {
		      ShadyCSS$1._revalidateApplyShim(s._style);
		    }
		  }
		};
		
		CustomStyle.applyStyles = function () {
		  for (var i = 0; i < customStyles.length; i++) {
		    customStyles[i]._applyStyle();
		  }
		};
		
		CustomStyle.prototype = Object.create(HTMLElement.prototype, {
		  'constructor': {
		    value: CustomStyle,
		    configurable: true,
		    writable: true
		  }
		});
		
		CustomStyle.prototype._findStyle = function () {
		  if (!this._style) {
		    var style = this.querySelector('style');
		    if (!style) {
		      return;
		    }
		    // HTMLImports polyfill may have cloned the style into the main document,
		    // which is referenced with __appliedElement.
		    // Also, we must copy over the attributes.
		    if (style.__appliedElement) {
		      for (var i = 0; i < style.attributes.length; i++) {
		        var attr = style.attributes[i];
		        style.__appliedElement.setAttribute(attr.name, attr.value);
		      }
		    }
		    this._style = style.__appliedElement || style;
		    if (hookFn) {
		      hookFn(this._style);
		    }
		    ShadyCSS$1._transformCustomStyleForDocument(this._style);
		  }
		};
		
		CustomStyle.prototype._applyStyle = function () {
		  if (this._style) {
		    ShadyCSS$1._applyCustomStyleToDocument(this._style);
		  }
		};
		
		window.customElements.define('custom-style', CustomStyle);
		window['CustomStyle'] = CustomStyle;
		
		/**
		@license
		Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
		This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
		The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
		The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
		Code distributed by Google as part of the polymer project is also
		subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
		*/
		/*
		Small module to load ShadyCSS and CustomStyle together
		*/
		
		}());
		
		//# sourceMappingURL=shadycss.min.js.map
	
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=index.js.map

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _skatejs = __webpack_require__(3);
	
	var _helpers = __webpack_require__(6);
	
	var _body = __webpack_require__(28);
	
	var _body2 = _interopRequireDefault(_body);
	
	var _footer = __webpack_require__(29);
	
	var _footer2 = _interopRequireDefault(_footer);
	
	var _header = __webpack_require__(32);
	
	var _header2 = _interopRequireDefault(_header);
	
	var _module = __webpack_require__(34);
	
	var _module2 = _interopRequireDefault(_module);
	
	var _route = __webpack_require__(35);
	
	var _route2 = _interopRequireDefault(_route);
	
	var _title = __webpack_require__(36);
	
	var _title2 = _interopRequireDefault(_title);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */
	
	exports.default = (0, _skatejs.define)('sk-app', function (_Component) {
	  _inherits(_class, _Component);
	
	  _createClass(_class, null, [{
	    key: 'props',
	    get: function get() {
	      return {
	        page: {},
	        scrolled: _skatejs.prop.boolean()
	      };
	    }
	  }]);
	
	  function _class() {
	    _classCallCheck(this, _class);
	
	    // Setup the Gitter script before it's rendered.
	    var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));
	
	    ((window.gitter = {}).chat = {}).options = {
	      room: 'skatejs/skatejs'
	    };
	    return _this;
	  }
	
	  _createClass(_class, [{
	    key: 'connectedCallback',
	    value: function connectedCallback() {
	      var _this2 = this;
	
	      _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);
	      window.addEventListener('scroll', this._scrollHandler = function () {
	        return _this2.scrolled = !!window.scrollY;
	      });
	    }
	  }, {
	    key: 'disconnectedCallback',
	    value: function disconnectedCallback() {
	      _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this).call(this);
	      window.removeEventListener('scroll', this._scrollHandler);
	    }
	  }, {
	    key: 'renderCallback',
	    value: function renderCallback() {
	      var _this3 = this;
	
	      var Page = this.page;
	      var render = function render(page) {
	        _this3.page = page.default;
	      };
	      (0, _title2.default)('SkateJS - functional web components');
	      return [(0, _skatejs.h)(
	        'div',
	        null,
	        (0, _skatejs.h)(_route2.default, { path: '/', match: function match() {
	            return (0, _skatejs.h)(_module2.default, { load: __webpack_require__(37), done: render });
	          } }),
	        (0, _skatejs.h)(_route2.default, { path: '/getting-started', match: function match() {
	            return (0, _skatejs.h)(_module2.default, { load: __webpack_require__(40), done: render });
	          } }),
	        (0, _skatejs.h)(_route2.default, { path: '/docs', match: function match() {
	            return (0, _skatejs.h)(_module2.default, { load: __webpack_require__(42), done: render });
	          } }),
	        (0, _skatejs.h)(_route2.default, { path: '/examples', match: function match() {
	            return (0, _skatejs.h)(_module2.default, { load: __webpack_require__(44), done: render });
	          } }),
	        (0, _skatejs.h)(_route2.default, { path: '/guides', match: function match() {
	            return (0, _skatejs.h)(_module2.default, { load: __webpack_require__(46), done: render });
	          } }),
	        (0, _skatejs.h)(_route2.default, { path: '/support', match: function match() {
	            return (0, _skatejs.h)(_module2.default, { load: __webpack_require__(48), done: render });
	          } }),
	        (0, _skatejs.h)(
	          _header2.default,
	          { scrolled: this.scrolled, title: 'SkateJS' },
	          (0, _skatejs.h)(
	            _helpers.Item,
	            { href: '/docs' },
	            'Docs'
	          )
	        ),
	        (0, _skatejs.h)(
	          _body2.default,
	          null,
	          Page ? (0, _skatejs.h)(Page, null) : ''
	        ),
	        (0, _skatejs.h)(_footer2.default, null)
	      ), (0, _skatejs.h)('script', { src: 'http://sidecar.gitter.im/dist/sidecar.v1.js', async: true, defer: true })];
	    }
	  }]);
	
	  return _class;
	}(_skatejs.Component));

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(4), __webpack_require__(5)) :
	  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :
	  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));
	}(this, (function (exports,incrementalDom,root) {
	
	root = 'default' in root ? root['default'] : root;
	
	function keys() {
	  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  var _ref$enumOnly = _ref.enumOnly;
	  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;
	
	  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);
	  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;
	}
	
	// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.
	// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.
	var assign = (function (obj) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	
	  args.forEach(function (arg) {
	    return keys(arg).forEach(function (name) {
	      return obj[name] = arg[name];
	    });
	  }); // eslint-disable-line no-return-assign
	  return obj;
	});
	
	var empty = function (val) {
	  return typeof val === 'undefined' || val === null;
	};
	
	var alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {
	  return isNaN(val) ? undefined : Number(val);
	};
	var alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {
	  return empty(val) ? undefined : String(val);
	};
	
	function create(def) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    args.unshift({}, def);
	    return assign.apply(undefined, args);
	  };
	}
	
	var array = create({
	  coerce: function coerce(val) {
	    return Array.isArray(val) ? val : [val];
	  },
	  default: function _default() {
	    return [];
	  },
	  deserialize: JSON.parse,
	  serialize: JSON.stringify
	});
	
	var boolean = create({
	  coerce: function coerce(value) {
	    return !!value;
	  },
	  default: false,
	  deserialize: function deserialize(value) {
	    return !(value === null);
	  },
	  serialize: function serialize(value) {
	    return value ? '' : undefined;
	  }
	});
	
	var number = create({
	  default: 0,
	  coerce: alwaysUndefinedIfNotANumberOrNumber,
	  deserialize: alwaysUndefinedIfNotANumberOrNumber,
	  serialize: alwaysUndefinedIfNotANumberOrNumber
	});
	
	var string = create({
	  default: '',
	  coerce: alwaysUndefinedIfEmptyOrString,
	  deserialize: alwaysUndefinedIfEmptyOrString,
	  serialize: alwaysUndefinedIfEmptyOrString
	});
	
	var prop = Object.freeze({
		create: create,
		array: array,
		boolean: boolean,
		number: number,
		string: string
	});
	
	var connected = '____skate_connected';
	var created$1 = '____skate_created';
	
	// DEPRECATED
	//
	// This is the only "symbol" that must stay a string. This is because it is
	// relied upon across several versions. We should remove it, but ensure that
	// it's considered a breaking change that whatever version removes it cannot
	// be passed to vdom functions as tag names.
	var name = '____skate_name';
	
	// Used on the Constructor
	var ctorCreateInitProps = '____skate_ctor_createInitProps';
	var ctorObservedAttributes = '____skate_ctor_observedAttributes';
	var ctorProps = '____skate_ctor_props';
	var ctorPropsMap = '____skate_ctor_propsMap';
	
	// Used on the Element
	var props = '____skate_props';
	var ref$1 = '____skate_ref';
	var renderer$1 = '____skate_renderer';
	var rendering = '____skate_rendering';
	var rendererDebounced = '____skate_rendererDebounced';
	var updated$1 = '____skate_updated';
	
	// DEPRECTAED
	//
	// We should not be relying on internals for symbols as this creates version
	// coupling. We will move forward with platform agnostic ways of doing this.
	
	
	var symbols$1 = Object.freeze({
		name: name
	});
	
	function enter(object, props) {
	  var saved = {};
	  Object.keys(props).forEach(function (key) {
	    saved[key] = object[key];
	    object[key] = props[key];
	  });
	  return saved;
	}
	
	function exit(object, saved) {
	  assign(object, saved);
	}
	
	// Decorates a function with a side effect that changes the properties of an
	// object during its execution, and restores them after. There is no error
	// handling here, if the wrapped function throws an error, properties are not
	// restored and all bets are off.
	var propContext = function (object, props) {
	  return function (func) {
	    return function () {
	      var saved = enter(object, props);
	      var result = func.apply(undefined, arguments);
	      exit(object, saved);
	      return result;
	    };
	  };
	};
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};
	
	
	
	
	
	var asyncGenerator = function () {
	  function AwaitValue(value) {
	    this.value = value;
	  }
	
	  function AsyncGenerator(gen) {
	    var front, back;
	
	    function send(key, arg) {
	      return new Promise(function (resolve, reject) {
	        var request = {
	          key: key,
	          arg: arg,
	          resolve: resolve,
	          reject: reject,
	          next: null
	        };
	
	        if (back) {
	          back = back.next = request;
	        } else {
	          front = back = request;
	          resume(key, arg);
	        }
	      });
	    }
	
	    function resume(key, arg) {
	      try {
	        var result = gen[key](arg);
	        var value = result.value;
	
	        if (value instanceof AwaitValue) {
	          Promise.resolve(value.value).then(function (arg) {
	            resume("next", arg);
	          }, function (arg) {
	            resume("throw", arg);
	          });
	        } else {
	          settle(result.done ? "return" : "normal", result.value);
	        }
	      } catch (err) {
	        settle("throw", err);
	      }
	    }
	
	    function settle(type, value) {
	      switch (type) {
	        case "return":
	          front.resolve({
	            value: value,
	            done: true
	          });
	          break;
	
	        case "throw":
	          front.reject(value);
	          break;
	
	        default:
	          front.resolve({
	            value: value,
	            done: false
	          });
	          break;
	      }
	
	      front = front.next;
	
	      if (front) {
	        resume(front.key, front.arg);
	      } else {
	        back = null;
	      }
	    }
	
	    this._invoke = send;
	
	    if (typeof gen.return !== "function") {
	      this.return = undefined;
	    }
	  }
	
	  if (typeof Symbol === "function" && Symbol.asyncIterator) {
	    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
	      return this;
	    };
	  }
	
	  AsyncGenerator.prototype.next = function (arg) {
	    return this._invoke("next", arg);
	  };
	
	  AsyncGenerator.prototype.throw = function (arg) {
	    return this._invoke("throw", arg);
	  };
	
	  AsyncGenerator.prototype.return = function (arg) {
	    return this._invoke("return", arg);
	  };
	
	  return {
	    wrap: function (fn) {
	      return function () {
	        return new AsyncGenerator(fn.apply(this, arguments));
	      };
	    },
	    await: function (value) {
	      return new AwaitValue(value);
	    }
	  };
	}();
	
	
	
	
	
	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	
	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();
	
	
	
	
	
	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};
	
	var get$1 = function get$1(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = Object.getOwnPropertyDescriptor(object, property);
	
	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);
	
	    if (parent === null) {
	      return undefined;
	    } else {
	      return get$1(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;
	
	    if (getter === undefined) {
	      return undefined;
	    }
	
	    return getter.call(receiver);
	  }
	};
	
	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }
	
	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};
	
	
	
	
	
	
	
	
	
	
	
	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};
	
	
	
	var set$1 = function set$1(object, property, value, receiver) {
	  var desc = Object.getOwnPropertyDescriptor(object, property);
	
	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);
	
	    if (parent !== null) {
	      set$1(parent, property, value, receiver);
	    }
	  } else if ("value" in desc && desc.writable) {
	    desc.value = value;
	  } else {
	    var setter = desc.set;
	
	    if (setter !== undefined) {
	      setter.call(receiver, value);
	    }
	  }
	
	  return value;
	};
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
	
	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};
	
	/* eslint no-plusplus: 0 */
	
	var customElements = root.customElements;
	var HTMLElement = root.HTMLElement;
	
	var applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];
	
	// A stack of children that corresponds to the current function helper being
	// executed.
	var stackChren = [];
	
	var $skip = '__skip';
	var $currentEventHandlers = '__events';
	var $stackCurrentHelperProps = '__props';
	
	// The current function helper in the stack.
	var stackCurrentHelper = void 0;
	
	// This is used for the Incremental DOM overrides to keep track of what args
	// to pass the main elementOpen() function.
	var overrideArgs = void 0;
	
	// The number of levels deep after skipping a tree.
	var skips = 0;
	
	var noop = function noop() {};
	
	// Adds or removes an event listener for an element.
	function applyEvent(elem, ename, newFunc) {
	  var events = elem[$currentEventHandlers];
	
	  if (!events) {
	    events = elem[$currentEventHandlers] = {};
	  }
	
	  // Undefined indicates that there is no listener yet.
	  if (typeof events[ename] === 'undefined') {
	    // We only add a single listener once. Originally this was a workaround for
	    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's
	    // also a simpler model for binding / unbinding events because you only
	    // have a single handler you need to worry about and a single place where
	    // you only store one event handler
	    elem.addEventListener(ename, function (e) {
	      if (events[ename]) {
	        events[ename].call(this, e);
	      }
	    });
	  }
	
	  // Not undefined indicates that we have set a listener, so default to null.
	  events[ename] = typeof newFunc === 'function' ? newFunc : null;
	}
	
	var attributesContext = propContext(incrementalDom.attributes, defineProperty({
	  // Attributes that shouldn't be applied to the DOM.
	  key: noop,
	  statics: noop,
	
	  // Attributes that *must* be set via a property on all elements.
	  checked: incrementalDom.applyProp,
	  className: incrementalDom.applyProp,
	  disabled: incrementalDom.applyProp,
	  value: incrementalDom.applyProp,
	
	  // Ref handler.
	  ref: function ref(elem, name$$1, value) {
	    elem[ref$1] = value;
	  },
	
	
	  // Skip handler.
	  skip: function skip(elem, name$$1, value) {
	    if (value) {
	      elem[$skip] = true;
	    } else {
	      delete elem[$skip];
	    }
	  }
	}, incrementalDom.symbols.default, function (elem, name$$1, value) {
	  var _ref = customElements.get(elem.localName) || {
	    props: {},
	    prototype: {}
	  };
	
	  var props$$1 = _ref.props;
	  var prototype = _ref.prototype;
	
	  // TODO when refactoring properties to not have to workaround the old
	  // WebKit bug we can remove the "name in props" check below.
	  //
	  // NOTE: That the "name in elem" check won't work for polyfilled custom
	  // elements that set a property that isn't explicitly specified in "props"
	  // or "prototype" unless it is added to the element explicitly as a
	  // property prior to passing the prop to the vdom function. For example, if
	  // it were added in a lifecycle callback because it wouldn't have been
	  // upgraded yet.
	  //
	  // We prefer setting props, so we do this if there's a property matching
	  // name that was passed. However, certain props on SVG elements are
	  // readonly and error when you try to set them.
	
	  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {
	    incrementalDom.applyProp(elem, name$$1, value);
	    return;
	  }
	
	  // Explicit false removes the attribute.
	  if (value === false) {
	    applyDefault(elem, name$$1);
	    return;
	  }
	
	  // Handle built-in and custom events.
	  if (name$$1.indexOf('on') === 0) {
	    var firstChar = name$$1[2];
	    var eventName = void 0;
	
	    if (firstChar === '-') {
	      eventName = name$$1.substring(3);
	    } else if (firstChar === firstChar.toUpperCase()) {
	      eventName = firstChar.toLowerCase() + name$$1.substring(3);
	    }
	
	    if (eventName) {
	      applyEvent(elem, eventName, value);
	      return;
	    }
	  }
	
	  applyDefault(elem, name$$1, value);
	}));
	
	function resolveTagName(name$$1) {
	  // We return falsy values as some wrapped IDOM functions allow empty values.
	  if (!name$$1) {
	    return name$$1;
	  }
	
	  // We try and return the cached tag name, if one exists.
	  if (name$$1[name]) {
	    return name$$1[name];
	  }
	
	  // If it's a custom element, we get the tag name by constructing it and
	  // caching it.
	  if (name$$1.prototype instanceof HTMLElement) {
	    // eslint-disable-next-line
	    var elem = new name$$1();
	    return name$$1[name] = elem.localName;
	  }
	
	  // Pass all other values through so IDOM gets what it's expecting.
	  return name$$1;
	}
	
	// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,
	// so it's the only function we need to execute in the context of our attributes.
	var elementOpen$1 = attributesContext(incrementalDom.elementOpen);
	
	function elementOpenStart(tag) {
	  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	
	  overrideArgs = [tag, key, statics];
	}
	
	function elementOpenEnd() {
	  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define
	  overrideArgs = null;
	  return node;
	}
	
	function wrapIdomFunc(func) {
	  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	
	  return function wrap() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    args[0] = resolveTagName(args[0]);
	    stackCurrentHelper = null;
	    if (typeof args[0] === 'function') {
	      // If we've encountered a function, handle it according to the type of
	      // function that is being wrapped.
	      stackCurrentHelper = args[0];
	      return tnameFuncHandler.apply(undefined, args);
	    } else if (stackChren.length) {
	      // We pass the wrap() function in here so that when it's called as
	      // children, it will queue up for the next stack, if there is one.
	      stackChren[stackChren.length - 1].push([wrap, args]);
	    } else {
	      if (func === elementOpen$1) {
	        if (skips) {
	          return ++skips;
	        }
	
	        var elem = func.apply(undefined, args);
	
	        if (elem[$skip]) {
	          ++skips;
	        }
	
	        return elem;
	      }
	
	      if (func === incrementalDom.elementClose) {
	        if (skips === 1) {
	          incrementalDom.skip();
	        }
	
	        // We only want to skip closing if it's not the last closing tag in the
	        // skipped tree because we keep the element that initiated the skpping.
	        if (skips && --skips) {
	          return;
	        }
	
	        var _elem = func.apply(undefined, args);
	        var ref$$1 = _elem[ref$1];
	
	        // We delete so that it isn't called again for the same element. If the
	        // ref changes, or the element changes, this will be defined again.
	        delete _elem[ref$1];
	
	        // Execute the saved ref after esuring we've cleand up after it.
	        if (typeof ref$$1 === 'function') {
	          ref$$1(_elem);
	        }
	
	        return _elem;
	      }
	
	      // We must call elementOpenStart and elementOpenEnd even if we are
	      // skipping because they queue up attributes and then call elementClose.
	      if (!skips || func === elementOpenStart || func === elementOpenEnd) {
	        return func.apply(undefined, args);
	      }
	    }
	  };
	}
	
	function newAttr() {
	  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }
	
	  if (stackCurrentHelper) {
	    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];
	  } else if (stackChren.length) {
	    stackChren[stackChren.length - 1].push([newAttr, args]);
	  } else {
	    overrideArgs.push(args[0]);
	    overrideArgs.push(args[1]);
	  }
	}
	
	function stackOpen(tname, key, statics) {
	  var props$$1 = { key: key, statics: statics };
	
	  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
	    attrs[_key3 - 3] = arguments[_key3];
	  }
	
	  for (var a = 0; a < attrs.length; a += 2) {
	    props$$1[attrs[a]] = attrs[a + 1];
	  }
	  tname[$stackCurrentHelperProps] = props$$1;
	  stackChren.push([]);
	}
	
	function stackClose(tname) {
	  var chren = stackChren.pop();
	  var props$$1 = tname[$stackCurrentHelperProps];
	  delete tname[$stackCurrentHelperProps];
	  var elemOrFn = tname(props$$1, function () {
	    return chren.forEach(function (args) {
	      return args[0].apply(args, toConsumableArray(args[1]));
	    });
	  });
	  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;
	}
	
	// Incremental DOM overrides
	// -------------------------
	
	// We must override internal functions that call internal Incremental DOM
	// functions because we can't override the internal references. This means
	// we must roughly re-implement their behaviour. Luckily, they're fairly
	// simple.
	var newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);
	var newElementOpenEnd = wrapIdomFunc(elementOpenEnd);
	
	// Standard open / closed overrides don't need to reproduce internal behaviour
	// because they are the ones referenced from *End and *Start.
	var newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);
	var newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);
	
	// Ensure we call our overridden functions instead of the internal ones.
	function newElementVoid(tag) {
	  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	    args[_key4 - 1] = arguments[_key4];
	  }
	
	  newElementOpen.apply(undefined, [tag].concat(args));
	  return newElementClose(tag);
	}
	
	// Text override ensures their calls can queue if using function helpers.
	var newText = wrapIdomFunc(incrementalDom.text);
	
	// Convenience function for declaring an Incremental DOM element using
	// hyperscript-style syntax.
	function element(tname, attrs) {
	  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);
	
	  // If attributes are a function, then they should be treated as children.
	
	  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
	    chren[_key5 - 2] = arguments[_key5];
	  }
	
	  if (atype === 'function' || atype === 'string' || atype === 'number') {
	    chren.unshift(attrs);
	  }
	
	  // Ensure the attributes are an object. Null is considered an object so we
	  // have to test for this explicitly.
	  if (attrs === null || atype !== 'object') {
	    attrs = {};
	  }
	
	  // We open the element so we can set attrs after.
	  newElementOpenStart(tname, attrs.key, attrs.statics);
	
	  // Delete so special attrs don't actually get set.
	  delete attrs.key;
	  delete attrs.statics;
	
	  // Set attributes.
	  Object.keys(attrs).forEach(function (name$$1) {
	    return newAttr(name$$1, attrs[name$$1]);
	  });
	
	  // Close before we render the descendant tree.
	  newElementOpenEnd(tname);
	
	  chren.forEach(function (ch) {
	    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);
	    if (ctype === 'function') {
	      ch();
	    } else if (ctype === 'string' || ctype === 'number') {
	      newText(ch);
	    } else if (Array.isArray(ch)) {
	      ch.forEach(function (sch) {
	        return sch();
	      });
	    }
	  });
	
	  return newElementClose(tname);
	}
	
	// Even further convenience for building a DSL out of JavaScript functions or hooking into standard
	// transpiles for JSX (React.createElement() / h).
	function builder() {
	  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    tags[_key6] = arguments[_key6];
	  }
	
	  if (tags.length === 0) {
	    return function () {
	      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
	        args[_key7] = arguments[_key7];
	      }
	
	      return element.bind.apply(element, [null].concat(args));
	    };
	  }
	  return tags.map(function (tag) {
	    return function () {
	      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
	        args[_key8] = arguments[_key8];
	      }
	
	      return element.bind.apply(element, [null, tag].concat(args));
	    };
	  });
	}
	
	
	
	var vdom = Object.freeze({
		element: element,
		builder: builder,
		attr: newAttr,
		elementClose: newElementClose,
		elementOpen: newElementOpen,
		elementOpenEnd: newElementOpenEnd,
		elementOpenStart: newElementOpenStart,
		elementVoid: newElementVoid,
		text: newText
	});
	
	function createSymbol(description) {
	  return typeof Symbol === 'function' ? Symbol(description) : description;
	}
	
	var data = function (element) {
	  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	
	  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});
	  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators
	};
	
	var dashCase = function (str) {
	  return str.split(/([A-Z])/).reduce(function (one, two, idx) {
	    var dash = !one || idx % 2 === 0 ? '' : '-';
	    return '' + one + dash + two.toLowerCase();
	  });
	};
	
	var nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0
	];
	var native = (function (fn) {
	  return nativeHints.map(function (hint) {
	    return (fn || '').toString().indexOf([hint]) > -1;
	  }).reduce(function (a, b) {
	    return a || b;
	  });
	});
	
	var MutationObserver = root.MutationObserver;
	
	
	function microtaskDebounce(cbFunc) {
	  var scheduled = false;
	  var i = 0;
	  var cbArgs = [];
	  var elem = document.createElement('span');
	  var observer = new MutationObserver(function () {
	    cbFunc.apply(undefined, toConsumableArray(cbArgs));
	    scheduled = false;
	    cbArgs = null;
	  });
	
	  observer.observe(elem, { childList: true });
	
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    cbArgs = args;
	    if (!scheduled) {
	      scheduled = true;
	      elem.textContent = '' + i;
	      i += 1;
	    }
	  };
	}
	
	// We have to use setTimeout() for IE9 and 10 because the Mutation Observer
	// polyfill requires that the element be in the document to trigger Mutation
	// Events. Mutation Events are also synchronous and thus wouldn't debounce.
	//
	// The soonest we can set the timeout for in IE is 1 as they have issues when
	// setting to 0.
	function taskDebounce(cbFunc) {
	  var scheduled = false;
	  var cbArgs = [];
	  return function () {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }
	
	    cbArgs = args;
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        cbFunc.apply(undefined, toConsumableArray(cbArgs));
	      }, 1);
	    }
	  };
	}
	var debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;
	
	var getOwnPropertyDescriptors = function () {
	  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  return keys(obj).reduce(function (prev, curr) {
	    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);
	    return prev;
	  }, {});
	};
	
	/**
	 * This is needed to avoid IE11 "stack size errors" when creating
	 * a new property on the constructor of an HTMLElement
	 */
	function setCtorNativeProperty(Ctor, propName, value) {
	  Object.defineProperty(Ctor, propName, { configurable: true, value: value });
	}
	
	/**
	 * Returns a cached map of property options for the given component class.
	 * Keys in the map are the properties name which can a string or a symbol.
	 *
	 * The map is created by caching the result of: static get props
	 */
	function getPropsMap(Ctor) {
	  // Must be defined on constructor and not from a superclass
	  if (!Ctor.hasOwnProperty(ctorPropsMap)) {
	    (function () {
	      var props$$1 = Ctor.props || {};
	
	      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {
	        result[propNameOrSymbol] = props$$1[propNameOrSymbol];
	        return result;
	      }, {});
	      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);
	    })();
	  }
	
	  return Ctor[ctorPropsMap];
	}
	
	function get$2(elem) {
	  var props$$1 = {};
	  keys(getPropsMap(elem.constructor)).forEach(function (key) {
	    props$$1[key] = elem[key];
	  });
	
	  return props$$1;
	}
	
	function set$2(elem, newProps) {
	  assign(elem, newProps);
	  if (elem[renderer$1]) {
	    elem[renderer$1]();
	  }
	}
	
	var props$1 = function (elem, newProps) {
	  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);
	};
	
	function getDefaultValue(elem, name, opts) {
	  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;
	}
	
	function getInitialValue(elem, name, opts) {
	  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;
	}
	
	function getPropData(elem, name) {
	  var elemData = data(elem, 'props');
	  return elemData[name] || (elemData[name] = {});
	}
	
	function syncFirstTimeProp(elem, prop, propName, attributeName, propData) {
	  var syncAttrValue = propData.lastAssignedValue;
	  if (empty(syncAttrValue)) {
	    if ('initial' in prop) {
	      syncAttrValue = getInitialValue(elem, propName, prop);
	    } else if ('default' in prop) {
	      syncAttrValue = getDefaultValue(elem, propName, prop);
	    }
	  }
	  if (!empty(syncAttrValue) && prop.serialize) {
	    syncAttrValue = prop.serialize(syncAttrValue);
	  }
	  if (!empty(syncAttrValue)) {
	    propData.syncingAttribute = true;
	    elem.setAttribute(attributeName, syncAttrValue);
	  }
	}
	
	function syncExistingProp(elem, prop, propName, attributeName, propData) {
	  if (attributeName && !propData.settingAttribute) {
	    var internalValue = propData.internalValue;
	
	    var serializedValue = prop.serialize(internalValue);
	    var currentAttrValue = elem.getAttribute(attributeName);
	    var serializedIsEmpty = empty(serializedValue);
	    var attributeChanged = !(serializedIsEmpty && empty(currentAttrValue) || serializedValue === currentAttrValue);
	
	    propData.syncingAttribute = true;
	
	    var shouldRemoveAttribute = empty(propData.lastAssignedValue);
	    if (shouldRemoveAttribute || serializedIsEmpty) {
	      elem.removeAttribute(attributeName);
	    } else {
	      elem.setAttribute(attributeName, serializedValue);
	    }
	
	    if (!attributeChanged && propData.syncingAttribute) {
	      propData.syncingAttribute = false;
	    }
	  }
	
	  // Allow the attribute to be linked again.
	  propData.settingAttribute = false;
	}
	
	function syncPropToAttr(elem, prop, propName, isFirstSync) {
	  var attributeName = data(elem, 'propertyLinks')[propName];
	  var propData = getPropData(elem, propName);
	
	  if (attributeName) {
	    if (isFirstSync) {
	      syncFirstTimeProp(elem, prop, propName, attributeName, propData);
	    } else {
	      syncExistingProp(elem, prop, propName, attributeName, propData);
	    }
	  }
	}
	
	function createNativePropertyDefinition(name$$1, opts) {
	  var prop = {
	    configurable: true,
	    enumerable: true
	  };
	
	  prop.created = function created(elem) {
	    var propData = getPropData(elem, name$$1);
	    var attributeName = opts.attribute === true ? dashCase(name$$1) : opts.attribute;
	    var initialValue = elem[name$$1];
	
	    // Store property to attribute link information.
	    data(elem, 'attributeLinks')[attributeName] = name$$1;
	    data(elem, 'propertyLinks')[name$$1] = attributeName;
	
	    // Set up initial value if it wasn't specified.
	    if (empty(initialValue)) {
	      if (attributeName && elem.hasAttribute(attributeName)) {
	        initialValue = opts.deserialize(elem.getAttribute(attributeName));
	      } else if ('initial' in opts) {
	        initialValue = getInitialValue(elem, name$$1, opts);
	      } else if ('default' in opts) {
	        initialValue = getDefaultValue(elem, name$$1, opts);
	      }
	    }
	
	    propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;
	  };
	
	  prop.get = function get() {
	    var propData = getPropData(this, name$$1);
	    var internalValue = propData.internalValue;
	
	    return typeof opts.get === 'function' ? opts.get(this, { name: name$$1, internalValue: internalValue }) : internalValue;
	  };
	
	  prop.set = function set(newValue) {
	    var propData = getPropData(this, name$$1);
	    propData.lastAssignedValue = newValue;
	    var oldValue = propData.oldValue;
	
	
	    if (empty(oldValue)) {
	      oldValue = null;
	    }
	
	    if (empty(newValue)) {
	      newValue = getDefaultValue(this, name$$1, opts);
	    }
	
	    if (typeof opts.coerce === 'function') {
	      newValue = opts.coerce(newValue);
	    }
	
	    var changeData = { name: name$$1, newValue: newValue, oldValue: oldValue };
	
	    if (typeof opts.set === 'function') {
	      opts.set(this, changeData);
	    }
	
	    // Queue a re-render.
	    this[rendererDebounced](this);
	
	    // Update prop data so we can use it next time.
	    propData.internalValue = propData.oldValue = newValue;
	
	    // Link up the attribute.
	    if (this[connected]) {
	      syncPropToAttr(this, opts, name$$1, false);
	    }
	  };
	
	  return prop;
	}
	
	var initProps = function (opts) {
	  opts = opts || {};
	
	  if (typeof opts === 'function') {
	    opts = { coerce: opts };
	  }
	
	  return function (name$$1) {
	    return createNativePropertyDefinition(name$$1, assign({
	      default: null,
	      deserialize: function deserialize(value) {
	        return value;
	      },
	      serialize: function serialize(value) {
	        return value;
	      }
	    }, opts));
	  };
	};
	
	var HTMLElement$1 = root.HTMLElement || function () {
	  function _class() {
	    classCallCheck(this, _class);
	  }
	
	  return _class;
	}();
	var _prevName = createSymbol('prevName');
	var _prevOldValue = createSymbol('prevOldValue');
	var _prevNewValue = createSymbol('prevNewValue');
	
	function preventDoubleCalling(elem, name$$1, oldValue, newValue) {
	  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];
	}
	
	function syncPropsToAttrs(elem) {
	  var props$$1 = getPropsMap(elem.constructor);
	  Object.keys(props$$1).forEach(function (propName) {
	    var prop = props$$1[propName];
	    syncPropToAttr(elem, prop, propName, true);
	  });
	}
	
	// TODO remove when not catering to Safari < 10.
	//
	// Ensures that definitions passed as part of the constructor are functions
	// that return property definitions used on the element.
	function ensurePropertyFunctions(Ctor) {
	  var props$$1 = getPropsMap(Ctor);
	  return keys(props$$1).reduce(function (descriptors, descriptorName) {
	    descriptors[descriptorName] = props$$1[descriptorName];
	    if (typeof descriptors[descriptorName] !== 'function') {
	      descriptors[descriptorName] = initProps(descriptors[descriptorName]);
	    }
	    return descriptors;
	  }, {});
	}
	
	// TODO remove when not catering to Safari < 10.
	//
	// This can probably be simplified into createInitProps().
	function ensurePropertyDefinitions(Ctor) {
	  var props$$1 = ensurePropertyFunctions(Ctor);
	  return keys(props$$1).reduce(function (descriptors, descriptorName) {
	    descriptors[descriptorName] = props$$1[descriptorName](descriptorName);
	    return descriptors;
	  }, {});
	}
	
	// TODO refactor when not catering to Safari < 10.
	//
	// We should be able to simplify this where all we do is Object.defineProperty().
	function createInitProps(Ctor) {
	  var props$$1 = ensurePropertyDefinitions(Ctor);
	
	  return function (elem) {
	    if (!props$$1) {
	      return;
	    }
	
	    keys(props$$1).forEach(function (name$$1) {
	      var prop = props$$1[name$$1];
	      prop.created(elem);
	
	      // We check here before defining to see if the prop was specified prior
	      // to upgrading.
	      var hasPropBeforeUpgrading = name$$1 in elem;
	
	      // This is saved prior to defining so that we can set it after it it was
	      // defined prior to upgrading. We don't want to invoke the getter if we
	      // don't need to, so we only get the value if we need to re-sync.
	      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];
	
	      // https://bugs.webkit.org/show_bug.cgi?id=49739
	      //
	      // When Webkit fixes that bug so that native property accessors can be
	      // retrieved, we can move defining the property to the prototype and away
	      // from having to do if for every instance as all other browsers support
	      // this.
	      Object.defineProperty(elem, name$$1, prop);
	
	      // DEPRECATED
	      //
	      // We'll be removing get / set callbacks on properties. Use the
	      // updatedCallback() instead.
	      //
	      // We re-set the prop if it was specified prior to upgrading because we
	      // need to ensure set() is triggered both in polyfilled environments and
	      // in native where the definition may be registerd after elements it
	      // represents have already been created.
	      if (hasPropBeforeUpgrading) {
	        elem[name$$1] = valueBeforeUpgrading;
	      }
	    });
	  };
	}
	
	var _class2 = function (_HTMLElement) {
	  inherits(_class2, _HTMLElement);
	  createClass(_class2, null, [{
	    key: 'observedAttributes',
	
	
	    /**
	     * Returns unique attribute names configured with props and
	     * those set on the Component constructor if any
	     */
	    get: function get() {
	      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];
	
	      var props$$1 = getPropsMap(this);
	      var attrsFromLinkedProps = Object.keys(props$$1).map(function (key) {
	        var attribute = props$$1[key].attribute;
	
	        return attribute === true ? dashCase(key) : attribute;
	      }).filter(Boolean);
	
	      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));
	
	      return all.filter(function (item, index) {
	        return all.indexOf(item) === index;
	      });
	    },
	    set: function set(value) {
	      value = Array.isArray(value) ? value : [];
	      setCtorNativeProperty(this, 'observedAttributes', value);
	    }
	
	    // Returns superclass props overwritten with this Component props
	
	  }, {
	    key: 'props',
	    get: function get() {
	      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);
	    },
	    set: function set(value) {
	      setCtorNativeProperty(this, ctorProps, value);
	    }
	  }]);
	
	  function _class2() {
	    classCallCheck(this, _class2);
	
	    var _this = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));
	
	    var constructor = _this.constructor;
	
	    // Used for the ready() function so it knows when it can call its callback.
	
	    _this[created$1] = true;
	
	    // TODO refactor to not cater to Safari < 10. This means we can depend on
	    // built-in property descriptors.
	    // Must be defined on constructor and not from a superclass
	    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {
	      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));
	    }
	
	    // Set up a renderer that is debounced for property sets to call directly.
	    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));
	
	    // Set up property lifecycle.
	    var propConfigsCount = keys(getPropsMap(constructor)).length;
	    if (propConfigsCount && constructor[ctorCreateInitProps]) {
	      constructor[ctorCreateInitProps](_this);
	    }
	
	    // DEPRECATED
	    //
	    // static render()
	    if (!_this.renderCallback && constructor.render) {
	      _this.renderCallback = constructor.render.bind(constructor, _this);
	    }
	
	    // DEPRECATED
	    //
	    // static created()
	    //
	    // Props should be set up before calling this.
	    if (typeof constructor.created === 'function') {
	      constructor.created(_this);
	    }
	
	    // DEPRECATED
	    //
	    // Feature has rarely been used.
	    //
	    // Created should be set before invoking the ready listeners.
	    var elemData = data(_this);
	    var readyCallbacks = elemData.readyCallbacks;
	    if (readyCallbacks) {
	      readyCallbacks.forEach(function (cb) {
	        return cb(_this);
	      });
	      delete elemData.readyCallbacks;
	    }
	    return _this;
	  }
	
	  // Custom Elements v1
	
	
	  createClass(_class2, [{
	    key: 'connectedCallback',
	    value: function connectedCallback() {
	      var constructor = this.constructor;
	
	      // DEPRECATED
	      //
	      // No more reflecting back to attributes in favour of one-way reflection.
	
	      syncPropsToAttrs(this);
	
	      // Used to check whether or not the component can render.
	      this[connected] = true;
	
	      // Render!
	      this[rendererDebounced]();
	
	      // DEPRECATED
	      //
	      // static attached()
	      if (typeof constructor.attached === 'function') {
	        constructor.attached(this);
	      }
	
	      // DEPRECATED
	      //
	      // We can remove this once all browsers support :defined.
	      this.setAttribute('defined', '');
	    }
	
	    // Custom Elements v1
	
	  }, {
	    key: 'disconnectedCallback',
	    value: function disconnectedCallback() {
	      var constructor = this.constructor;
	
	      // Ensures the component can't be rendered while disconnected.
	
	      this[connected] = false;
	
	      // DEPRECATED
	      //
	      // static detached()
	      if (typeof constructor.detached === 'function') {
	        constructor.detached(this);
	      }
	    }
	
	    // Custom Elements v1
	
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name$$1, oldValue, newValue) {
	      // Polyfill calls this twice.
	      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {
	        return;
	      }
	
	      // Set data so we can prevent double calling if the polyfill.
	      this[_prevName] = name$$1;
	      this[_prevOldValue] = oldValue;
	      this[_prevNewValue] = newValue;
	
	      var attributeChanged = this.constructor.attributeChanged;
	
	      var propertyName = data(this, 'attributeLinks')[name$$1];
	
	      if (propertyName) {
	        var propData = data(this, 'props')[propertyName];
	
	        // This ensures a property set doesn't cause the attribute changed
	        // handler to run again once we set this flag. This only ever has a
	        // chance to run when you set an attribute, it then sets a property and
	        // then that causes the attribute to be set again.
	        if (propData.syncingAttribute) {
	          propData.syncingAttribute = false;
	        } else {
	          // Sync up the property.
	          var propOpts = getPropsMap(this.constructor)[propertyName];
	          propData.settingAttribute = true;
	          var newPropVal = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;
	          this[propertyName] = newPropVal;
	        }
	      }
	
	      if (attributeChanged) {
	        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });
	      }
	    }
	
	    // Skate
	    //
	    // Maps to the static updated() callback. That logic should be moved here
	    // when that is finally removed.
	
	  }, {
	    key: 'updatedCallback',
	    value: function updatedCallback(prev) {
	      return this.constructor.updated(this, prev);
	    }
	
	    // Skate
	    //
	    // Maps to the static rendered() callback. That logic should be moved here
	    // when that is finally removed.
	
	  }, {
	    key: 'renderedCallback',
	    value: function renderedCallback() {
	      return this.constructor.rendered(this);
	    }
	
	    // Skate
	    //
	    // Maps to the static renderer() callback. That logic should be moved here
	    // when that is finally removed.
	
	  }, {
	    key: 'rendererCallback',
	    value: function rendererCallback() {
	      return this.constructor.renderer(this);
	    }
	
	    // Skate
	    //
	    // Invokes the complete render lifecycle.
	
	  }, {
	    key: renderer$1,
	    value: function value() {
	      if (this[rendering] || !this[connected]) {
	        return;
	      }
	
	      // Flag as rendering. This prevents anything from trying to render - or
	      // queueing a render - while there is a pending render.
	      this[rendering] = true;
	
	      if (this[updated$1]() && typeof this.renderCallback === 'function') {
	        this.rendererCallback();
	        this.renderedCallback();
	      }
	
	      this[rendering] = false;
	    }
	
	    // Skate
	    //
	    // Calls the user-defined updated() lifecycle callback.
	
	  }, {
	    key: updated$1,
	    value: function value() {
	      var prev = this[props];
	      this[props] = props$1(this);
	      return this.updatedCallback(prev);
	    }
	
	    // Skate
	
	  }], [{
	    key: 'extend',
	    value: function extend() {
	      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	
	      // Create class for the user.
	      var Ctor = function (_Base) {
	        inherits(Ctor, _Base);
	
	        function Ctor() {
	          classCallCheck(this, Ctor);
	          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));
	        }
	
	        return Ctor;
	      }(Base);
	
	      // For inheriting from the object literal.
	
	
	      var opts = getOwnPropertyDescriptors(definition);
	      var prot = getOwnPropertyDescriptors(definition.prototype);
	
	      // Prototype is non configurable (but is writable).
	      delete opts.prototype;
	
	      // Pass on static and instance members from the definition.
	      Object.defineProperties(Ctor, opts);
	      Object.defineProperties(Ctor.prototype, prot);
	
	      return Ctor;
	    }
	
	    // Skate
	    //
	    // DEPRECATED
	    //
	    // Move this to rendererCallback() before removing.
	
	  }, {
	    key: 'updated',
	    value: function updated(elem, prev) {
	      if (!prev) {
	        return true;
	      }
	
	      // use get all keys so that we check Symbols as well as regular props
	      // using a for loop so we can break early
	      var allKeys = keys(prev);
	      for (var i = 0; i < allKeys.length; i += 1) {
	        if (prev[allKeys[i]] !== elem[allKeys[i]]) {
	          return true;
	        }
	      }
	
	      return false;
	    }
	
	    // Skate
	    //
	    // DEPRECATED
	    //
	    // Move this to rendererCallback() before removing.
	
	  }, {
	    key: 'rendered',
	    value: function rendered() {}
	
	    // Skate
	    //
	    // DEPRECATED
	    //
	    // Move this to rendererCallback() before removing.
	
	  }, {
	    key: 'renderer',
	    value: function renderer(elem) {
	      if (!elem.shadowRoot) {
	        elem.attachShadow({ mode: 'open' });
	      }
	      incrementalDom.patchInner(elem.shadowRoot, function () {
	        var possibleFn = elem.renderCallback();
	        if (typeof possibleFn === 'function') {
	          possibleFn();
	        } else if (Array.isArray(possibleFn)) {
	          possibleFn.forEach(function (fn) {
	            if (typeof fn === 'function') {
	              fn();
	            }
	          });
	        }
	      });
	    }
	  }]);
	  return _class2;
	}(HTMLElement$1);
	
	function uniqueId(prefix) {
	  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523
	  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0;
	    // eslint-disable-next-line no-mixed-operators
	    var v = c === 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	  return (prefix || 'x') + '-' + rand;
	}
	
	var define = function () {
	  var customElements = root.customElements;
	
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  var name$$1 = args[0];
	  var Ctor = args[1];
	
	
	  if (!customElements) {
	    throw new Error('Skate requires native custom element support or a polyfill.');
	  }
	
	  // Support passing an anonymous definition.
	  if (args.length === 1) {
	    // We are checking string for now, but once we remove the ability to pass
	    // an object literal, we can change this to check "function" and invert the
	    // blocks of logic.
	    if (typeof name$$1 === 'string') {
	      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');
	    } else {
	      Ctor = name$$1;
	      name$$1 = uniqueId();
	    }
	  }
	
	  // Ensure there's no conflicts.
	  if (customElements.get(name$$1)) {
	    name$$1 = uniqueId(name$$1);
	  }
	
	  // DEPRECATED
	  //
	  // Object literals.
	  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {
	    Ctor = _class2.extend(Ctor);
	  }
	
	  // This allows us to check this before instantiating the custom element to
	  // find its name from the constructor in the vdom module, thus improving
	  // performance but still falling back to a robust method.
	  Ctor[name] = name$$1;
	
	  // Sipmle define. Not supporting customised built-ins yet.
	  customElements.define(name$$1, Ctor);
	
	  // The spec doesn't return but this allows for a simpler, more concise API.
	  return Ctor;
	};
	
	var Event = function (TheEvent) {
	  if (TheEvent) {
	    try {
	      new TheEvent('emit-init'); // eslint-disable-line no-new
	    } catch (e) {
	      return undefined;
	    }
	  }
	  return TheEvent;
	}(root.Event);
	
	function createCustomEvent(name) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var detail = opts.detail;
	
	  delete opts.detail;
	
	  var e = void 0;
	  if (Event) {
	    e = new Event(name, opts);
	    Object.defineProperty(e, 'detail', { value: detail });
	  } else {
	    e = document.createEvent('CustomEvent');
	    Object.defineProperty(e, 'composed', { value: opts.composed });
	    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);
	  }
	  return e;
	}
	
	var emit = function (elem, name) {
	  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	  if (opts.bubbles === undefined) {
	    opts.bubbles = true;
	  }
	  if (opts.cancelable === undefined) {
	    opts.cancelable = true;
	  }
	  if (opts.composed === undefined) {
	    opts.composed = true;
	  }
	  return elem.dispatchEvent(createCustomEvent(name, opts));
	};
	
	function getValue(elem) {
	  var type = elem.type;
	  if (type === 'checkbox' || type === 'radio') {
	    return elem.checked ? elem.value || true : false;
	  }
	  return elem.value;
	}
	
	var link = function (elem, target) {
	  return function (e) {
	    var value = getValue(e.target);
	    var localTarget = target || e.target.name || 'value';
	
	    if (localTarget.indexOf('.') > -1) {
	      var parts = localTarget.split('.');
	      var firstPart = parts[0];
	      var propName = parts.pop();
	      var obj = parts.reduce(function (prev, curr) {
	        return prev && prev[curr];
	      }, elem);
	
	      obj[propName || e.target.name] = value;
	      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));
	    } else {
	      props$1(elem, defineProperty({}, localTarget, value));
	    }
	  };
	};
	
	var ready = function (elem, done) {
	  var info = data(elem);
	  if (elem[created$1]) {
	    done(elem);
	  } else if (info.readyCallbacks) {
	    info.readyCallbacks.push(done);
	  } else {
	    info.readyCallbacks = [done];
	  }
	};
	
	var h = builder();
	
	exports.Component = _class2;
	exports.define = define;
	exports.emit = emit;
	exports.h = h;
	exports.link = link;
	exports.prop = prop;
	exports.props = props$1;
	exports.ready = ready;
	exports.symbols = symbols$1;
	exports.vdom = vdom;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=index.js.map


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * @license
	 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS-IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	'use strict';
	
	/**
	 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS-IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * A cached reference to the hasOwnProperty function.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * A cached reference to the create function.
	 */
	var create = Object.create;
	
	/**
	 * Used to prevent property collisions between our "map" and its prototype.
	 * @param {!Object<string, *>} map The map to check.
	 * @param {string} property The property to check.
	 * @return {boolean} Whether map has property.
	 */
	var has = function (map, property) {
	  return hasOwnProperty.call(map, property);
	};
	
	/**
	 * Creates an map object without a prototype.
	 * @return {!Object}
	 */
	var createMap = function () {
	  return create(null);
	};
	
	/**
	 * Keeps track of information needed to perform diffs for a given DOM node.
	 * @param {!string} nodeName
	 * @param {?string=} key
	 * @constructor
	 */
	function NodeData(nodeName, key) {
	  /**
	   * The attributes and their values.
	   * @const {!Object<string, *>}
	   */
	  this.attrs = createMap();
	
	  /**
	   * An array of attribute name/value pairs, used for quickly diffing the
	   * incomming attributes to see if the DOM node's attributes need to be
	   * updated.
	   * @const {Array<*>}
	   */
	  this.attrsArr = [];
	
	  /**
	   * The incoming attributes for this Node, before they are updated.
	   * @const {!Object<string, *>}
	   */
	  this.newAttrs = createMap();
	
	  /**
	   * The key used to identify this node, used to preserve DOM nodes when they
	   * move within their parent.
	   * @const
	   */
	  this.key = key;
	
	  /**
	   * Keeps track of children within this node by their key.
	   * {?Object<string, !Element>}
	   */
	  this.keyMap = null;
	
	  /**
	   * Whether or not the keyMap is currently valid.
	   * {boolean}
	   */
	  this.keyMapValid = true;
	
	  /**
	   * The node name for this node.
	   * @const {string}
	   */
	  this.nodeName = nodeName;
	
	  /**
	   * @type {?string}
	   */
	  this.text = null;
	}
	
	/**
	 * Initializes a NodeData object for a Node.
	 *
	 * @param {Node} node The node to initialize data for.
	 * @param {string} nodeName The node name of node.
	 * @param {?string=} key The key that identifies the node.
	 * @return {!NodeData} The newly initialized data object
	 */
	var initData = function (node, nodeName, key) {
	  var data = new NodeData(nodeName, key);
	  node['__incrementalDOMData'] = data;
	  return data;
	};
	
	/**
	 * Retrieves the NodeData object for a Node, creating it if necessary.
	 *
	 * @param {Node} node The node to retrieve the data for.
	 * @return {!NodeData} The NodeData for this Node.
	 */
	var getData = function (node) {
	  var data = node['__incrementalDOMData'];
	
	  if (!data) {
	    var nodeName = node.nodeName.toLowerCase();
	    var key = null;
	
	    if (node instanceof Element) {
	      key = node.getAttribute('key');
	    }
	
	    data = initData(node, nodeName, key);
	  }
	
	  return data;
	};
	
	/**
	 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS-IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/** @const */
	var symbols = {
	  default: '__default',
	
	  placeholder: '__placeholder'
	};
	
	/**
	 * @param {string} name
	 * @return {string|undefined} The namespace to use for the attribute.
	 */
	var getNamespace = function (name) {
	  if (name.lastIndexOf('xml:', 0) === 0) {
	    return 'http://www.w3.org/XML/1998/namespace';
	  }
	
	  if (name.lastIndexOf('xlink:', 0) === 0) {
	    return 'http://www.w3.org/1999/xlink';
	  }
	};
	
	/**
	 * Applies an attribute or property to a given Element. If the value is null
	 * or undefined, it is removed from the Element. Otherwise, the value is set
	 * as an attribute.
	 * @param {!Element} el
	 * @param {string} name The attribute's name.
	 * @param {?(boolean|number|string)=} value The attribute's value.
	 */
	var applyAttr = function (el, name, value) {
	  if (value == null) {
	    el.removeAttribute(name);
	  } else {
	    var attrNS = getNamespace(name);
	    if (attrNS) {
	      el.setAttributeNS(attrNS, name, value);
	    } else {
	      el.setAttribute(name, value);
	    }
	  }
	};
	
	/**
	 * Applies a property to a given Element.
	 * @param {!Element} el
	 * @param {string} name The property's name.
	 * @param {*} value The property's value.
	 */
	var applyProp = function (el, name, value) {
	  el[name] = value;
	};
	
	/**
	 * Applies a style to an Element. No vendor prefix expansion is done for
	 * property names/values.
	 * @param {!Element} el
	 * @param {string} name The attribute's name.
	 * @param {*} style The style to set. Either a string of css or an object
	 *     containing property-value pairs.
	 */
	var applyStyle = function (el, name, style) {
	  if (typeof style === 'string') {
	    el.style.cssText = style;
	  } else {
	    el.style.cssText = '';
	    var elStyle = el.style;
	    var obj = /** @type {!Object<string,string>} */style;
	
	    for (var prop in obj) {
	      if (has(obj, prop)) {
	        elStyle[prop] = obj[prop];
	      }
	    }
	  }
	};
	
	/**
	 * Updates a single attribute on an Element.
	 * @param {!Element} el
	 * @param {string} name The attribute's name.
	 * @param {*} value The attribute's value. If the value is an object or
	 *     function it is set on the Element, otherwise, it is set as an HTML
	 *     attribute.
	 */
	var applyAttributeTyped = function (el, name, value) {
	  var type = typeof value;
	
	  if (type === 'object' || type === 'function') {
	    applyProp(el, name, value);
	  } else {
	    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
	  }
	};
	
	/**
	 * Calls the appropriate attribute mutator for this attribute.
	 * @param {!Element} el
	 * @param {string} name The attribute's name.
	 * @param {*} value The attribute's value.
	 */
	var updateAttribute = function (el, name, value) {
	  var data = getData(el);
	  var attrs = data.attrs;
	
	  if (attrs[name] === value) {
	    return;
	  }
	
	  var mutator = attributes[name] || attributes[symbols.default];
	  mutator(el, name, value);
	
	  attrs[name] = value;
	};
	
	/**
	 * A publicly mutable object to provide custom mutators for attributes.
	 * @const {!Object<string, function(!Element, string, *)>}
	 */
	var attributes = createMap();
	
	// Special generic mutator that's called for any attribute that does not
	// have a specific mutator.
	attributes[symbols.default] = applyAttributeTyped;
	
	attributes[symbols.placeholder] = function () {};
	
	attributes['style'] = applyStyle;
	
	/**
	 * Gets the namespace to create an element (of a given tag) in.
	 * @param {string} tag The tag to get the namespace for.
	 * @param {?Node} parent
	 * @return {?string} The namespace to create the tag in.
	 */
	var getNamespaceForTag = function (tag, parent) {
	  if (tag === 'svg') {
	    return 'http://www.w3.org/2000/svg';
	  }
	
	  if (getData(parent).nodeName === 'foreignObject') {
	    return null;
	  }
	
	  return parent.namespaceURI;
	};
	
	/**
	 * Creates an Element.
	 * @param {Document} doc The document with which to create the Element.
	 * @param {?Node} parent
	 * @param {string} tag The tag for the Element.
	 * @param {?string=} key A key to identify the Element.
	 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
	 *     static attributes for the Element.
	 * @return {!Element}
	 */
	var createElement = function (doc, parent, tag, key, statics) {
	  var namespace = getNamespaceForTag(tag, parent);
	  var el = undefined;
	
	  if (namespace) {
	    el = doc.createElementNS(namespace, tag);
	  } else {
	    el = doc.createElement(tag);
	  }
	
	  initData(el, tag, key);
	
	  if (statics) {
	    for (var i = 0; i < statics.length; i += 2) {
	      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);
	    }
	  }
	
	  return el;
	};
	
	/**
	 * Creates a Text Node.
	 * @param {Document} doc The document with which to create the Element.
	 * @return {!Text}
	 */
	var createText = function (doc) {
	  var node = doc.createTextNode('');
	  initData(node, '#text', null);
	  return node;
	};
	
	/**
	 * Creates a mapping that can be used to look up children using a key.
	 * @param {?Node} el
	 * @return {!Object<string, !Element>} A mapping of keys to the children of the
	 *     Element.
	 */
	var createKeyMap = function (el) {
	  var map = createMap();
	  var child = el.firstElementChild;
	
	  while (child) {
	    var key = getData(child).key;
	
	    if (key) {
	      map[key] = child;
	    }
	
	    child = child.nextElementSibling;
	  }
	
	  return map;
	};
	
	/**
	 * Retrieves the mapping of key to child node for a given Element, creating it
	 * if necessary.
	 * @param {?Node} el
	 * @return {!Object<string, !Node>} A mapping of keys to child Elements
	 */
	var getKeyMap = function (el) {
	  var data = getData(el);
	
	  if (!data.keyMap) {
	    data.keyMap = createKeyMap(el);
	  }
	
	  return data.keyMap;
	};
	
	/**
	 * Retrieves a child from the parent with the given key.
	 * @param {?Node} parent
	 * @param {?string=} key
	 * @return {?Node} The child corresponding to the key.
	 */
	var getChild = function (parent, key) {
	  return key ? getKeyMap(parent)[key] : null;
	};
	
	/**
	 * Registers an element as being a child. The parent will keep track of the
	 * child using the key. The child can be retrieved using the same key using
	 * getKeyMap. The provided key should be unique within the parent Element.
	 * @param {?Node} parent The parent of child.
	 * @param {string} key A key to identify the child with.
	 * @param {!Node} child The child to register.
	 */
	var registerChild = function (parent, key, child) {
	  getKeyMap(parent)[key] = child;
	};
	
	/**
	 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS-IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/** @const */
	var notifications = {
	  /**
	   * Called after patch has compleated with any Nodes that have been created
	   * and added to the DOM.
	   * @type {?function(Array<!Node>)}
	   */
	  nodesCreated: null,
	
	  /**
	   * Called after patch has compleated with any Nodes that have been removed
	   * from the DOM.
	   * Note it's an applications responsibility to handle any childNodes.
	   * @type {?function(Array<!Node>)}
	   */
	  nodesDeleted: null
	};
	
	/**
	 * Keeps track of the state of a patch.
	 * @constructor
	 */
	function Context() {
	  /**
	   * @type {(Array<!Node>|undefined)}
	   */
	  this.created = notifications.nodesCreated && [];
	
	  /**
	   * @type {(Array<!Node>|undefined)}
	   */
	  this.deleted = notifications.nodesDeleted && [];
	}
	
	/**
	 * @param {!Node} node
	 */
	Context.prototype.markCreated = function (node) {
	  if (this.created) {
	    this.created.push(node);
	  }
	};
	
	/**
	 * @param {!Node} node
	 */
	Context.prototype.markDeleted = function (node) {
	  if (this.deleted) {
	    this.deleted.push(node);
	  }
	};
	
	/**
	 * Notifies about nodes that were created during the patch opearation.
	 */
	Context.prototype.notifyChanges = function () {
	  if (this.created && this.created.length > 0) {
	    notifications.nodesCreated(this.created);
	  }
	
	  if (this.deleted && this.deleted.length > 0) {
	    notifications.nodesDeleted(this.deleted);
	  }
	};
	
	/**
	* Makes sure that keyed Element matches the tag name provided.
	* @param {!string} nodeName The nodeName of the node that is being matched.
	* @param {string=} tag The tag name of the Element.
	* @param {?string=} key The key of the Element.
	*/
	var assertKeyedTagMatches = function (nodeName, tag, key) {
	  if (nodeName !== tag) {
	    throw new Error('Was expecting node with key "' + key + '" to be a ' + tag + ', not a ' + nodeName + '.');
	  }
	};
	
	/** @type {?Context} */
	var context = null;
	
	/** @type {?Node} */
	var currentNode = null;
	
	/** @type {?Node} */
	var currentParent = null;
	
	/** @type {?Element|?DocumentFragment} */
	var root = null;
	
	/** @type {?Document} */
	var doc = null;
	
	/**
	 * Returns a patcher function that sets up and restores a patch context,
	 * running the run function with the provided data.
	 * @param {function((!Element|!DocumentFragment),!function(T),T=)} run
	 * @return {function((!Element|!DocumentFragment),!function(T),T=)}
	 * @template T
	 */
	var patchFactory = function (run) {
	  /**
	   * TODO(moz): These annotations won't be necessary once we switch to Closure
	   * Compiler's new type inference. Remove these once the switch is done.
	   *
	   * @param {(!Element|!DocumentFragment)} node
	   * @param {!function(T)} fn
	   * @param {T=} data
	   * @template T
	   */
	  var f = function (node, fn, data) {
	    var prevContext = context;
	    var prevRoot = root;
	    var prevDoc = doc;
	    var prevCurrentNode = currentNode;
	    var prevCurrentParent = currentParent;
	    var previousInAttributes = false;
	    var previousInSkip = false;
	
	    context = new Context();
	    root = node;
	    doc = node.ownerDocument;
	    currentParent = node.parentNode;
	
	    if (false) {}
	
	    run(node, fn, data);
	
	    if (false) {}
	
	    context.notifyChanges();
	
	    context = prevContext;
	    root = prevRoot;
	    doc = prevDoc;
	    currentNode = prevCurrentNode;
	    currentParent = prevCurrentParent;
	  };
	  return f;
	};
	
	/**
	 * Patches the document starting at node with the provided function. This
	 * function may be called during an existing patch operation.
	 * @param {!Element|!DocumentFragment} node The Element or Document
	 *     to patch.
	 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
	 *     calls that describe the DOM.
	 * @param {T=} data An argument passed to fn to represent DOM state.
	 * @template T
	 */
	var patchInner = patchFactory(function (node, fn, data) {
	  currentNode = node;
	
	  enterNode();
	  fn(data);
	  exitNode();
	
	  if (false) {}
	});
	
	/**
	 * Patches an Element with the the provided function. Exactly one top level
	 * element call should be made corresponding to `node`.
	 * @param {!Element} node The Element where the patch should start.
	 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
	 *     calls that describe the DOM. This should have at most one top level
	 *     element call.
	 * @param {T=} data An argument passed to fn to represent DOM state.
	 * @template T
	 */
	var patchOuter = patchFactory(function (node, fn, data) {
	  currentNode = /** @type {!Element} */{ nextSibling: node };
	
	  fn(data);
	
	  if (false) {}
	});
	
	/**
	 * Checks whether or not the current node matches the specified nodeName and
	 * key.
	 *
	 * @param {?string} nodeName The nodeName for this node.
	 * @param {?string=} key An optional key that identifies a node.
	 * @return {boolean} True if the node matches, false otherwise.
	 */
	var matches = function (nodeName, key) {
	  var data = getData(currentNode);
	
	  // Key check is done using double equals as we want to treat a null key the
	  // same as undefined. This should be okay as the only values allowed are
	  // strings, null and undefined so the == semantics are not too weird.
	  return nodeName === data.nodeName && key == data.key;
	};
	
	/**
	 * Aligns the virtual Element definition with the actual DOM, moving the
	 * corresponding DOM node to the correct location or creating it if necessary.
	 * @param {string} nodeName For an Element, this should be a valid tag string.
	 *     For a Text, this should be #text.
	 * @param {?string=} key The key used to identify this element.
	 * @param {?Array<*>=} statics For an Element, this should be an array of
	 *     name-value pairs.
	 */
	var alignWithDOM = function (nodeName, key, statics) {
	  if (currentNode && matches(nodeName, key)) {
	    return;
	  }
	
	  var node = undefined;
	
	  // Check to see if the node has moved within the parent.
	  if (key) {
	    node = getChild(currentParent, key);
	    if (node && 'production' !== 'production') {
	      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);
	    }
	  }
	
	  // Create the node if it doesn't exist.
	  if (!node) {
	    if (nodeName === '#text') {
	      node = createText(doc);
	    } else {
	      node = createElement(doc, currentParent, nodeName, key, statics);
	    }
	
	    if (key) {
	      registerChild(currentParent, key, node);
	    }
	
	    context.markCreated(node);
	  }
	
	  // If the node has a key, remove it from the DOM to prevent a large number
	  // of re-orders in the case that it moved far or was completely removed.
	  // Since we hold on to a reference through the keyMap, we can always add it
	  // back.
	  if (currentNode && getData(currentNode).key) {
	    currentParent.replaceChild(node, currentNode);
	    getData(currentParent).keyMapValid = false;
	  } else {
	    currentParent.insertBefore(node, currentNode);
	  }
	
	  currentNode = node;
	};
	
	/**
	 * Clears out any unvisited Nodes, as the corresponding virtual element
	 * functions were never called for them.
	 */
	var clearUnvisitedDOM = function () {
	  var node = currentParent;
	  var data = getData(node);
	  var keyMap = data.keyMap;
	  var keyMapValid = data.keyMapValid;
	  var child = node.lastChild;
	  var key = undefined;
	
	  if (child === currentNode && keyMapValid) {
	    return;
	  }
	
	  if (data.attrs[symbols.placeholder] && node !== root) {
	    if (false) {}
	    return;
	  }
	
	  while (child !== currentNode) {
	    node.removeChild(child);
	    context.markDeleted( /** @type {!Node}*/child);
	
	    key = getData(child).key;
	    if (key) {
	      delete keyMap[key];
	    }
	    child = node.lastChild;
	  }
	
	  // Clean the keyMap, removing any unusued keys.
	  if (!keyMapValid) {
	    for (key in keyMap) {
	      child = keyMap[key];
	      if (child.parentNode !== node) {
	        context.markDeleted(child);
	        delete keyMap[key];
	      }
	    }
	
	    data.keyMapValid = true;
	  }
	};
	
	/**
	 * Changes to the first child of the current node.
	 */
	var enterNode = function () {
	  currentParent = currentNode;
	  currentNode = null;
	};
	
	/**
	 * Changes to the next sibling of the current node.
	 */
	var nextNode = function () {
	  if (currentNode) {
	    currentNode = currentNode.nextSibling;
	  } else {
	    currentNode = currentParent.firstChild;
	  }
	};
	
	/**
	 * Changes to the parent of the current node, removing any unvisited children.
	 */
	var exitNode = function () {
	  clearUnvisitedDOM();
	
	  currentNode = currentParent;
	  currentParent = currentParent.parentNode;
	};
	
	/**
	 * Makes sure that the current node is an Element with a matching tagName and
	 * key.
	 *
	 * @param {string} tag The element's tag.
	 * @param {?string=} key The key used to identify this element. This can be an
	 *     empty string, but performance may be better if a unique value is used
	 *     when iterating over an array of items.
	 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
	 *     static attributes for the Element. These will only be set once when the
	 *     Element is created.
	 * @return {!Element} The corresponding Element.
	 */
	var coreElementOpen = function (tag, key, statics) {
	  nextNode();
	  alignWithDOM(tag, key, statics);
	  enterNode();
	  return (/** @type {!Element} */currentParent
	  );
	};
	
	/**
	 * Closes the currently open Element, removing any unvisited children if
	 * necessary.
	 *
	 * @return {!Element} The corresponding Element.
	 */
	var coreElementClose = function () {
	  if (false) {}
	
	  exitNode();
	  return (/** @type {!Element} */currentNode
	  );
	};
	
	/**
	 * Makes sure the current node is a Text node and creates a Text node if it is
	 * not.
	 *
	 * @return {!Text} The corresponding Text Node.
	 */
	var coreText = function () {
	  nextNode();
	  alignWithDOM('#text', null, null);
	  return (/** @type {!Text} */currentNode
	  );
	};
	
	/**
	 * Gets the current Element being patched.
	 * @return {!Element}
	 */
	var currentElement = function () {
	  if (false) {}
	  return (/** @type {!Element} */currentParent
	  );
	};
	
	/**
	 * Skips the children in a subtree, allowing an Element to be closed without
	 * clearing out the children.
	 */
	var skip = function () {
	  if (false) {}
	  currentNode = currentParent.lastChild;
	};
	
	/**
	 * The offset in the virtual element declaration where the attributes are
	 * specified.
	 * @const
	 */
	var ATTRIBUTES_OFFSET = 3;
	
	/**
	 * Builds an array of arguments for use with elementOpenStart, attr and
	 * elementOpenEnd.
	 * @const {Array<*>}
	 */
	var argsBuilder = [];
	
	/**
	 * @param {string} tag The element's tag.
	 * @param {?string=} key The key used to identify this element. This can be an
	 *     empty string, but performance may be better if a unique value is used
	 *     when iterating over an array of items.
	 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
	 *     static attributes for the Element. These will only be set once when the
	 *     Element is created.
	 * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
	 *     for the Element.
	 * @return {!Element} The corresponding Element.
	 */
	var elementOpen = function (tag, key, statics, const_args) {
	  if (false) {}
	
	  var node = coreElementOpen(tag, key, statics);
	  var data = getData(node);
	
	  /*
	   * Checks to see if one or more attributes have changed for a given Element.
	   * When no attributes have changed, this is much faster than checking each
	   * individual argument. When attributes have changed, the overhead of this is
	   * minimal.
	   */
	  var attrsArr = data.attrsArr;
	  var newAttrs = data.newAttrs;
	  var attrsChanged = false;
	  var i = ATTRIBUTES_OFFSET;
	  var j = 0;
	
	  for (; i < arguments.length; i += 1, j += 1) {
	    if (attrsArr[j] !== arguments[i]) {
	      attrsChanged = true;
	      break;
	    }
	  }
	
	  for (; i < arguments.length; i += 1, j += 1) {
	    attrsArr[j] = arguments[i];
	  }
	
	  if (j < attrsArr.length) {
	    attrsChanged = true;
	    attrsArr.length = j;
	  }
	
	  /*
	   * Actually perform the attribute update.
	   */
	  if (attrsChanged) {
	    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {
	      newAttrs[arguments[i]] = arguments[i + 1];
	    }
	
	    for (var _attr in newAttrs) {
	      updateAttribute(node, _attr, newAttrs[_attr]);
	      newAttrs[_attr] = undefined;
	    }
	  }
	
	  return node;
	};
	
	/**
	 * Declares a virtual Element at the current location in the document. This
	 * corresponds to an opening tag and a elementClose tag is required. This is
	 * like elementOpen, but the attributes are defined using the attr function
	 * rather than being passed as arguments. Must be folllowed by 0 or more calls
	 * to attr, then a call to elementOpenEnd.
	 * @param {string} tag The element's tag.
	 * @param {?string=} key The key used to identify this element. This can be an
	 *     empty string, but performance may be better if a unique value is used
	 *     when iterating over an array of items.
	 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
	 *     static attributes for the Element. These will only be set once when the
	 *     Element is created.
	 */
	var elementOpenStart = function (tag, key, statics) {
	  if (false) {}
	
	  argsBuilder[0] = tag;
	  argsBuilder[1] = key;
	  argsBuilder[2] = statics;
	};
	
	/***
	 * Defines a virtual attribute at this point of the DOM. This is only valid
	 * when called between elementOpenStart and elementOpenEnd.
	 *
	 * @param {string} name
	 * @param {*} value
	 */
	var attr = function (name, value) {
	  if (false) {}
	
	  argsBuilder.push(name, value);
	};
	
	/**
	 * Closes an open tag started with elementOpenStart.
	 * @return {!Element} The corresponding Element.
	 */
	var elementOpenEnd = function () {
	  if (false) {}
	
	  var node = elementOpen.apply(null, argsBuilder);
	  argsBuilder.length = 0;
	  return node;
	};
	
	/**
	 * Closes an open virtual Element.
	 *
	 * @param {string} tag The element's tag.
	 * @return {!Element} The corresponding Element.
	 */
	var elementClose = function (tag) {
	  if (false) {}
	
	  var node = coreElementClose();
	
	  if (false) {}
	
	  return node;
	};
	
	/**
	 * Declares a virtual Element at the current location in the document that has
	 * no children.
	 * @param {string} tag The element's tag.
	 * @param {?string=} key The key used to identify this element. This can be an
	 *     empty string, but performance may be better if a unique value is used
	 *     when iterating over an array of items.
	 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
	 *     static attributes for the Element. These will only be set once when the
	 *     Element is created.
	 * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
	 *     for the Element.
	 * @return {!Element} The corresponding Element.
	 */
	var elementVoid = function (tag, key, statics, const_args) {
	  elementOpen.apply(null, arguments);
	  return elementClose(tag);
	};
	
	/**
	 * Declares a virtual Element at the current location in the document that is a
	 * placeholder element. Children of this Element can be manually managed and
	 * will not be cleared by the library.
	 *
	 * A key must be specified to make sure that this node is correctly preserved
	 * across all conditionals.
	 *
	 * @param {string} tag The element's tag.
	 * @param {string} key The key used to identify this element.
	 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
	 *     static attributes for the Element. These will only be set once when the
	 *     Element is created.
	 * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
	 *     for the Element.
	 * @return {!Element} The corresponding Element.
	 */
	var elementPlaceholder = function (tag, key, statics, const_args) {
	  if (false) {}
	
	  elementOpen.apply(null, arguments);
	  skip();
	  return elementClose(tag);
	};
	
	/**
	 * Declares a virtual Text at this point in the document.
	 *
	 * @param {string|number|boolean} value The value of the Text.
	 * @param {...(function((string|number|boolean)):string)} const_args
	 *     Functions to format the value which are called only when the value has
	 *     changed.
	 * @return {!Text} The corresponding text node.
	 */
	var text = function (value, const_args) {
	  if (false) {}
	
	  var node = coreText();
	  var data = getData(node);
	
	  if (data.text !== value) {
	    data.text = /** @type {string} */value;
	
	    var formatted = value;
	    for (var i = 1; i < arguments.length; i += 1) {
	      /*
	       * Call the formatter function directly to prevent leaking arguments.
	       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
	       */
	      var fn = arguments[i];
	      formatted = fn(formatted);
	    }
	
	    node.data = formatted;
	  }
	
	  return node;
	};
	
	exports.patch = patchInner;
	exports.patchInner = patchInner;
	exports.patchOuter = patchOuter;
	exports.currentElement = currentElement;
	exports.skip = skip;
	exports.elementVoid = elementVoid;
	exports.elementOpenStart = elementOpenStart;
	exports.elementOpenEnd = elementOpenEnd;
	exports.elementOpen = elementOpen;
	exports.elementClose = elementClose;
	exports.elementPlaceholder = elementPlaceholder;
	exports.text = text;
	exports.attr = attr;
	exports.symbols = symbols;
	exports.attributes = attributes;
	exports.applyAttr = applyAttr;
	exports.applyProp = applyProp;
	exports.notifications = notifications;
	
	//# sourceMappingURL=incremental-dom-cjs.js.map

/***/ },
/* 5 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	module.exports = (typeof self === 'object' && self.self === self && self) ||
	  (typeof global === 'object' && global.global === global && global) ||
	  this
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Item = exports.CodeExample = exports.Layout = exports.Link = exports.Css = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _skatejs = __webpack_require__(3);
	
	var _glamor = __webpack_require__(7);
	
	var _page = __webpack_require__(15);
	
	var _page2 = _interopRequireDefault(_page);
	
	var _prism = __webpack_require__(18);
	
	var _prism2 = _interopRequireDefault(_prism);
	
	var _prismjs = __webpack_require__(20);
	
	var _prismjs2 = _interopRequireDefault(_prismjs);
	
	var _tabs = __webpack_require__(21);
	
	var _tabs2 = _interopRequireDefault(_tabs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function followHref(e) {
	  if (e.currentTarget.rel !== 'external') {
	    (0, _page2.default)(e.target.pathname || '/');
	    e.preventDefault();
	  }
	}
	
	var Css = exports.Css = function Css(props) {
	  return (0, _skatejs.h)(
	    'style',
	    null,
	    props.for.length ? _glamor.cssFor.apply(undefined, _toConsumableArray(props.for)) : (0, _glamor.cssFor)(props.for)
	  );
	};
	var Link = exports.Link = function Link(props, chren) {
	  return (0, _skatejs.h)(
	    'a',
	    _extends({}, props, { onclick: followHref }),
	    chren
	  );
	};
	var Layout = exports.Layout = function Layout(props, chren) {
	  return (0, _skatejs.h)(
	    'div',
	    { style: 'padding: 20px' },
	    chren
	  );
	};
	
	function format(code) {
	  var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'markup';
	
	  var lines = code.split('\n');
	  var ident = (lines[1] || '').match(/^\s*/)[0].length;
	  var formatted = lines.map(function (line) {
	    return line.substring(ident);
	  }).join('\n').trim();
	  var highlighted = _prismjs2.default.highlight(formatted, _prismjs2.default.languages[lang]);
	  return highlighted;
	}
	
	var codeCss = (0, _glamor.style)({
	  backgroundColor: '#F1EDE4'
	});
	var codeTitleCss = (0, _glamor.style)({
	  backgroundColor: '#DAD6CE',
	  fontSize: 24,
	  fontWeight: 200,
	  margin: 0,
	  padding: 20
	});
	var codeDescriptionCss = (0, _glamor.style)({
	  backgroundColor: '#DAD6CE',
	  fontSize: 14,
	  fontWeight: 100,
	  margin: 0,
	  padding: 20
	});
	
	var CodeExample = exports.CodeExample = function CodeExample(props, chren) {
	  return (0, _skatejs.h)(
	    'div',
	    codeCss,
	    (0, _skatejs.h)(
	      'style',
	      null,
	      _prism2.default.toString()
	    ),
	    (0, _skatejs.h)(Css, { 'for': [codeCss, codeTitleCss, codeDescriptionCss] }),
	    props.title ? (0, _skatejs.h)(
	      'h3',
	      codeTitleCss,
	      props.title
	    ) : '',
	    props.description ? (0, _skatejs.h)(
	      'h3',
	      codeDescriptionCss,
	      props.description
	    ) : '',
	    (0, _skatejs.h)(
	      _tabs2.default,
	      null,
	      (0, _skatejs.h)(
	        _tabs.Tab,
	        { name: 'Result', selected: true },
	        (0, _skatejs.h)(
	          'p',
	          null,
	          chren
	        )
	      ),
	      (0, _skatejs.h)(
	        _tabs.Tab,
	        { name: 'JS' },
	        (0, _skatejs.h)(
	          'pre',
	          null,
	          (0, _skatejs.h)('code', { ref: function ref(e) {
	              return e.innerHTML = format(props.js, 'javascript');
	            } })
	        )
	      ),
	      (0, _skatejs.h)(
	        _tabs.Tab,
	        { name: 'HTML' },
	        (0, _skatejs.h)(
	          'pre',
	          null,
	          (0, _skatejs.h)('code', { ref: function ref(e) {
	              return e.innerHTML = format(props.html, 'markup');
	            } })
	        )
	      )
	    )
	  );
	};
	
	var itemCss = (0, _glamor.style)({
	  display: 'inline-block',
	  margin: 0,
	  padding: 0
	});
	
	var itemLinkCss = (0, _glamor.style)({
	  color: '#333',
	  display: 'inline-block',
	  fontSize: 18,
	  margin: 0,
	  padding: 20,
	  textDecoration: 'none',
	  transition: 'background-color .3s ease'
	});
	
	var itemLinkHover = (0, _glamor.hover)({
	  backgroundColor: '#eee'
	});
	
	var Item = exports.Item = function Item(props, chren) {
	  return (0, _skatejs.h)(
	    'li',
	    itemCss,
	    (0, _skatejs.h)(Css, { 'for': [itemCss, itemLinkCss, itemLinkHover] }),
	    props.external ? (0, _skatejs.h)(
	      'a',
	      _extends({}, props, itemLinkCss, itemLinkHover),
	      chren
	    ) : (0, _skatejs.h)(
	      Link,
	      _extends({}, props, itemLinkCss, itemLinkHover),
	      chren
	    )
	  );
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.presets = exports.compose = exports.$ = exports.plugins = exports.styleSheet = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.speedy = speedy;
	exports.simulations = simulations;
	exports.simulate = simulate;
	exports.cssLabels = cssLabels;
	exports.isLikeRule = isLikeRule;
	exports.idFor = idFor;
	exports.insertRule = insertRule;
	exports.insertGlobal = insertGlobal;
	exports.rehydrate = rehydrate;
	exports.flush = flush;
	exports.style = style;
	exports.select = select;
	exports.parent = parent;
	exports.merge = merge;
	exports.media = media;
	exports.trackMediaQueryLabels = trackMediaQueryLabels;
	exports.pseudo = pseudo;
	exports.active = active;
	exports.any = any;
	exports.checked = checked;
	exports.disabled = disabled;
	exports.empty = empty;
	exports.enabled = enabled;
	exports._default = _default;
	exports.first = first;
	exports.firstChild = firstChild;
	exports.firstOfType = firstOfType;
	exports.fullscreen = fullscreen;
	exports.focus = focus;
	exports.hover = hover;
	exports.indeterminate = indeterminate;
	exports.inRange = inRange;
	exports.invalid = invalid;
	exports.lastChild = lastChild;
	exports.lastOfType = lastOfType;
	exports.left = left;
	exports.link = link;
	exports.onlyChild = onlyChild;
	exports.onlyOfType = onlyOfType;
	exports.optional = optional;
	exports.outOfRange = outOfRange;
	exports.readOnly = readOnly;
	exports.readWrite = readWrite;
	exports.required = required;
	exports.right = right;
	exports.root = root;
	exports.scope = scope;
	exports.target = target;
	exports.valid = valid;
	exports.visited = visited;
	exports.dir = dir;
	exports.lang = lang;
	exports.not = not;
	exports.nthChild = nthChild;
	exports.nthLastChild = nthLastChild;
	exports.nthLastOfType = nthLastOfType;
	exports.nthOfType = nthOfType;
	exports.after = after;
	exports.before = before;
	exports.firstLetter = firstLetter;
	exports.firstLine = firstLine;
	exports.selection = selection;
	exports.backdrop = backdrop;
	exports.placeholder = placeholder;
	exports.keyframes = keyframes;
	exports.fontFace = fontFace;
	exports.cssFor = cssFor;
	exports.attribsFor = attribsFor;
	
	var _sheet = __webpack_require__(9);
	
	var _CSSPropertyOperations = __webpack_require__(10);
	
	var _clean = __webpack_require__(11);
	
	var _clean2 = _interopRequireDefault(_clean);
	
	var _plugins = __webpack_require__(12);
	
	var _hash = __webpack_require__(14);
	
	var _hash2 = _interopRequireDefault(_hash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**** stylesheet  ****/
	
	var styleSheet = exports.styleSheet = new _sheet.StyleSheet();
	// an isomorphic StyleSheet shim. hides all the nitty gritty. 
	
	// /**************** LIFTOFF IN 3... 2... 1... ****************/
	styleSheet.inject(); //eslint-disable-line indent
	// /****************      TO THE MOOOOOOON     ****************/
	
	// convenience function to toggle speedy
	function speedy(bool) {
	  return styleSheet.speedy(bool);
	}
	
	// plugins 
	// we include these by default 
	var plugins = exports.plugins = styleSheet.plugins = new _plugins.PluginSet(_plugins.fallbacks, _plugins.bug20fix, _plugins.prefixes);
	plugins.media = new _plugins.PluginSet(); // neat! media, font-face, keyframes
	plugins.fontFace = new _plugins.PluginSet();
	plugins.keyframes = new _plugins.PluginSet(_plugins.prefixes);
	
	// define some constants 
	var isBrowser = typeof window !== 'undefined';
	var isDev = function (x) {
	  return x === 'development' || !x;
	}(process.env.NODE_ENV);
	var isTest = process.env.NODE_ENV === 'test';
	
	/**** simulations  ****/
	
	// a flag to enable simulation meta tags on dom nodes 
	// defaults to true in dev mode. recommend *not* to 
	// toggle often. 
	var canSimulate = isDev;
	
	// we use these flags for issuing warnings when simulate is called 
	// in prod / in incorrect order 
	var warned1 = false,
	    warned2 = false;
	
	// toggles simulation activity. shouldn't be needed in most cases 
	function simulations() {
	  var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	
	  canSimulate = !!bool;
	}
	
	// use this on dom nodes to 'simulate' pseudoclasses
	// <div {...hover({ color: 'red' })} {...simulate('hover', 'visited')}>...</div>
	// you can even send in some weird ones, as long as it's in simple format 
	// and matches an existing rule on the element 
	// eg simulate('nthChild2', ':hover:active') etc 
	function simulate() {
	  for (var _len = arguments.length, pseudos = Array(_len), _key = 0; _key < _len; _key++) {
	    pseudos[_key] = arguments[_key];
	  }
	
	  pseudos = (0, _clean2.default)(pseudos);
	  if (!pseudos) return {};
	  if (!canSimulate) {
	    if (!warned1) {
	      console.warn('can\'t simulate without once calling simulations(true)'); //eslint-disable-line no-console
	      warned1 = true;
	    }
	    if (!isDev && !isTest && !warned2) {
	      console.warn('don\'t use simulation outside dev'); //eslint-disable-line no-console
	      warned2 = true;
	    }
	    return {};
	  }
	  return pseudos.reduce(function (o, p) {
	    return o['data-simulate-' + simple(p)] = '', o;
	  }, {});
	}
	
	/**** labels ****/
	// toggle for debug labels. 
	// *shouldn't* have to mess with this manually
	var hasLabels = isDev;
	
	function cssLabels(bool) {
	  hasLabels = !!bool;
	}
	
	// takes a string, converts to lowercase, strips out nonalphanumeric.
	function simple(str) {
	  return str.toLowerCase().replace(/[^a-z0-9]/g, '');
	}
	
	// flatten a nested array 
	function flatten(inArr) {
	  var arr = [];
	  for (var i = 0; i < inArr.length; i++) {
	    if (Array.isArray(inArr[i])) arr = arr.concat(flatten(inArr[i]));else arr = arr.concat(inArr[i]);
	  }
	  return arr;
	}
	
	// hashes a string to something 'unique'
	// we use this to generate ids for styles
	
	
	function hashify() {
	  for (var _len2 = arguments.length, objs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    objs[_key2] = arguments[_key2];
	  }
	
	  return (0, _hash2.default)(objs.map(function (x) {
	    return JSON.stringify(x);
	  }).join('')).toString(36);
	}
	
	// of shape { 'data-css-<id>': ''}
	function isLikeRule(rule) {
	  var keys = Object.keys(rule).filter(function (x) {
	    return x !== 'toString';
	  });
	  if (keys.length !== 1) {
	    return false;
	  }
	  return !!/data\-css\-([a-zA-Z0-9]+)/.exec(keys[0]);
	}
	
	// extracts id from a { 'data-css-<id>': ''} like object 
	function idFor(rule) {
	  var keys = Object.keys(rule).filter(function (x) {
	    return x !== 'toString';
	  });
	  if (keys.length !== 1) throw new Error('not a rule');
	  var regex = /data\-css\-([a-zA-Z0-9]+)/;
	  var match = regex.exec(keys[0]);
	  if (!match) throw new Error('not a rule');
	  return match[1];
	}
	
	// a simple cache to store generated rules 
	var registered = {};
	function register(spec) {
	  if (!registered[spec.id]) {
	    registered[spec.id] = spec;
	  }
	}
	
	// semi-deeply merge 2 'mega' style objects 
	function deepMergeStyles(dest, src) {
	  Object.keys(src).forEach(function (expr) {
	    dest[expr] = dest[expr] || {};
	    Object.keys(src[expr]).forEach(function (type) {
	      dest[expr][type] = dest[expr][type] || {};
	      Object.assign(dest[expr][type], src[expr][type]);
	    });
	  });
	}
	
	//todo - prevent nested media queries
	function deconstruct(obj) {
	  var ret = [];
	  var plain = {},
	      hasPlain = false;
	  var hasPseudos = obj && find(Object.keys(obj), function (x) {
	    return x.charAt(0) === ':';
	  });
	  var hasMedias = obj && find(Object.keys(obj), function (x) {
	    return x.charAt(0) === '@';
	  }); // todo - check @media
	
	  if (hasPseudos || hasMedias) {
	
	    Object.keys(obj).forEach(function (key) {
	      if (key.charAt(0) === ':') {
	        ret.push({
	          type: 'pseudo',
	          style: obj[key],
	          selector: key
	        });
	      } else if (key.charAt(0) === '@') {
	        ret.push({
	          type: 'media',
	          rules: deconstruct(obj[key]),
	          expr: key.substring(6)
	        });
	      } else {
	        hasPlain = true;
	        plain[key] = obj[key];
	      }
	    });
	    return hasPlain ? [plain].concat(ret) : ret;
	  }
	  return obj;
	}
	
	// extracts and composes styles from a rule into a 'mega' style
	// with sub styles keyed by media query + 'path'
	function extractStyles() {
	  for (var _len3 = arguments.length, rules = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    rules[_key3] = arguments[_key3];
	  }
	
	  rules = flatten(rules);
	  var exprs = {};
	  // converts {[data-css-<id>]} to the backing rule 
	  rules = rules.map(function (x) {
	    return x.type === 'style' || !x.type ? deconstruct(x.style || x) : x;
	  });
	  rules = flatten(rules);
	  rules.forEach(function (rule) {
	    // avoid possible label. todo - cleaner 
	    if (typeof rule === 'string') {
	      return;
	    }
	    if (isLikeRule(rule)) {
	      rule = registered[idFor(rule)];
	    }
	    switch (rule.type) {
	      case 'raw':
	      case 'font-face':
	      case 'keyframes':
	        throw new Error('not implemented');
	
	      case 'merge':
	        return deepMergeStyles(exprs, extractStyles(rule.rules));
	
	      case 'pseudo':
	        if (rule.selector === ':hover' && exprs._ && exprs._['%%%:active'] && !exprs._['%%%:hover']) {
	          console.warn(':active must come after :hover to work correctly'); //eslint-disable-line no-console
	        }
	        return deepMergeStyles(exprs, { _: _defineProperty({}, '%%%' + rule.selector, rule.style) });
	      case 'select':
	        return deepMergeStyles(exprs, { _: _defineProperty({}, '^^^' + rule.selector, rule.style) });
	      case 'parent':
	        return deepMergeStyles(exprs, { _: _defineProperty({}, '***' + rule.selector, rule.style) });
	
	      case 'style':
	        return deepMergeStyles(exprs, { _: { _: rule.style } });
	
	      case 'media':
	        return deepMergeStyles(exprs, _defineProperty({}, rule.expr, extractStyles(rule.rules)._));
	
	      default:
	        return deepMergeStyles(exprs, { _: { _: rule } });
	    }
	  });
	  return exprs;
	}
	
	// extract label from a rule / style 
	function extractLabel(rule) {
	  if (isLikeRule(rule)) {
	    rule = registered[idFor(rule)];
	  }
	  return rule.label || '{:}';
	}
	
	// given an id / 'path', generate a css selector 
	function selector(id, path) {
	  if (path === '_') return '.css-' + id + ',[data-css-' + id + ']';
	
	  if (path.indexOf('%%%') === 0) {
	    var x = '.css-' + id + path.slice(3) + ',[data-css-' + id + ']' + path.slice(3);
	    if (canSimulate) x += ',[data-css-' + id + '][data-simulate-' + simple(path) + '],.css-' + id + '[data-simulate-' + simple(path) + ']';
	    return x;
	  }
	
	  if (path.indexOf('***') === 0) {
	    return path.slice(3).split(',').map(function (x) {
	      return x + ' .css-' + id + ',' + x + ' [data-css-' + id + ']';
	    }).join(',');
	  }
	  if (path.indexOf('^^^') === 0) {
	    return path.slice(3).split(',').map(function (x) {
	      return '.css-' + id + x + ',[data-css-' + id + ']' + x;
	    }).join(',');
	  }
	}
	
	function toCSS(_ref4) {
	  var selector = _ref4.selector;
	  var style = _ref4.style;
	
	  var result = plugins.transform({ selector: selector, style: style });
	  return result.selector + '{' + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + '}';
	}
	
	function ruleToAst(rule) {
	  var styles = extractStyles(rule);
	  return Object.keys(styles).reduce(function (o, expr) {
	    o[expr] = Object.keys(styles[expr]).map(function (s) {
	      return { selector: selector(rule.id, s), style: styles[expr][s] };
	    });
	    return o;
	  }, {});
	}
	
	function ruleToCSS(spec) {
	  var css = [];
	  var ast = ruleToAst(spec);
	  // plugins here 
	  var _ = ast._;
	
	  var exprs = _objectWithoutProperties(ast, ['_']);
	
	  if (_) {
	    _.map(toCSS).forEach(function (str) {
	      return css.push(str);
	    });
	  }
	  Object.keys(exprs).forEach(function (expr) {
	    css.push('@media ' + expr + '{' + exprs[expr].map(toCSS).join('') + '}');
	  });
	  return css;
	}
	
	// this cache to track which rules have 
	// been inserted into the stylesheet
	var inserted = styleSheet.inserted = {};
	
	// and helpers to insert rules into said styleSheet
	function insert(spec) {
	  if (!inserted[spec.id]) {
	    inserted[spec.id] = true;
	    ruleToCSS(spec).map(function (cssRule) {
	      return styleSheet.insert(cssRule);
	    });
	  }
	}
	
	function insertRule(css) {
	  var spec = {
	    id: hashify(css),
	    css: css,
	    type: 'raw',
	    label: '^'
	  };
	  register(spec);
	  if (!inserted[spec.id]) {
	    styleSheet.insert(spec.css);
	    inserted[spec.id] = true;
	  }
	}
	
	function insertGlobal(selector, style) {
	  return insertRule(selector + '{' + (0, _CSSPropertyOperations.createMarkupForStyles)(style) + '}');
	}
	
	function insertKeyframe(spec) {
	  if (!inserted[spec.id]) {
	    (function () {
	      var inner = Object.keys(spec.keyframes).map(function (kf) {
	        var result = plugins.keyframes.transform({ id: spec.id, name: kf, style: spec.keyframes[kf] });
	        return result.name + '{' + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + '}';
	      }).join('');
	
	      ['-webkit-', '-moz-', '-o-', ''].forEach(function (prefix) {
	        return styleSheet.insert('@' + prefix + 'keyframes ' + (spec.name + '_' + spec.id) + '{' + inner + '}');
	      });
	
	      inserted[spec.id] = true;
	    })();
	  }
	}
	
	function insertFontFace(spec) {
	  if (!inserted[spec.id]) {
	    styleSheet.insert('@font-face{' + (0, _CSSPropertyOperations.createMarkupForStyles)(spec.font) + '}');
	    inserted[spec.id] = true;
	  }
	}
	
	// rehydrate the insertion cache with ids sent from 
	// renderStatic / renderStaticOptimized 
	function rehydrate(ids) {
	  // load up ids
	  Object.assign(inserted, ids.reduce(function (o, i) {
	    return o[i] = true, o;
	  }, {}));
	  // assume css loaded separately
	}
	
	// todo - perf
	var ruleCache = {};
	function toRule(spec) {
	  register(spec);
	  insert(spec);
	  if (ruleCache[spec.id]) {
	    return ruleCache[spec.id];
	  }
	
	  var ret = _defineProperty({}, 'data-css-' + spec.id, hasLabels ? spec.label || '' : '');
	  Object.defineProperty(ret, 'toString', {
	    enumerable: false, value: function value() {
	      return 'css-' + spec.id;
	    }
	  });
	  ruleCache[spec.id] = ret;
	  return ret;
	}
	
	// clears out the cache and empties the stylesheet
	// best for tests, though there might be some value for SSR. 
	
	function flush() {
	  inserted = styleSheet.inserted = {};
	  registered = {};
	  ruleCache = {};
	  styleSheet.flush();
	  styleSheet.inject();
	}
	
	function find(arr, fn) {
	  for (var i = 0; i < arr.length; i++) {
	    if (fn(arr[i]) === true) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function style(obj) {
	  obj = (0, _clean2.default)(obj);
	
	  return obj ? toRule({
	    id: hashify(obj),
	    type: 'style',
	    style: obj,
	    label: obj.label || '*'
	  }) : {};
	}
	
	// unique feature 
	// when you need to define 'real' css (whatever that may be)
	// https://twitter.com/threepointone/status/756585907877273600
	// https://twitter.com/threepointone/status/756986938033254400
	function select(selector, obj) {
	  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
	    return style(selector);
	  }
	  obj = (0, _clean2.default)(obj);
	
	  return obj ? toRule({
	    id: hashify(selector, obj),
	    type: 'select',
	    selector: selector,
	    style: obj,
	    label: obj.label || '*'
	  }) : {};
	}
	
	var $ = exports.$ = select; // bringin' jquery back
	
	function parent(selector, obj) {
	  obj = (0, _clean2.default)(obj);
	  return obj ? toRule({
	    id: hashify(selector, obj),
	    type: 'parent',
	    selector: selector,
	    style: obj,
	    label: obj.label || '*'
	  }) : {};
	}
	
	// we define a function to 'merge' styles together.
	// backstory - because of a browser quirk, multiple styles are applied in the order they're 
	// defined in the stylesheet, not in the order of application 
	// in most cases, this won't case an issue UNTIL IT DOES 
	// instead, use merge() to merge styles,
	// with latter styles gaining precedence over former ones 
	
	function merge() {
	  for (var _len4 = arguments.length, rules = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	    rules[_key4] = arguments[_key4];
	  }
	
	  rules = (0, _clean2.default)(rules);
	  return rules ? toRule({
	    id: hashify(extractStyles(rules)),
	    type: 'merge',
	    rules: rules,
	    label: '[' + (typeof rules[0] === 'string' ? rules[0] : rules.map(extractLabel).join(' + ')) + ']'
	  }) : {};
	}
	
	var compose = exports.compose = merge;
	
	function media(expr) {
	  for (var _len5 = arguments.length, rules = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	    rules[_key5 - 1] = arguments[_key5];
	  }
	
	  rules = (0, _clean2.default)(rules);
	  return rules ? toRule({
	    id: hashify(expr, extractStyles(rules)),
	    type: 'media',
	    rules: rules,
	    expr: expr,
	    label: '*mq(' + rules.map(extractLabel).join(' + ') + ')'
	  }) : {};
	}
	
	var presets = exports.presets = {
	  mobile: '(min-width: 400px)',
	  phablet: '(min-width: 550px)',
	  tablet: '(min-width: 750px)',
	  desktop: '(min-width: 1000px)',
	  hd: '(min-width: 1200px)'
	};
	
	/**** live media query labels ****/
	
	// simplest implementation -
	// cycle through the cache, and for every media query
	// find matching elements and update the label 
	function updateMediaQueryLabels() {
	  Object.keys(registered).forEach(function (id) {
	    var expr = registered[id].expr;
	
	    if (expr && hasLabels && window.matchMedia) {
	      (function () {
	        var els = document.querySelectorAll('[data-css-' + id + ']');
	        var match = window.matchMedia(expr).matches ? '✓' : '✕';
	        var regex = /^(✓|✕|\*)mq/;
	        [].concat(_toConsumableArray(els)).forEach(function (el) {
	          return el.setAttribute('data-css-' + id, el.getAttribute('data-css-' + id).replace(regex, match + 'mq'));
	        });
	      })();
	    }
	  });
	}
	
	// saves a reference to the loop we trigger 
	var interval = void 0;
	
	function trackMediaQueryLabels() {
	  var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	  var period = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
	
	  if (bool) {
	    if (interval) {
	      console.warn('already tracking labels, call trackMediaQueryLabels(false) to stop'); // eslint-disable-line no-console 
	      return;
	    }
	    interval = setInterval(function () {
	      return updateMediaQueryLabels();
	    }, period);
	  } else {
	    clearInterval(interval);
	    interval = null;
	  }
	}
	
	// in dev mode, start this up immediately 
	if (isDev && isBrowser) {
	  trackMediaQueryLabels(true);
	  // todo - make sure hot loading isn't broken
	  // todo - clearInterval on browser close  
	}
	
	function pseudo(selector, obj) {
	  obj = (0, _clean2.default)(obj);
	  return obj ? toRule({
	    id: hashify(selector, obj),
	    type: 'pseudo',
	    selector: selector,
	    style: obj,
	    label: obj.label || ':*'
	  }) : {};
	}
	
	// allllll the pseudoclasses
	
	function active(x) {
	  return pseudo(':active', x);
	}
	
	function any(x) {
	  return pseudo(':any', x);
	}
	
	function checked(x) {
	  return pseudo(':checked', x);
	}
	
	function disabled(x) {
	  return pseudo(':disabled', x);
	}
	
	function empty(x) {
	  return pseudo(':empty', x);
	}
	
	function enabled(x) {
	  return pseudo(':enabled', x);
	}
	
	function _default(x) {
	  return pseudo(':default', x); // note '_default' name  
	}
	
	function first(x) {
	  return pseudo(':first', x);
	}
	
	function firstChild(x) {
	  return pseudo(':first-child', x);
	}
	
	function firstOfType(x) {
	  return pseudo(':first-of-type', x);
	}
	
	function fullscreen(x) {
	  return pseudo(':fullscreen', x);
	}
	
	function focus(x) {
	  return pseudo(':focus', x);
	}
	
	function hover(x) {
	  return pseudo(':hover', x);
	}
	
	function indeterminate(x) {
	  return pseudo(':indeterminate', x);
	}
	
	function inRange(x) {
	  return pseudo(':in-range', x);
	}
	
	function invalid(x) {
	  return pseudo(':invalid', x);
	}
	
	function lastChild(x) {
	  return pseudo(':last-child', x);
	}
	
	function lastOfType(x) {
	  return pseudo(':last-of-type', x);
	}
	
	function left(x) {
	  return pseudo(':left', x);
	}
	
	function link(x) {
	  return pseudo(':link', x);
	}
	
	function onlyChild(x) {
	  return pseudo(':only-child', x);
	}
	
	function onlyOfType(x) {
	  return pseudo(':only-of-type', x);
	}
	
	function optional(x) {
	  return pseudo(':optional', x);
	}
	
	function outOfRange(x) {
	  return pseudo(':out-of-range', x);
	}
	
	function readOnly(x) {
	  return pseudo(':read-only', x);
	}
	
	function readWrite(x) {
	  return pseudo(':read-write', x);
	}
	
	function required(x) {
	  return pseudo(':required', x);
	}
	
	function right(x) {
	  return pseudo(':right', x);
	}
	
	function root(x) {
	  return pseudo(':root', x);
	}
	
	function scope(x) {
	  return pseudo(':scope', x);
	}
	
	function target(x) {
	  return pseudo(':target', x);
	}
	
	function valid(x) {
	  return pseudo(':valid', x);
	}
	
	function visited(x) {
	  return pseudo(':visited', x);
	}
	
	// parameterized pseudoclasses
	function dir(p, x) {
	  return pseudo(':dir(' + p + ')', x);
	}
	function lang(p, x) {
	  return pseudo(':lang(' + p + ')', x);
	}
	function not(p, x) {
	  // should this be a plugin?
	  var selector = p.split(',').map(function (x) {
	    return x.trim();
	  }).map(function (x) {
	    return ':not(' + x + ')';
	  });
	  if (selector.length === 1) {
	    return pseudo(':not(' + p + ')', x);
	  }
	  return select(selector.join(''), x);
	}
	function nthChild(p, x) {
	  return pseudo(':nth-child(' + p + ')', x);
	}
	function nthLastChild(p, x) {
	  return pseudo(':nth-last-child(' + p + ')', x);
	}
	function nthLastOfType(p, x) {
	  return pseudo(':nth-last-of-type(' + p + ')', x);
	}
	function nthOfType(p, x) {
	  return pseudo(':nth-of-type(' + p + ')', x);
	}
	
	// pseudoelements
	function after(x) {
	  return pseudo('::after', x);
	}
	function before(x) {
	  return pseudo('::before', x);
	}
	function firstLetter(x) {
	  return pseudo('::first-letter', x);
	}
	function firstLine(x) {
	  return pseudo('::first-line', x);
	}
	function selection(x) {
	  return pseudo('::selection', x);
	}
	function backdrop(x) {
	  return pseudo('::backdrop', x);
	}
	function placeholder(x) {
	  // https://github.com/threepointone/glamor/issues/14
	  return merge(pseudo('::placeholder', x), pseudo('::-webkit-input-placeholder', x), pseudo('::-moz-placeholder', x), pseudo('::-ms-input-placeholder', x));
	}
	
	// we can add keyframes in a similar manner, but still generating a unique name 
	// for including in styles. this gives us modularity, but still a natural api 
	function keyframes(name, kfs) {
	  if (!kfs) {
	    kfs = name, name = 'animation';
	  }
	
	  // do not ignore empty keyframe definitions for now.
	  kfs = (0, _clean2.default)(kfs) || {};
	  var spec = {
	    id: hashify(name, kfs),
	    type: 'keyframes',
	    name: name,
	    keyframes: kfs
	  };
	  register(spec);
	  insertKeyframe(spec);
	  return name + '_' + spec.id;
	}
	
	// we don't go all out for fonts as much, giving a simple font loading strategy 
	// use a fancier lib if you need moar power
	function fontFace(font) {
	  font = (0, _clean2.default)(font);
	  var spec = {
	    id: hashify(font),
	    type: 'font-face',
	    font: font
	  };
	  register(spec);
	  insertFontFace(spec);
	
	  return font.fontFamily;
	}
	
	/*** helpers for web components ***/
	// https://github.com/threepointone/glamor/issues/16
	
	function cssFor() {
	  for (var _len6 = arguments.length, rules = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    rules[_key6] = arguments[_key6];
	  }
	
	  rules = (0, _clean2.default)(rules);
	  return rules ? flatten(rules.map(function (r) {
	    return registered[idFor(r)];
	  }).map(ruleToCSS)).join('') : '';
	}
	
	function attribsFor() {
	  for (var _len7 = arguments.length, rules = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
	    rules[_key7] = arguments[_key7];
	  }
	
	  rules = (0, _clean2.default)(rules);
	  var htmlAttributes = rules ? rules.map(function (rule) {
	    idFor(rule); // throwaway check for rule 
	    var key = Object.keys(rule)[0],
	        value = rule[key];
	    return key + '="' + (value || '') + '"';
	  }).join(' ') : '';
	
	  return htmlAttributes;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* 
	
	high performance StyleSheet for css-in-js systems 
	
	- uses multiple style tags behind the scenes for millions of rules 
	- uses `insertRule` for appending in production for *much* faster performance
	- 'polyfills' on server side 
	
	
	// usage
	
	import StyleSheet from 'glamor/lib/sheet'
	let styleSheet = new StyleSheet()
	
	styleSheet.inject() 
	- 'injects' the stylesheet into the page (or into memory if on server)
	
	styleSheet.insert('#box { border: 1px solid red; }') 
	- appends a css rule into the stylesheet 
	
	styleSheet.flush() 
	- empties the stylesheet of all its contents
	
	
	*/
	
	function last() {
	  return this[this.length - 1];
	}
	
	function sheetForTag(tag) {
	  for (var i = 0; i < document.styleSheets.length; i++) {
	    if (document.styleSheets[i].ownerNode === tag) {
	      return document.styleSheets[i];
	    }
	  }
	}
	
	var isBrowser = typeof window !== 'undefined';
	var isDev = function (x) {
	  return x === 'development' || !x;
	}(process.env.NODE_ENV);
	var isTest = process.env.NODE_ENV === 'test';
	
	var oldIE = function () {
	  if (isBrowser) {
	    var div = document.createElement('div');
	    div.innerHTML = '<!--[if lt IE 10]><i></i><![endif]-->';
	    return div.getElementsByTagName('i').length === 1;
	  }
	}();
	
	function makeStyleTag() {
	  var tag = document.createElement('style');
	  tag.type = 'text/css';
	  tag.appendChild(document.createTextNode(''));
	  (document.head || document.getElementsByTagName('head')[0]).appendChild(tag);
	  return tag;
	}
	
	var StyleSheet = exports.StyleSheet = function () {
	  function StyleSheet() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    var _ref$speedy = _ref.speedy;
	    var speedy = _ref$speedy === undefined ? !isDev && !isTest : _ref$speedy;
	    var _ref$maxLength = _ref.maxLength;
	    var maxLength = _ref$maxLength === undefined ? isBrowser && oldIE ? 4000 : 65000 : _ref$maxLength;
	
	    _classCallCheck(this, StyleSheet);
	
	    this.isSpeedy = speedy; // the big drawback here is that the css won't be editable in devtools
	    this.sheet = undefined;
	    this.tags = [];
	    this.maxLength = maxLength;
	    this.ctr = 0;
	  }
	
	  _createClass(StyleSheet, [{
	    key: 'inject',
	    value: function inject() {
	      var _this = this;
	
	      if (this.injected) {
	        throw new Error('already injected stylesheet!');
	      }
	      if (isBrowser) {
	        // this section is just weird alchemy I found online off many sources 
	        this.tags[0] = makeStyleTag();
	        // this weirdness brought to you by firefox 
	        this.sheet = sheetForTag(this.tags[0]);
	      } else {
	        // server side 'polyfill'. just enough behavior to be useful.
	        this.sheet = {
	          cssRules: [],
	          insertRule: function insertRule(rule) {
	            // enough 'spec compliance' to be able to extract the rules later  
	            // in other words, just the cssText field 
	            _this.sheet.cssRules.push({ cssText: rule });
	          }
	        };
	      }
	      this.injected = true;
	    }
	  }, {
	    key: 'speedy',
	    value: function speedy(bool) {
	      if (this.ctr !== 0) {
	        throw new Error('cannot change speedy mode after inserting any rule to sheet. Either call speedy(' + bool + ') earlier in your app, or call flush() before speedy(' + bool + ')');
	      }
	      this.isSpeedy = !!bool;
	    }
	  }, {
	    key: '_insert',
	    value: function _insert(rule) {
	      // this weirdness for perf, and chrome's weird bug 
	      // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
	      try {
	        this.sheet.insertRule(rule, this.sheet.cssRules.length); // todo - correct index here     
	      } catch (e) {
	        if (isDev) {
	          // might need beter dx for this 
	          console.warn('whoops, illegal rule inserted', rule); //eslint-disable-line no-console
	        }
	      }
	    }
	  }, {
	    key: 'insert',
	    value: function insert(rule) {
	
	      if (isBrowser) {
	        var _context;
	
	        // this is the ultrafast version, works across browsers 
	        if (this.isSpeedy && this.sheet.insertRule) {
	          this._insert(rule);
	        }
	        // more browser weirdness. I don't even know    
	        else if (this.tags.length > 0 && (_context = this.tags, last).call(_context).styleSheet) {
	            var _context2;
	
	            (_context2 = this.tags, last).call(_context2).styleSheet.cssText += rule;
	          } else {
	            var _context3;
	
	            (_context3 = this.tags, last).call(_context3).appendChild(document.createTextNode(rule));
	
	            if (!this.isSpeedy) {
	              var _context4;
	
	              // sighhh
	              this.sheet = sheetForTag((_context4 = this.tags, last).call(_context4));
	            }
	          }
	      } else {
	        // server side is pretty simple         
	        this.sheet.insertRule(rule);
	      }
	
	      this.ctr++;
	      if (isBrowser && this.ctr % this.maxLength === 0) {
	        var _context5;
	
	        this.tags.push(makeStyleTag());
	        this.sheet = sheetForTag((_context5 = this.tags, last).call(_context5));
	      }
	    }
	  }, {
	    key: 'flush',
	    value: function flush() {
	      if (isBrowser) {
	        this.tags.forEach(function (tag) {
	          return tag.parentNode.removeChild(tag);
	        });
	        this.tags = [];
	        this.sheet = null;
	        this.ctr = 0;
	        // todo - look for remnants in document.styleSheets
	      } else {
	        // simpler on server 
	        this.sheet.cssRules = [];
	      }
	      this.injected = false;
	    }
	  }, {
	    key: 'rules',
	    value: function rules() {
	      if (!isBrowser) {
	        return this.sheet.cssRules;
	      }
	      var arr = [];
	      this.tags.forEach(function (tag) {
	        return arr.splice.apply(arr, [arr.length, 0].concat(_toConsumableArray(Array.from(sheetForTag(tag).cssRules))));
	      });
	      return arr;
	    }
	  }]);
	
	  return StyleSheet;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	(function (f) {
	  if (( false ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
	    module.exports = f();
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    var g;if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      g = this;
	    }g.CSSOps = f();
	  }
	})(function () {
	  var define, module, exports;return function e(t, n, r) {
	    function s(o, u) {
	      if (!n[o]) {
	        if (!t[o]) {
	          var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
	        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
	          var n = t[o][1][e];return s(n ? n : e);
	        }, l, l.exports, e, t, n, r);
	      }return n[o].exports;
	    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
	      s(r[o]);
	    }return s;
	  }({ 1: [function (_dereq_, module, exports) {
	      module.exports = _dereq_("react/lib/CSSPropertyOperations");
	    }, { "react/lib/CSSPropertyOperations": 14 }], 2: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       */
	
	      'use strict';
	
	      var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	      /**
	       * Simple, lightweight module assisting with the detection and context of
	       * Worker. Helps avoid circular dependencies and allows code to reason about
	       * whether or not they are in a Worker, even if they never include the main
	       * `ReactWorker` dependency.
	       */
	      var ExecutionEnvironment = {
	
	        canUseDOM: canUseDOM,
	
	        canUseWorkers: typeof Worker !== 'undefined',
	
	        canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	        canUseViewport: canUseDOM && !!window.screen,
	
	        isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	      };
	
	      module.exports = ExecutionEnvironment;
	    }, {}], 3: [function (_dereq_, module, exports) {
	      "use strict";
	
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @typechecks
	       */
	
	      var _hyphenPattern = /-(.)/g;
	
	      /**
	       * Camelcases a hyphenated string, for example:
	       *
	       *   > camelize('background-color')
	       *   < "backgroundColor"
	       *
	       * @param {string} string
	       * @return {string}
	       */
	      function camelize(string) {
	        return string.replace(_hyphenPattern, function (_, character) {
	          return character.toUpperCase();
	        });
	      }
	
	      module.exports = camelize;
	    }, {}], 4: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @typechecks
	       */
	
	      'use strict';
	
	      var camelize = _dereq_('./camelize');
	
	      var msPattern = /^-ms-/;
	
	      /**
	       * Camelcases a hyphenated CSS property name, for example:
	       *
	       *   > camelizeStyleName('background-color')
	       *   < "backgroundColor"
	       *   > camelizeStyleName('-moz-transition')
	       *   < "MozTransition"
	       *   > camelizeStyleName('-ms-transition')
	       *   < "msTransition"
	       *
	       * As Andi Smith suggests
	       * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	       * is converted to lowercase `ms`.
	       *
	       * @param {string} string
	       * @return {string}
	       */
	      function camelizeStyleName(string) {
	        return camelize(string.replace(msPattern, 'ms-'));
	      }
	
	      module.exports = camelizeStyleName;
	    }, { "./camelize": 3 }], 5: [function (_dereq_, module, exports) {
	      "use strict";
	
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * 
	       */
	
	      function makeEmptyFunction(arg) {
	        return function () {
	          return arg;
	        };
	      }
	
	      /**
	       * This function accepts and discards inputs; it has no side effects. This is
	       * primarily useful idiomatically for overridable function endpoints which
	       * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	       */
	      var emptyFunction = function emptyFunction() {};
	
	      emptyFunction.thatReturns = makeEmptyFunction;
	      emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	      emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	      emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	      emptyFunction.thatReturnsThis = function () {
	        return this;
	      };
	      emptyFunction.thatReturnsArgument = function (arg) {
	        return arg;
	      };
	
	      module.exports = emptyFunction;
	    }, {}], 6: [function (_dereq_, module, exports) {
	      'use strict';
	
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @typechecks
	       */
	
	      var _uppercasePattern = /([A-Z])/g;
	
	      /**
	       * Hyphenates a camelcased string, for example:
	       *
	       *   > hyphenate('backgroundColor')
	       *   < "background-color"
	       *
	       * For CSS style names, use `hyphenateStyleName` instead which works properly
	       * with all vendor prefixes, including `ms`.
	       *
	       * @param {string} string
	       * @return {string}
	       */
	      function hyphenate(string) {
	        return string.replace(_uppercasePattern, '-$1').toLowerCase();
	      }
	
	      module.exports = hyphenate;
	    }, {}], 7: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @typechecks
	       */
	
	      'use strict';
	
	      var hyphenate = _dereq_('./hyphenate');
	
	      var msPattern = /^ms-/;
	
	      /**
	       * Hyphenates a camelcased CSS property name, for example:
	       *
	       *   > hyphenateStyleName('backgroundColor')
	       *   < "background-color"
	       *   > hyphenateStyleName('MozTransition')
	       *   < "-moz-transition"
	       *   > hyphenateStyleName('msTransition')
	       *   < "-ms-transition"
	       *
	       * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	       * is converted to `-ms-`.
	       *
	       * @param {string} string
	       * @return {string}
	       */
	      function hyphenateStyleName(string) {
	        return hyphenate(string).replace(msPattern, '-ms-');
	      }
	
	      module.exports = hyphenateStyleName;
	    }, { "./hyphenate": 6 }], 8: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       */
	
	      'use strict';
	
	      /**
	       * Use invariant() to assert state which your program assumes to be true.
	       *
	       * Provide sprintf-style format (only %s is supported) and arguments
	       * to provide information about what broke and what you were
	       * expecting.
	       *
	       * The invariant message will be stripped in production, but the invariant
	       * will remain to ensure logic does not differ in production.
	       */
	
	      function invariant(condition, format, a, b, c, d, e, f) {
	        if (false) {
	          if (format === undefined) {
	            throw new Error('invariant requires an error message argument');
	          }
	        }
	
	        if (!condition) {
	          var error;
	          if (format === undefined) {
	            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	          } else {
	            var args = [a, b, c, d, e, f];
	            var argIndex = 0;
	            error = new Error(format.replace(/%s/g, function () {
	              return args[argIndex++];
	            }));
	            error.name = 'Invariant Violation';
	          }
	
	          error.framesToPop = 1; // we don't care about invariant's own frame
	          throw error;
	        }
	      }
	
	      module.exports = invariant;
	    }, {}], 9: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * 
	       * @typechecks static-only
	       */
	
	      'use strict';
	
	      /**
	       * Memoizes the return value of a function that accepts one string argument.
	       */
	
	      function memoizeStringOnly(callback) {
	        var cache = {};
	        return function (string) {
	          if (!cache.hasOwnProperty(string)) {
	            cache[string] = callback.call(this, string);
	          }
	          return cache[string];
	        };
	      }
	
	      module.exports = memoizeStringOnly;
	    }, {}], 10: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @typechecks
	       */
	
	      'use strict';
	
	      var ExecutionEnvironment = _dereq_('./ExecutionEnvironment');
	
	      var performance;
	
	      if (ExecutionEnvironment.canUseDOM) {
	        performance = window.performance || window.msPerformance || window.webkitPerformance;
	      }
	
	      module.exports = performance || {};
	    }, { "./ExecutionEnvironment": 2 }], 11: [function (_dereq_, module, exports) {
	      'use strict';
	
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @typechecks
	       */
	
	      var performance = _dereq_('./performance');
	
	      var performanceNow;
	
	      /**
	       * Detect if we can use `window.performance.now()` and gracefully fallback to
	       * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	       * because of Facebook's testing infrastructure.
	       */
	      if (performance.now) {
	        performanceNow = function performanceNow() {
	          return performance.now();
	        };
	      } else {
	        performanceNow = function performanceNow() {
	          return Date.now();
	        };
	      }
	
	      module.exports = performanceNow;
	    }, { "./performance": 10 }], 12: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2014-2015, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       */
	
	      'use strict';
	
	      var emptyFunction = _dereq_('./emptyFunction');
	
	      /**
	       * Similar to invariant but only logs a warning if the condition is not met.
	       * This can be used to log issues in development environments in critical
	       * paths. Removing the logging code for production environments will keep the
	       * same logic and follow the same code paths.
	       */
	
	      var warning = emptyFunction;
	
	      if (false) {
	        (function () {
	          var printWarning = function printWarning(format) {
	            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = arguments[_key];
	            }
	
	            var argIndex = 0;
	            var message = 'Warning: ' + format.replace(/%s/g, function () {
	              return args[argIndex++];
	            });
	            if (typeof console !== 'undefined') {
	              console.error(message);
	            }
	            try {
	              // --- Welcome to debugging React ---
	              // This error was thrown as a convenience so that you can use this stack
	              // to find the callsite that caused this warning to fire.
	              throw new Error(message);
	            } catch (x) {}
	          };
	
	          warning = function warning(condition, format) {
	            if (format === undefined) {
	              throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	            }
	
	            if (format.indexOf('Failed Composite propType: ') === 0) {
	              return; // Ignore CompositeComponent proptype check.
	            }
	
	            if (!condition) {
	              for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	                args[_key2 - 2] = arguments[_key2];
	              }
	
	              printWarning.apply(undefined, [format].concat(args));
	            }
	          };
	        })();
	      }
	
	      module.exports = warning;
	    }, { "./emptyFunction": 5 }], 13: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule CSSProperty
	       */
	
	      'use strict';
	
	      /**
	       * CSS properties which accept numbers but are not in units of "px".
	       */
	
	      var isUnitlessNumber = {
	        animationIterationCount: true,
	        borderImageOutset: true,
	        borderImageSlice: true,
	        borderImageWidth: true,
	        boxFlex: true,
	        boxFlexGroup: true,
	        boxOrdinalGroup: true,
	        columnCount: true,
	        flex: true,
	        flexGrow: true,
	        flexPositive: true,
	        flexShrink: true,
	        flexNegative: true,
	        flexOrder: true,
	        gridRow: true,
	        gridColumn: true,
	        fontWeight: true,
	        lineClamp: true,
	        lineHeight: true,
	        opacity: true,
	        order: true,
	        orphans: true,
	        tabSize: true,
	        widows: true,
	        zIndex: true,
	        zoom: true,
	
	        // SVG-related properties
	        fillOpacity: true,
	        floodOpacity: true,
	        stopOpacity: true,
	        strokeDasharray: true,
	        strokeDashoffset: true,
	        strokeMiterlimit: true,
	        strokeOpacity: true,
	        strokeWidth: true
	      };
	
	      /**
	       * @param {string} prefix vendor-specific prefix, eg: Webkit
	       * @param {string} key style name, eg: transitionDuration
	       * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	       * WebkitTransitionDuration
	       */
	      function prefixKey(prefix, key) {
	        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	      }
	
	      /**
	       * Support style names that may come passed in prefixed by adding permutations
	       * of vendor prefixes.
	       */
	      var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	      // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	      // infinite loop, because it iterates over the newly added props too.
	      Object.keys(isUnitlessNumber).forEach(function (prop) {
	        prefixes.forEach(function (prefix) {
	          isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	        });
	      });
	
	      /**
	       * Most style properties can be unset by doing .style[prop] = '' but IE8
	       * doesn't like doing that with shorthand properties so for the properties that
	       * IE8 breaks on, which are listed here, we instead unset each of the
	       * individual properties. See http://bugs.jquery.com/ticket/12385.
	       * The 4-value 'clock' properties like margin, padding, border-width seem to
	       * behave without any problems. Curiously, list-style works too without any
	       * special prodding.
	       */
	      var shorthandPropertyExpansions = {
	        background: {
	          backgroundAttachment: true,
	          backgroundColor: true,
	          backgroundImage: true,
	          backgroundPositionX: true,
	          backgroundPositionY: true,
	          backgroundRepeat: true
	        },
	        backgroundPosition: {
	          backgroundPositionX: true,
	          backgroundPositionY: true
	        },
	        border: {
	          borderWidth: true,
	          borderStyle: true,
	          borderColor: true
	        },
	        borderBottom: {
	          borderBottomWidth: true,
	          borderBottomStyle: true,
	          borderBottomColor: true
	        },
	        borderLeft: {
	          borderLeftWidth: true,
	          borderLeftStyle: true,
	          borderLeftColor: true
	        },
	        borderRight: {
	          borderRightWidth: true,
	          borderRightStyle: true,
	          borderRightColor: true
	        },
	        borderTop: {
	          borderTopWidth: true,
	          borderTopStyle: true,
	          borderTopColor: true
	        },
	        font: {
	          fontStyle: true,
	          fontVariant: true,
	          fontWeight: true,
	          fontSize: true,
	          lineHeight: true,
	          fontFamily: true
	        },
	        outline: {
	          outlineWidth: true,
	          outlineStyle: true,
	          outlineColor: true
	        }
	      };
	
	      var CSSProperty = {
	        isUnitlessNumber: isUnitlessNumber,
	        shorthandPropertyExpansions: shorthandPropertyExpansions
	      };
	
	      module.exports = CSSProperty;
	    }, {}], 14: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule CSSPropertyOperations
	       */
	
	      'use strict';
	
	      var CSSProperty = _dereq_('./CSSProperty');
	      var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
	      var ReactInstrumentation = _dereq_('./ReactInstrumentation');
	
	      var camelizeStyleName = _dereq_('fbjs/lib/camelizeStyleName');
	      var dangerousStyleValue = _dereq_('./dangerousStyleValue');
	      var hyphenateStyleName = _dereq_('fbjs/lib/hyphenateStyleName');
	      var memoizeStringOnly = _dereq_('fbjs/lib/memoizeStringOnly');
	      var warning = _dereq_('fbjs/lib/warning');
	
	      var processStyleName = memoizeStringOnly(function (styleName) {
	        return hyphenateStyleName(styleName);
	      });
	
	      var hasShorthandPropertyBug = false;
	      var styleFloatAccessor = 'cssFloat';
	      if (ExecutionEnvironment.canUseDOM) {
	        var tempStyle = document.createElement('div').style;
	        try {
	          // IE8 throws "Invalid argument." if resetting shorthand style properties.
	          tempStyle.font = '';
	        } catch (e) {
	          hasShorthandPropertyBug = true;
	        }
	        // IE8 only supports accessing cssFloat (standard) as styleFloat
	        if (document.documentElement.style.cssFloat === undefined) {
	          styleFloatAccessor = 'styleFloat';
	        }
	      }
	
	      if (false) {
	        // 'msTransform' is correct, but the other prefixes should be capitalized
	        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	        // style values shouldn't contain a semicolon
	        var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	        var warnedStyleNames = {};
	        var warnedStyleValues = {};
	        var warnedForNaNValue = false;
	
	        var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
	          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	            return;
	          }
	
	          warnedStyleNames[name] = true;
	          "production" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	        };
	
	        var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
	          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	            return;
	          }
	
	          warnedStyleNames[name] = true;
	          "production" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	        };
	
	        var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
	          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	            return;
	          }
	
	          warnedStyleValues[value] = true;
	          "production" !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	        };
	
	        var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
	          if (warnedForNaNValue) {
	            return;
	          }
	
	          warnedForNaNValue = true;
	          "production" !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	        };
	
	        var checkRenderMessage = function checkRenderMessage(owner) {
	          if (owner) {
	            var name = owner.getName();
	            if (name) {
	              return ' Check the render method of `' + name + '`.';
	            }
	          }
	          return '';
	        };
	
	        /**
	         * @param {string} name
	         * @param {*} value
	         * @param {ReactDOMComponent} component
	         */
	        var warnValidStyle = function warnValidStyle(name, value, component) {
	          var owner;
	          if (component) {
	            owner = component._currentElement._owner;
	          }
	          if (name.indexOf('-') > -1) {
	            warnHyphenatedStyleName(name, owner);
	          } else if (badVendoredStyleNamePattern.test(name)) {
	            warnBadVendoredStyleName(name, owner);
	          } else if (badStyleValueWithSemicolonPattern.test(value)) {
	            warnStyleValueWithSemicolon(name, value, owner);
	          }
	
	          if (typeof value === 'number' && isNaN(value)) {
	            warnStyleValueIsNaN(name, value, owner);
	          }
	        };
	      }
	
	      /**
	       * Operations for dealing with CSS properties.
	       */
	      var CSSPropertyOperations = {
	
	        /**
	         * Serializes a mapping of style properties for use as inline styles:
	         *
	         *   > createMarkupForStyles({width: '200px', height: 0})
	         *   "width:200px;height:0;"
	         *
	         * Undefined values are ignored so that declarative programming is easier.
	         * The result should be HTML-escaped before insertion into the DOM.
	         *
	         * @param {object} styles
	         * @param {ReactDOMComponent} component
	         * @return {?string}
	         */
	        createMarkupForStyles: function createMarkupForStyles(styles, component) {
	          var serialized = '';
	          for (var styleName in styles) {
	            if (!styles.hasOwnProperty(styleName)) {
	              continue;
	            }
	            var styleValue = styles[styleName];
	            if (false) {
	              warnValidStyle(styleName, styleValue, component);
	            }
	            if (styleValue != null) {
	              serialized += processStyleName(styleName) + ':';
	              serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	            }
	          }
	          return serialized || null;
	        },
	
	        /**
	         * Sets the value for multiple styles on a node.  If a value is specified as
	         * '' (empty string), the corresponding style property will be unset.
	         *
	         * @param {DOMElement} node
	         * @param {object} styles
	         * @param {ReactDOMComponent} component
	         */
	        setValueForStyles: function setValueForStyles(node, styles, component) {
	          if (false) {
	            ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	          }
	
	          var style = node.style;
	          for (var styleName in styles) {
	            if (!styles.hasOwnProperty(styleName)) {
	              continue;
	            }
	            if (false) {
	              warnValidStyle(styleName, styles[styleName], component);
	            }
	            var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	            if (styleName === 'float' || styleName === 'cssFloat') {
	              styleName = styleFloatAccessor;
	            }
	            if (styleValue) {
	              style[styleName] = styleValue;
	            } else {
	              var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	              if (expansion) {
	                // Shorthand property that IE8 won't like unsetting, so unset each
	                // component to placate it
	                for (var individualStyleName in expansion) {
	                  style[individualStyleName] = '';
	                }
	              } else {
	                style[styleName] = '';
	              }
	            }
	          }
	        }
	
	      };
	
	      module.exports = CSSPropertyOperations;
	    }, { "./CSSProperty": 13, "./ReactInstrumentation": 20, "./dangerousStyleValue": 22, "fbjs/lib/ExecutionEnvironment": 2, "fbjs/lib/camelizeStyleName": 4, "fbjs/lib/hyphenateStyleName": 7, "fbjs/lib/memoizeStringOnly": 9, "fbjs/lib/warning": 12 }], 15: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactChildrenMutationWarningHook
	       */
	
	      'use strict';
	
	      var ReactComponentTreeHook = _dereq_('./ReactComponentTreeHook');
	
	      var warning = _dereq_('fbjs/lib/warning');
	
	      function handleElement(debugID, element) {
	        if (element == null) {
	          return;
	        }
	        if (element._shadowChildren === undefined) {
	          return;
	        }
	        if (element._shadowChildren === element.props.children) {
	          return;
	        }
	        var isMutated = false;
	        if (Array.isArray(element._shadowChildren)) {
	          if (element._shadowChildren.length === element.props.children.length) {
	            for (var i = 0; i < element._shadowChildren.length; i++) {
	              if (element._shadowChildren[i] !== element.props.children[i]) {
	                isMutated = true;
	              }
	            }
	          } else {
	            isMutated = true;
	          }
	        }
	        if (!Array.isArray(element._shadowChildren) || isMutated) {
	           false ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	        }
	      }
	
	      var ReactChildrenMutationWarningHook = {
	        onMountComponent: function onMountComponent(debugID) {
	          handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	        },
	        onUpdateComponent: function onUpdateComponent(debugID) {
	          handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	        }
	      };
	
	      module.exports = ReactChildrenMutationWarningHook;
	    }, { "./ReactComponentTreeHook": 16, "fbjs/lib/warning": 12 }], 16: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2016-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactComponentTreeHook
	       */
	
	      'use strict';
	
	      var _prodInvariant = _dereq_('./reactProdInvariant');
	
	      var ReactCurrentOwner = _dereq_('./ReactCurrentOwner');
	
	      var invariant = _dereq_('fbjs/lib/invariant');
	      var warning = _dereq_('fbjs/lib/warning');
	
	      function isNative(fn) {
	        // Based on isNative() from Lodash
	        var funcToString = Function.prototype.toString;
	        var hasOwnProperty = Object.prototype.hasOwnProperty;
	        var reIsNative = RegExp('^' + funcToString
	        // Take an example native function source for comparison
	        .call(hasOwnProperty)
	        // Strip regex characters so we can use it for regex
	        .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	        // Remove hasOwnProperty from the template to make it generic
	        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	        try {
	          var source = funcToString.call(fn);
	          return reIsNative.test(source);
	        } catch (err) {
	          return false;
	        }
	      }
	
	      var canUseCollections =
	      // Array.from
	      typeof Array.from === 'function' &&
	      // Map
	      typeof Map === 'function' && isNative(Map) &&
	      // Map.prototype.keys
	      Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	      // Set
	      typeof Set === 'function' && isNative(Set) &&
	      // Set.prototype.keys
	      Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	      var itemMap;
	      var rootIDSet;
	
	      var itemByKey;
	      var rootByKey;
	
	      if (canUseCollections) {
	        itemMap = new Map();
	        rootIDSet = new Set();
	      } else {
	        itemByKey = {};
	        rootByKey = {};
	      }
	
	      var unmountedIDs = [];
	
	      // Use non-numeric keys to prevent V8 performance issues:
	      // https://github.com/facebook/react/pull/7232
	      function getKeyFromID(id) {
	        return '.' + id;
	      }
	      function getIDFromKey(key) {
	        return parseInt(key.substr(1), 10);
	      }
	
	      function get(id) {
	        if (canUseCollections) {
	          return itemMap.get(id);
	        } else {
	          var key = getKeyFromID(id);
	          return itemByKey[key];
	        }
	      }
	
	      function remove(id) {
	        if (canUseCollections) {
	          itemMap['delete'](id);
	        } else {
	          var key = getKeyFromID(id);
	          delete itemByKey[key];
	        }
	      }
	
	      function create(id, element, parentID) {
	        var item = {
	          element: element,
	          parentID: parentID,
	          text: null,
	          childIDs: [],
	          isMounted: false,
	          updateCount: 0
	        };
	
	        if (canUseCollections) {
	          itemMap.set(id, item);
	        } else {
	          var key = getKeyFromID(id);
	          itemByKey[key] = item;
	        }
	      }
	
	      function addRoot(id) {
	        if (canUseCollections) {
	          rootIDSet.add(id);
	        } else {
	          var key = getKeyFromID(id);
	          rootByKey[key] = true;
	        }
	      }
	
	      function removeRoot(id) {
	        if (canUseCollections) {
	          rootIDSet['delete'](id);
	        } else {
	          var key = getKeyFromID(id);
	          delete rootByKey[key];
	        }
	      }
	
	      function getRegisteredIDs() {
	        if (canUseCollections) {
	          return Array.from(itemMap.keys());
	        } else {
	          return Object.keys(itemByKey).map(getIDFromKey);
	        }
	      }
	
	      function getRootIDs() {
	        if (canUseCollections) {
	          return Array.from(rootIDSet.keys());
	        } else {
	          return Object.keys(rootByKey).map(getIDFromKey);
	        }
	      }
	
	      function purgeDeep(id) {
	        var item = get(id);
	        if (item) {
	          var childIDs = item.childIDs;
	
	          remove(id);
	          childIDs.forEach(purgeDeep);
	        }
	      }
	
	      function describeComponentFrame(name, source, ownerName) {
	        return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	      }
	
	      function _getDisplayName(element) {
	        if (element == null) {
	          return '#empty';
	        } else if (typeof element === 'string' || typeof element === 'number') {
	          return '#text';
	        } else if (typeof element.type === 'string') {
	          return element.type;
	        } else {
	          return element.type.displayName || element.type.name || 'Unknown';
	        }
	      }
	
	      function describeID(id) {
	        var name = ReactComponentTreeHook.getDisplayName(id);
	        var element = ReactComponentTreeHook.getElement(id);
	        var ownerID = ReactComponentTreeHook.getOwnerID(id);
	        var ownerName;
	        if (ownerID) {
	          ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	        }
	         false ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	        return describeComponentFrame(name, element && element._source, ownerName);
	      }
	
	      var ReactComponentTreeHook = {
	        onSetChildren: function onSetChildren(id, nextChildIDs) {
	          var item = get(id);
	          item.childIDs = nextChildIDs;
	
	          for (var i = 0; i < nextChildIDs.length; i++) {
	            var nextChildID = nextChildIDs[i];
	            var nextChild = get(nextChildID);
	            !nextChild ?  false ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	            !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ?  false ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	            !nextChild.isMounted ?  false ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	            if (nextChild.parentID == null) {
	              nextChild.parentID = id;
	              // TODO: This shouldn't be necessary but mounting a new root during in
	              // componentWillMount currently causes not-yet-mounted components to
	              // be purged from our tree data so their parent ID is missing.
	            }
	            !(nextChild.parentID === id) ?  false ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	          }
	        },
	        onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
	          create(id, element, parentID);
	        },
	        onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
	          var item = get(id);
	          if (!item || !item.isMounted) {
	            // We may end up here as a result of setState() in componentWillUnmount().
	            // In this case, ignore the element.
	            return;
	          }
	          item.element = element;
	        },
	        onMountComponent: function onMountComponent(id) {
	          var item = get(id);
	          item.isMounted = true;
	          var isRoot = item.parentID === 0;
	          if (isRoot) {
	            addRoot(id);
	          }
	        },
	        onUpdateComponent: function onUpdateComponent(id) {
	          var item = get(id);
	          if (!item || !item.isMounted) {
	            // We may end up here as a result of setState() in componentWillUnmount().
	            // In this case, ignore the element.
	            return;
	          }
	          item.updateCount++;
	        },
	        onUnmountComponent: function onUnmountComponent(id) {
	          var item = get(id);
	          if (item) {
	            // We need to check if it exists.
	            // `item` might not exist if it is inside an error boundary, and a sibling
	            // error boundary child threw while mounting. Then this instance never
	            // got a chance to mount, but it still gets an unmounting event during
	            // the error boundary cleanup.
	            item.isMounted = false;
	            var isRoot = item.parentID === 0;
	            if (isRoot) {
	              removeRoot(id);
	            }
	          }
	          unmountedIDs.push(id);
	        },
	        purgeUnmountedComponents: function purgeUnmountedComponents() {
	          if (ReactComponentTreeHook._preventPurging) {
	            // Should only be used for testing.
	            return;
	          }
	
	          for (var i = 0; i < unmountedIDs.length; i++) {
	            var id = unmountedIDs[i];
	            purgeDeep(id);
	          }
	          unmountedIDs.length = 0;
	        },
	        isMounted: function isMounted(id) {
	          var item = get(id);
	          return item ? item.isMounted : false;
	        },
	        getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
	          var info = '';
	          if (topElement) {
	            var type = topElement.type;
	            var name = typeof type === 'function' ? type.displayName || type.name : type;
	            var owner = topElement._owner;
	            info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	          }
	
	          var currentOwner = ReactCurrentOwner.current;
	          var id = currentOwner && currentOwner._debugID;
	
	          info += ReactComponentTreeHook.getStackAddendumByID(id);
	          return info;
	        },
	        getStackAddendumByID: function getStackAddendumByID(id) {
	          var info = '';
	          while (id) {
	            info += describeID(id);
	            id = ReactComponentTreeHook.getParentID(id);
	          }
	          return info;
	        },
	        getChildIDs: function getChildIDs(id) {
	          var item = get(id);
	          return item ? item.childIDs : [];
	        },
	        getDisplayName: function getDisplayName(id) {
	          var element = ReactComponentTreeHook.getElement(id);
	          if (!element) {
	            return null;
	          }
	          return _getDisplayName(element);
	        },
	        getElement: function getElement(id) {
	          var item = get(id);
	          return item ? item.element : null;
	        },
	        getOwnerID: function getOwnerID(id) {
	          var element = ReactComponentTreeHook.getElement(id);
	          if (!element || !element._owner) {
	            return null;
	          }
	          return element._owner._debugID;
	        },
	        getParentID: function getParentID(id) {
	          var item = get(id);
	          return item ? item.parentID : null;
	        },
	        getSource: function getSource(id) {
	          var item = get(id);
	          var element = item ? item.element : null;
	          var source = element != null ? element._source : null;
	          return source;
	        },
	        getText: function getText(id) {
	          var element = ReactComponentTreeHook.getElement(id);
	          if (typeof element === 'string') {
	            return element;
	          } else if (typeof element === 'number') {
	            return '' + element;
	          } else {
	            return null;
	          }
	        },
	        getUpdateCount: function getUpdateCount(id) {
	          var item = get(id);
	          return item ? item.updateCount : 0;
	        },
	
	        getRegisteredIDs: getRegisteredIDs,
	
	        getRootIDs: getRootIDs
	      };
	
	      module.exports = ReactComponentTreeHook;
	    }, { "./ReactCurrentOwner": 17, "./reactProdInvariant": 23, "fbjs/lib/invariant": 8, "fbjs/lib/warning": 12 }], 17: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactCurrentOwner
	       */
	
	      'use strict';
	
	      /**
	       * Keeps track of the current owner.
	       *
	       * The current owner is the component who should own any components that are
	       * currently being constructed.
	       */
	
	      var ReactCurrentOwner = {
	
	        /**
	         * @internal
	         * @type {ReactComponent}
	         */
	        current: null
	
	      };
	
	      module.exports = ReactCurrentOwner;
	    }, {}], 18: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2016-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactDebugTool
	       */
	
	      'use strict';
	
	      var ReactInvalidSetStateWarningHook = _dereq_('./ReactInvalidSetStateWarningHook');
	      var ReactHostOperationHistoryHook = _dereq_('./ReactHostOperationHistoryHook');
	      var ReactComponentTreeHook = _dereq_('./ReactComponentTreeHook');
	      var ReactChildrenMutationWarningHook = _dereq_('./ReactChildrenMutationWarningHook');
	      var ExecutionEnvironment = _dereq_('fbjs/lib/ExecutionEnvironment');
	
	      var performanceNow = _dereq_('fbjs/lib/performanceNow');
	      var warning = _dereq_('fbjs/lib/warning');
	
	      var hooks = [];
	      var didHookThrowForEvent = {};
	
	      function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	        try {
	          fn.call(context, arg1, arg2, arg3, arg4, arg5);
	        } catch (e) {
	           false ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	          didHookThrowForEvent[event] = true;
	        }
	      }
	
	      function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	        for (var i = 0; i < hooks.length; i++) {
	          var hook = hooks[i];
	          var fn = hook[event];
	          if (fn) {
	            callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	          }
	        }
	      }
	
	      var _isProfiling = false;
	      var flushHistory = [];
	      var lifeCycleTimerStack = [];
	      var currentFlushNesting = 0;
	      var currentFlushMeasurements = null;
	      var currentFlushStartTime = null;
	      var currentTimerDebugID = null;
	      var currentTimerStartTime = null;
	      var currentTimerNestedFlushDuration = null;
	      var currentTimerType = null;
	
	      var lifeCycleTimerHasWarned = false;
	
	      function clearHistory() {
	        ReactComponentTreeHook.purgeUnmountedComponents();
	        ReactHostOperationHistoryHook.clearHistory();
	      }
	
	      function getTreeSnapshot(registeredIDs) {
	        return registeredIDs.reduce(function (tree, id) {
	          var ownerID = ReactComponentTreeHook.getOwnerID(id);
	          var parentID = ReactComponentTreeHook.getParentID(id);
	          tree[id] = {
	            displayName: ReactComponentTreeHook.getDisplayName(id),
	            text: ReactComponentTreeHook.getText(id),
	            updateCount: ReactComponentTreeHook.getUpdateCount(id),
	            childIDs: ReactComponentTreeHook.getChildIDs(id),
	            // Text nodes don't have owners but this is close enough.
	            ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	            parentID: parentID
	          };
	          return tree;
	        }, {});
	      }
	
	      function resetMeasurements() {
	        var previousStartTime = currentFlushStartTime;
	        var previousMeasurements = currentFlushMeasurements || [];
	        var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	        if (currentFlushNesting === 0) {
	          currentFlushStartTime = null;
	          currentFlushMeasurements = null;
	          clearHistory();
	          return;
	        }
	
	        if (previousMeasurements.length || previousOperations.length) {
	          var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	          flushHistory.push({
	            duration: performanceNow() - previousStartTime,
	            measurements: previousMeasurements || [],
	            operations: previousOperations || [],
	            treeSnapshot: getTreeSnapshot(registeredIDs)
	          });
	        }
	
	        clearHistory();
	        currentFlushStartTime = performanceNow();
	        currentFlushMeasurements = [];
	      }
	
	      function checkDebugID(debugID) {
	        var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	        if (allowRoot && debugID === 0) {
	          return;
	        }
	        if (!debugID) {
	           false ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	        }
	      }
	
	      function beginLifeCycleTimer(debugID, timerType) {
	        if (currentFlushNesting === 0) {
	          return;
	        }
	        if (currentTimerType && !lifeCycleTimerHasWarned) {
	           false ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	          lifeCycleTimerHasWarned = true;
	        }
	        currentTimerStartTime = performanceNow();
	        currentTimerNestedFlushDuration = 0;
	        currentTimerDebugID = debugID;
	        currentTimerType = timerType;
	      }
	
	      function endLifeCycleTimer(debugID, timerType) {
	        if (currentFlushNesting === 0) {
	          return;
	        }
	        if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	           false ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	          lifeCycleTimerHasWarned = true;
	        }
	        if (_isProfiling) {
	          currentFlushMeasurements.push({
	            timerType: timerType,
	            instanceID: debugID,
	            duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	          });
	        }
	        currentTimerStartTime = null;
	        currentTimerNestedFlushDuration = null;
	        currentTimerDebugID = null;
	        currentTimerType = null;
	      }
	
	      function pauseCurrentLifeCycleTimer() {
	        var currentTimer = {
	          startTime: currentTimerStartTime,
	          nestedFlushStartTime: performanceNow(),
	          debugID: currentTimerDebugID,
	          timerType: currentTimerType
	        };
	        lifeCycleTimerStack.push(currentTimer);
	        currentTimerStartTime = null;
	        currentTimerNestedFlushDuration = null;
	        currentTimerDebugID = null;
	        currentTimerType = null;
	      }
	
	      function resumeCurrentLifeCycleTimer() {
	        var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	        var startTime = _lifeCycleTimerStack$.startTime;
	        var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	        var debugID = _lifeCycleTimerStack$.debugID;
	        var timerType = _lifeCycleTimerStack$.timerType;
	
	        var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	        currentTimerStartTime = startTime;
	        currentTimerNestedFlushDuration += nestedFlushDuration;
	        currentTimerDebugID = debugID;
	        currentTimerType = timerType;
	      }
	
	      var ReactDebugTool = {
	        addHook: function addHook(hook) {
	          hooks.push(hook);
	        },
	        removeHook: function removeHook(hook) {
	          for (var i = 0; i < hooks.length; i++) {
	            if (hooks[i] === hook) {
	              hooks.splice(i, 1);
	              i--;
	            }
	          }
	        },
	        isProfiling: function isProfiling() {
	          return _isProfiling;
	        },
	        beginProfiling: function beginProfiling() {
	          if (_isProfiling) {
	            return;
	          }
	
	          _isProfiling = true;
	          flushHistory.length = 0;
	          resetMeasurements();
	          ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	        },
	        endProfiling: function endProfiling() {
	          if (!_isProfiling) {
	            return;
	          }
	
	          _isProfiling = false;
	          resetMeasurements();
	          ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	        },
	        getFlushHistory: function getFlushHistory() {
	          return flushHistory;
	        },
	        onBeginFlush: function onBeginFlush() {
	          currentFlushNesting++;
	          resetMeasurements();
	          pauseCurrentLifeCycleTimer();
	          emitEvent('onBeginFlush');
	        },
	        onEndFlush: function onEndFlush() {
	          resetMeasurements();
	          currentFlushNesting--;
	          resumeCurrentLifeCycleTimer();
	          emitEvent('onEndFlush');
	        },
	        onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
	          checkDebugID(debugID);
	          emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	          beginLifeCycleTimer(debugID, timerType);
	        },
	        onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
	          checkDebugID(debugID);
	          endLifeCycleTimer(debugID, timerType);
	          emitEvent('onEndLifeCycleTimer', debugID, timerType);
	        },
	        onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	          emitEvent('onBeginProcessingChildContext');
	        },
	        onEndProcessingChildContext: function onEndProcessingChildContext() {
	          emitEvent('onEndProcessingChildContext');
	        },
	        onHostOperation: function onHostOperation(debugID, type, payload) {
	          checkDebugID(debugID);
	          emitEvent('onHostOperation', debugID, type, payload);
	        },
	        onSetState: function onSetState() {
	          emitEvent('onSetState');
	        },
	        onSetChildren: function onSetChildren(debugID, childDebugIDs) {
	          checkDebugID(debugID);
	          childDebugIDs.forEach(checkDebugID);
	          emitEvent('onSetChildren', debugID, childDebugIDs);
	        },
	        onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
	          checkDebugID(debugID);
	          checkDebugID(parentDebugID, true);
	          emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	        },
	        onMountComponent: function onMountComponent(debugID) {
	          checkDebugID(debugID);
	          emitEvent('onMountComponent', debugID);
	        },
	        onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	          checkDebugID(debugID);
	          emitEvent('onBeforeUpdateComponent', debugID, element);
	        },
	        onUpdateComponent: function onUpdateComponent(debugID) {
	          checkDebugID(debugID);
	          emitEvent('onUpdateComponent', debugID);
	        },
	        onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
	          checkDebugID(debugID);
	          emitEvent('onBeforeUnmountComponent', debugID);
	        },
	        onUnmountComponent: function onUnmountComponent(debugID) {
	          checkDebugID(debugID);
	          emitEvent('onUnmountComponent', debugID);
	        },
	        onTestEvent: function onTestEvent() {
	          emitEvent('onTestEvent');
	        }
	      };
	
	      // TODO remove these when RN/www gets updated
	      ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	      ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	      ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	      ReactDebugTool.addHook(ReactComponentTreeHook);
	      ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	      var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	      if (/[?&]react_perf\b/.test(url)) {
	        ReactDebugTool.beginProfiling();
	      }
	
	      module.exports = ReactDebugTool;
	    }, { "./ReactChildrenMutationWarningHook": 15, "./ReactComponentTreeHook": 16, "./ReactHostOperationHistoryHook": 19, "./ReactInvalidSetStateWarningHook": 21, "fbjs/lib/ExecutionEnvironment": 2, "fbjs/lib/performanceNow": 11, "fbjs/lib/warning": 12 }], 19: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2016-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactHostOperationHistoryHook
	       */
	
	      'use strict';
	
	      var history = [];
	
	      var ReactHostOperationHistoryHook = {
	        onHostOperation: function onHostOperation(debugID, type, payload) {
	          history.push({
	            instanceID: debugID,
	            type: type,
	            payload: payload
	          });
	        },
	        clearHistory: function clearHistory() {
	          if (ReactHostOperationHistoryHook._preventClearing) {
	            // Should only be used for tests.
	            return;
	          }
	
	          history = [];
	        },
	        getHistory: function getHistory() {
	          return history;
	        }
	      };
	
	      module.exports = ReactHostOperationHistoryHook;
	    }, {}], 20: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2016-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactInstrumentation
	       */
	
	      'use strict';
	
	      var debugTool = null;
	
	      if (false) {
	        var ReactDebugTool = _dereq_('./ReactDebugTool');
	        debugTool = ReactDebugTool;
	      }
	
	      module.exports = { debugTool: debugTool };
	    }, { "./ReactDebugTool": 18 }], 21: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2016-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule ReactInvalidSetStateWarningHook
	       */
	
	      'use strict';
	
	      var warning = _dereq_('fbjs/lib/warning');
	
	      if (false) {
	        var processingChildContext = false;
	
	        var warnInvalidSetState = function warnInvalidSetState() {
	          "production" !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	        };
	      }
	
	      var ReactInvalidSetStateWarningHook = {
	        onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	          processingChildContext = true;
	        },
	        onEndProcessingChildContext: function onEndProcessingChildContext() {
	          processingChildContext = false;
	        },
	        onSetState: function onSetState() {
	          warnInvalidSetState();
	        }
	      };
	
	      module.exports = ReactInvalidSetStateWarningHook;
	    }, { "fbjs/lib/warning": 12 }], 22: [function (_dereq_, module, exports) {
	      /**
	       * Copyright 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule dangerousStyleValue
	       */
	
	      'use strict';
	
	      var CSSProperty = _dereq_('./CSSProperty');
	      var warning = _dereq_('fbjs/lib/warning');
	
	      var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	      var styleWarnings = {};
	
	      /**
	       * Convert a value into the proper css writable value. The style name `name`
	       * should be logical (no hyphens), as specified
	       * in `CSSProperty.isUnitlessNumber`.
	       *
	       * @param {string} name CSS property name such as `topMargin`.
	       * @param {*} value CSS property value such as `10px`.
	       * @param {ReactDOMComponent} component
	       * @return {string} Normalized style value with dimensions applied.
	       */
	      function dangerousStyleValue(name, value, component) {
	        // Note that we've removed escapeTextForBrowser() calls here since the
	        // whole string will be escaped when the attribute is injected into
	        // the markup. If you provide unsafe user data here they can inject
	        // arbitrary CSS which may be problematic (I couldn't repro this):
	        // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	        // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	        // This is not an XSS hole but instead a potential CSS injection issue
	        // which has lead to a greater discussion about how we're going to
	        // trust URLs moving forward. See #2115901
	
	        var isEmpty = value == null || typeof value === 'boolean' || value === '';
	        if (isEmpty) {
	          return '';
	        }
	
	        var isNonNumeric = isNaN(value);
	        if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	          return '' + value; // cast to string
	        }
	
	        if (typeof value === 'string') {
	          if (false) {
	            // Allow '0' to pass through without warning. 0 is already special and
	            // doesn't require units, so we don't need to warn about it.
	            if (component && value !== '0') {
	              var owner = component._currentElement._owner;
	              var ownerName = owner ? owner.getName() : null;
	              if (ownerName && !styleWarnings[ownerName]) {
	                styleWarnings[ownerName] = {};
	              }
	              var warned = false;
	              if (ownerName) {
	                var warnings = styleWarnings[ownerName];
	                warned = warnings[name];
	                if (!warned) {
	                  warnings[name] = true;
	                }
	              }
	              if (!warned) {
	                "production" !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	              }
	            }
	          }
	          value = value.trim();
	        }
	        return value + 'px';
	      }
	
	      module.exports = dangerousStyleValue;
	    }, { "./CSSProperty": 13, "fbjs/lib/warning": 12 }], 23: [function (_dereq_, module, exports) {
	      /**
	       * Copyright (c) 2013-present, Facebook, Inc.
	       * All rights reserved.
	       *
	       * This source code is licensed under the BSD-style license found in the
	       * LICENSE file in the root directory of this source tree. An additional grant
	       * of patent rights can be found in the PATENTS file in the same directory.
	       *
	       * @providesModule reactProdInvariant
	       * 
	       */
	      'use strict';
	
	      /**
	       * WARNING: DO NOT manually require this module.
	       * This is a replacement for `invariant(...)` used by the error code system
	       * and will _only_ be required by the corresponding babel pass.
	       * It always throws.
	       */
	
	      function reactProdInvariant(code) {
	        var argCount = arguments.length - 1;
	
	        var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	        for (var argIdx = 0; argIdx < argCount; argIdx++) {
	          message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	        }
	
	        message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	        var error = new Error(message);
	        error.name = 'Invariant Violation';
	        error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	        throw error;
	      }
	
	      module.exports = reactProdInvariant;
	    }, {}] }, {}, [1])(1);
	});

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.default = clean;
	// Returns true for null, false, undefined and {}
	function isFalsy(value) {
	  return value === null || value === undefined || value === false || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && Object.keys(value).length === 0;
	}
	
	function cleanObject(object) {
	  if (isFalsy(object)) return null;
	  if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') return object;
	
	  var acc = {},
	      keys = Object.keys(object),
	      hasFalsy = false;
	  for (var i = 0; i < keys.length; i++) {
	    var value = object[keys[i]];
	    var filteredValue = clean(value);
	    if (filteredValue === null || filteredValue !== value) {
	      hasFalsy = true;
	    }
	    if (filteredValue !== null) {
	      acc[keys[i]] = filteredValue;
	    }
	  }
	  return Object.keys(acc).length === 0 ? null : hasFalsy ? acc : object;
	}
	
	function cleanArray(rules) {
	  var hasFalsy = false;
	  var filtered = [];
	  rules.forEach(function (rule) {
	    var filteredRule = clean(rule);
	    if (filteredRule === null || filteredRule !== rule) {
	      hasFalsy = true;
	    }
	    if (filteredRule !== null) {
	      filtered.push(filteredRule);
	    }
	  });
	  return filtered.length == 0 ? null : hasFalsy ? filtered : rules;
	}
	
	// Takes style array or object provided by user and clears all the falsy data 
	// If there is no styles left after filtration returns null
	function clean(input) {
	  return Array.isArray(input) ? cleanArray(input) : cleanObject(input);
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PluginSet = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.fallbacks = fallbacks;
	exports.prefixes = prefixes;
	exports.bug20fix = bug20fix;
	
	var _autoprefix = __webpack_require__(13);
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var isDev = function (x) {
	  return x === 'development' || !x;
	}(process.env.NODE_ENV);
	
	var PluginSet = exports.PluginSet = function () {
	  function PluginSet() {
	    _classCallCheck(this, PluginSet);
	
	    for (var _len = arguments.length, initial = Array(_len), _key = 0; _key < _len; _key++) {
	      initial[_key] = arguments[_key];
	    }
	
	    this.fns = initial || [];
	  }
	
	  _createClass(PluginSet, [{
	    key: 'add',
	    value: function add() {
	      var _this = this;
	
	      for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        fns[_key2] = arguments[_key2];
	      }
	
	      fns.forEach(function (fn) {
	        if (_this.fns.indexOf(fn) >= 0) {
	          if (isDev) {
	            console.warn('adding the same plugin again, ignoring'); //eslint-disable-line no-console
	          }
	        } else {
	          _this.fns = [fn].concat(_toConsumableArray(_this.fns));
	        }
	      });
	    }
	  }, {
	    key: 'remove',
	    value: function remove(fn) {
	      this.fns = this.fns.filter(function (x) {
	        return x !== fn;
	      });
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.fns = [];
	    }
	  }, {
	    key: 'transform',
	    value: function transform(o) {
	      return this.fns.reduce(function (o, fn) {
	        return fn(o);
	      }, o);
	    }
	  }]);
	
	  return PluginSet;
	}();
	
	function fallbacks(node) {
	  var hasArray = Object.keys(node.style).map(function (x) {
	    return Array.isArray(node.style[x]);
	  }).indexOf(true) >= 0;
	  if (hasArray) {
	    var _ret = function () {
	      var style = node.style;
	
	      var rest = _objectWithoutProperties(node, ['style']);
	
	      var flattened = Object.keys(style).reduce(function (o, key) {
	        o[key] = Array.isArray(style[key]) ? style[key].join('; ' + key + ': ') : style[key];
	        return o;
	      }, {});
	      // todo - 
	      // flatten arrays which haven't been flattened yet 
	      return {
	        v: _extends({ style: flattened }, rest)
	      };
	    }();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	  return node;
	}
	
	function prefixes(_ref) {
	  var style = _ref.style;
	
	  var rest = _objectWithoutProperties(_ref, ['style']);
	
	  return _extends({ style: (0, _autoprefix.autoprefix)(style) }, rest);
	}
	
	function bug20fix(_ref2) {
	  var selector = _ref2.selector;
	  var style = _ref2.style;
	
	  // https://github.com/threepointone/glamor/issues/20
	  // todo - only on chrome versions and server side   
	  return { selector: selector.replace(/\:hover/g, ':hover:nth-child(n)'), style: style };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	// forked from https://www.npmjs.com/package/auto-prefixer
	
	function capitalize(str) {
	  return str && str.charAt(0).toUpperCase() + str.substring(1);
	}
	
	function includes(obj, search) {
	  if (typeof obj === 'number') {
	    obj = obj.toString();
	  }
	  return obj.indexOf(search) !== -1;
	}
	
	function values(obj) {
	  return Object.keys(obj).map(function (key) {
	    return obj[key];
	  });
	}
	
	var webkitPrefix = 'Webkit';
	var mozPrefix = 'Moz';
	var msPrefix = 'ms';
	var oPrefix = 'o';
	
	var webkit = [webkitPrefix];
	var webkitO = [webkitPrefix, oPrefix];
	var moz = [mozPrefix];
	var ms = [msPrefix];
	
	var webkitMoz = [webkitPrefix, mozPrefix];
	var webkitMozO = [webkitPrefix, mozPrefix, oPrefix];
	var webkitMozMs = [webkitPrefix, mozPrefix, msPrefix];
	var webkitMs = [webkitPrefix, msPrefix];
	var allPrefixes = [webkitPrefix, msPrefix, mozPrefix, oPrefix];
	
	var neededRules = {
	  alignContent: webkit,
	  alignItems: webkit,
	  alignSelf: webkit,
	  animation: webkitMoz,
	  animationDelay: webkitMoz,
	  animationDirection: webkitMoz,
	  animationDuration: webkitMoz,
	  animationFillMode: webkitMoz,
	  animationIterationCount: webkitMoz,
	  animationName: webkitMoz,
	  animationPlayState: webkitMoz,
	  animationTimingFunction: webkitMoz,
	  appearance: webkitMoz,
	  backfaceVisibility: webkitMoz,
	  backgroundClip: webkit,
	  borderImage: webkitMozO,
	  borderImageSlice: webkitMozO,
	  boxShadow: webkitMozMs,
	  boxSizing: webkitMoz,
	  clipPath: webkit,
	  columns: webkitMoz,
	  cursor: webkitMoz,
	  flex: webkitMs, //new flex and 2012 specification , no support for old specification
	  flexBasis: webkitMs,
	  flexDirection: webkitMs,
	  flexFlow: webkitMs,
	  flexGrow: webkitMs,
	  flexShrink: webkitMs,
	  flexWrap: webkitMs,
	  fontSmoothing: webkitMoz,
	  justifyContent: webkitMoz,
	  order: webkitMoz,
	  perspective: webkitMoz,
	  perspectiveOrigin: webkitMoz,
	  transform: webkitMozMs,
	  transformOrigin: webkitMozMs,
	  transformOriginX: webkitMozMs,
	  transformOriginY: webkitMozMs,
	  transformOriginZ: webkitMozMs,
	  transformStyle: webkitMozMs,
	  transition: webkitMozMs,
	  transitionDelay: webkitMozMs,
	  transitionDuration: webkitMozMs,
	  transitionProperty: webkitMozMs,
	  transitionTimingFunction: webkitMozMs,
	  userSelect: webkitMozMs
	};
	
	var neededCssValues = {
	  calc: webkitMoz,
	  flex: webkitMs
	};
	
	var clientPrefix = function () {
	  if (typeof navigator === 'undefined') {
	    //in server rendering
	    return allPrefixes; //also default when not passing true to 'all vendors' explicitly
	  }
	  var sUsrAg = navigator.userAgent;
	
	  if (includes(sUsrAg, 'Chrome')) {
	    return webkit;
	  } else if (includes(sUsrAg, 'Safari')) {
	    return webkit;
	  } else if (includes(sUsrAg, 'Opera')) {
	    return webkitO;
	  } else if (includes(sUsrAg, 'Firefox')) {
	    return moz;
	  } else if (includes(sUsrAg, 'MSIE')) {
	    return ms;
	  }
	
	  return [];
	}();
	
	function checkAndAddPrefix(styleObj, key, val, allVendors) {
	  var oldFlex = true;
	
	  function valueWithPrefix(cssVal, prefix) {
	    return includes(val, cssVal) && (allVendors || includes(clientPrefix, prefix)) ? val.replace(cssVal, ['', prefix.toLowerCase(), cssVal].join('-')) : null;
	    //example return -> 'transition: -webkit-transition'
	  }
	
	  function createObjectOfValuesWithPrefixes(cssVal) {
	    return neededCssValues[cssVal].reduce(function (o, v) {
	      o[v.toLowerCase()] = valueWithPrefix(cssVal, v);
	      return o;
	    }, {});
	    //example return -> {webkit: -webkit-calc(10% - 1px), moz: -moz-calc(10% - 1px)}
	  }
	
	  function composePrefixedValues(objOfPrefixedValues) {
	    var composed = values(objOfPrefixedValues).filter(function (str) {
	      return str !== null;
	    }).map(function (str) {
	      return key + ':' + str;
	    }).join(';');
	
	    if (composed) {
	      styleObj[key] = styleObj[key] + ';' + composed;
	    }
	    //example do -> {display: "flex;display:-webkit-flex;display:-ms-flexbox"}
	  }
	
	  function valWithoutFlex() {
	    return val.replace('flex-', '').toLowerCase();
	  }
	
	  if (val === 'flex' && key === 'display') {
	
	    var flex = createObjectOfValuesWithPrefixes('flex');
	    if (flex.ms) {
	      flex.ms = flex.ms.replace('flex', 'flexbox');
	    } //special case
	
	    composePrefixedValues(flex);
	    //if(oldFlex){styleObj[key] = styleObj[key] + ';display:-webkit-box'; }
	    if (oldFlex) {
	      styleObj[key] = '-webkit-box;display:' + styleObj[key];
	    }
	
	    //display:flex is simple case, no need for other checks
	    return styleObj;
	  }
	
	  var allPrefixedCssValues = Object.keys(neededCssValues).filter(function (c) {
	    return c !== 'flex';
	  }).reduce(function (o, c) {
	    o[c] = createObjectOfValuesWithPrefixes(c);
	    return o;
	  }, {});
	  /*
	   example allPrefixedCssValues = {
	   calc: {
	   webkit: "translateX(-webkit-calc(10% - 10px))",
	   moz: "translateX(-moz-calc(10% - 10px))"
	   },
	   flex: {
	   ms: null,
	   webkit: null
	   }
	   };*/
	
	  //if(includes(val, 'gradient')){
	  //
	  //}
	
	  if (neededRules[key]) {
	
	    var prefixes = allVendors ? neededRules[key] : neededRules[key].filter(function (vendor) {
	      return includes(clientPrefix, vendor);
	    });
	
	    var prefixedProperties = prefixes.reduce(function (obj, prefix) {
	      var property = val;
	
	      //add valueWithPrefixes in their position and null the property
	      Object.keys(allPrefixedCssValues).forEach(function (cssKey) {
	        var cssVal = allPrefixedCssValues[cssKey];
	        Object.keys(cssVal).forEach(function (vendor) {
	          if (cssVal[vendor] && capitalize(prefix) === capitalize(vendor)) {
	            property = cssVal[vendor];
	            cssVal[vendor] = null;
	          }
	        });
	      });
	
	      obj[prefix + capitalize(key)] = property;
	      return obj;
	    }, {});
	
	    if (oldFlex) {
	      switch (key) {
	        case 'flexDirection':
	          if (includes(val, 'reverse')) {
	            prefixedProperties.WebkitBoxDirection = 'reverse';
	          } else {
	            prefixedProperties.WebkitBoxDirection = 'normal';
	          }
	          if (includes(val, 'row')) {
	            prefixedProperties.WebkitBoxOrient = prefixedProperties.boxOrient = 'horizontal';
	          } else if (includes(val, 'column')) {
	            prefixedProperties.WebkitBoxOrient = 'vertical';
	          }
	          break;
	        case 'alignSelf':
	          prefixedProperties.msFlexItemAlign = valWithoutFlex();break;
	        case 'alignItems':
	          prefixedProperties.WebkitBoxAlign = prefixedProperties.msFlexAlign = valWithoutFlex();break;
	        case 'alignContent':
	          if (val === 'spaceAround') {
	            prefixedProperties.msFlexLinePack = 'distribute';
	          } else if (val === 'spaceBetween') {
	            prefixedProperties.msFlexLinePack = 'justify';
	          } else {
	            prefixedProperties.msFlexLinePack = valWithoutFlex();
	          }
	          break;
	        case 'justifyContent':
	          if (val === 'spaceAround') {
	            prefixedProperties.msFlexPack = 'distribute';
	          } else if (val === 'spaceBetween') {
	            prefixedProperties.WebkitBoxPack = prefixedProperties.msFlexPack = 'justify';
	          } else {
	            prefixedProperties.WebkitBoxPack = prefixedProperties.msFlexPack = valWithoutFlex();
	          }
	          break;
	        case 'flexBasis':
	          prefixedProperties.msFlexPreferredSize = val;break;
	        case 'order':
	          prefixedProperties.msFlexOrder = '-moz-calc(' + val + ')'; //ugly hack to prevent react from adding 'px'
	          prefixedProperties.WebkitBoxOrdinalGroup = '-webkit-calc(' + (parseInt(val) + 1) + ')'; //this might not work for browsers who don't support calc
	          break;
	        case 'flexGrow':
	          prefixedProperties.WebkitBoxFlex = prefixedProperties.msFlexPositive = val;break;
	        case 'flexShrink':
	          prefixedProperties.msFlexNegative = val;break;
	        case 'flex':
	          prefixedProperties.WebkitBoxFlex = val;break;
	      }
	    }
	
	    Object.assign(styleObj, prefixedProperties);
	  }
	
	  //if valueWithPrefixes were not added before
	  Object.keys(allPrefixedCssValues).forEach(function (cssKey) {
	    composePrefixedValues(allPrefixedCssValues[cssKey]);
	  });
	  return styleObj;
	}
	
	function autoPrefixer(obj, allVendors) {
	  Object.keys(obj).forEach(function (key) {
	    return obj = checkAndAddPrefix(_extends({}, obj), key, obj[key], allVendors);
	  });
	  return obj;
	}
	
	function gate(objOrBool) {
	  var optionalBoolean = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	
	  if (typeof objOrBool === 'boolean') {
	    return function (obj) {
	      return autoPrefixer(obj, objOrBool);
	    };
	  }
	  if (!objOrBool) {
	    return {};
	  } else {
	    return autoPrefixer(objOrBool, optionalBoolean);
	  } // default: don't include all browsers
	}
	
	var autoprefix = exports.autoprefix = gate(true);

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = doHash;
	// murmurhash2 via https://gist.github.com/raycmorgan/588423
	
	function doHash(str, seed) {
	  var m = 0x5bd1e995;
	  var r = 24;
	  var h = seed ^ str.length;
	  var length = str.length;
	  var currentIndex = 0;
	
	  while (length >= 4) {
	    var k = UInt32(str, currentIndex);
	
	    k = Umul32(k, m);
	    k ^= k >>> r;
	    k = Umul32(k, m);
	
	    h = Umul32(h, m);
	    h ^= k;
	
	    currentIndex += 4;
	    length -= 4;
	  }
	
	  switch (length) {
	    case 3:
	      h ^= UInt16(str, currentIndex);
	      h ^= str.charCodeAt(currentIndex + 2) << 16;
	      h = Umul32(h, m);
	      break;
	
	    case 2:
	      h ^= UInt16(str, currentIndex);
	      h = Umul32(h, m);
	      break;
	
	    case 1:
	      h ^= str.charCodeAt(currentIndex);
	      h = Umul32(h, m);
	      break;
	  }
	
	  h ^= h >>> 13;
	  h = Umul32(h, m);
	  h ^= h >>> 15;
	
	  return h >>> 0;
	}
	
	function UInt32(str, pos) {
	  return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8) + (str.charCodeAt(pos++) << 16) + (str.charCodeAt(pos) << 24);
	}
	
	function UInt16(str, pos) {
	  return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);
	}
	
	function Umul32(n, m) {
	  n = n | 0;
	  m = m | 0;
	  var nlo = n & 0xffff;
	  var nhi = n >>> 16;
	  var res = nlo * m + ((nhi * m & 0xffff) << 16) | 0;
	  return res;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {  /* globals require, module */
	
	  'use strict';
	
	  /**
	   * Module dependencies.
	   */
	
	  var pathtoRegexp = __webpack_require__(16);
	
	  /**
	   * Module exports.
	   */
	
	  module.exports = page;
	
	  /**
	   * Detect click event
	   */
	  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';
	
	  /**
	   * To work properly with the URL
	   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
	   */
	
	  var location = ('undefined' !== typeof window) && (window.history.location || window.location);
	
	  /**
	   * Perform initial dispatch.
	   */
	
	  var dispatch = true;
	
	
	  /**
	   * Decode URL components (query string, pathname, hash).
	   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
	   */
	  var decodeURLComponents = true;
	
	  /**
	   * Base path.
	   */
	
	  var base = '';
	
	  /**
	   * Running flag.
	   */
	
	  var running;
	
	  /**
	   * HashBang option
	   */
	
	  var hashbang = false;
	
	  /**
	   * Previous context, for capturing
	   * page exit events.
	   */
	
	  var prevContext;
	
	  /**
	   * Register `path` with callback `fn()`,
	   * or route `path`, or redirection,
	   * or `page.start()`.
	   *
	   *   page(fn);
	   *   page('*', fn);
	   *   page('/user/:id', load, user);
	   *   page('/user/' + user.id, { some: 'thing' });
	   *   page('/user/' + user.id);
	   *   page('/from', '/to')
	   *   page();
	   *
	   * @param {string|!Function|!Object} path
	   * @param {Function=} fn
	   * @api public
	   */
	
	  function page(path, fn) {
	    // <callback>
	    if ('function' === typeof path) {
	      return page('*', path);
	    }
	
	    // route <path> to <callback ...>
	    if ('function' === typeof fn) {
	      var route = new Route(/** @type {string} */ (path));
	      for (var i = 1; i < arguments.length; ++i) {
	        page.callbacks.push(route.middleware(arguments[i]));
	      }
	      // show <path> with [state]
	    } else if ('string' === typeof path) {
	      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);
	      // start [options]
	    } else {
	      page.start(path);
	    }
	  }
	
	  /**
	   * Callback functions.
	   */
	
	  page.callbacks = [];
	  page.exits = [];
	
	  /**
	   * Current path being processed
	   * @type {string}
	   */
	  page.current = '';
	
	  /**
	   * Number of pages navigated to.
	   * @type {number}
	   *
	   *     page.len == 0;
	   *     page('/login');
	   *     page.len == 1;
	   */
	
	  page.len = 0;
	
	  /**
	   * Get or set basepath to `path`.
	   *
	   * @param {string} path
	   * @api public
	   */
	
	  page.base = function(path) {
	    if (0 === arguments.length) return base;
	    base = path;
	  };
	
	  /**
	   * Bind with the given `options`.
	   *
	   * Options:
	   *
	   *    - `click` bind to click events [true]
	   *    - `popstate` bind to popstate [true]
	   *    - `dispatch` perform initial dispatch [true]
	   *
	   * @param {Object} options
	   * @api public
	   */
	
	  page.start = function(options) {
	    options = options || {};
	    if (running) return;
	    running = true;
	    if (false === options.dispatch) dispatch = false;
	    if (false === options.decodeURLComponents) decodeURLComponents = false;
	    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
	    if (false !== options.click) {
	      document.addEventListener(clickEvent, onclick, false);
	    }
	    if (true === options.hashbang) hashbang = true;
	    if (!dispatch) return;
	    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
	    page.replace(url, null, true, dispatch);
	  };
	
	  /**
	   * Unbind click and popstate event handlers.
	   *
	   * @api public
	   */
	
	  page.stop = function() {
	    if (!running) return;
	    page.current = '';
	    page.len = 0;
	    running = false;
	    document.removeEventListener(clickEvent, onclick, false);
	    window.removeEventListener('popstate', onpopstate, false);
	  };
	
	  /**
	   * Show `path` with optional `state` object.
	   *
	   * @param {string} path
	   * @param {Object=} state
	   * @param {boolean=} dispatch
	   * @param {boolean=} push
	   * @return {!Context}
	   * @api public
	   */
	
	  page.show = function(path, state, dispatch, push) {
	    var ctx = new Context(path, state);
	    page.current = ctx.path;
	    if (false !== dispatch) page.dispatch(ctx);
	    if (false !== ctx.handled && false !== push) ctx.pushState();
	    return ctx;
	  };
	
	  /**
	   * Goes back in the history
	   * Back should always let the current route push state and then go back.
	   *
	   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
	   * @param {Object=} state
	   * @api public
	   */
	
	  page.back = function(path, state) {
	    if (page.len > 0) {
	      // this may need more testing to see if all browsers
	      // wait for the next tick to go back in history
	      history.back();
	      page.len--;
	    } else if (path) {
	      setTimeout(function() {
	        page.show(path, state);
	      });
	    }else{
	      setTimeout(function() {
	        page.show(base, state);
	      });
	    }
	  };
	
	
	  /**
	   * Register route to redirect from one path to other
	   * or just redirect to another route
	   *
	   * @param {string} from - if param 'to' is undefined redirects to 'from'
	   * @param {string=} to
	   * @api public
	   */
	  page.redirect = function(from, to) {
	    // Define route from a path to another
	    if ('string' === typeof from && 'string' === typeof to) {
	      page(from, function(e) {
	        setTimeout(function() {
	          page.replace(/** @type {!string} */ (to));
	        }, 0);
	      });
	    }
	
	    // Wait for the push state and replace it with another
	    if ('string' === typeof from && 'undefined' === typeof to) {
	      setTimeout(function() {
	        page.replace(from);
	      }, 0);
	    }
	  };
	
	  /**
	   * Replace `path` with optional `state` object.
	   *
	   * @param {string} path
	   * @param {Object=} state
	   * @param {boolean=} init
	   * @param {boolean=} dispatch
	   * @return {!Context}
	   * @api public
	   */
	
	
	  page.replace = function(path, state, init, dispatch) {
	    var ctx = new Context(path, state);
	    page.current = ctx.path;
	    ctx.init = init;
	    ctx.save(); // save before dispatching, which may redirect
	    if (false !== dispatch) page.dispatch(ctx);
	    return ctx;
	  };
	
	  /**
	   * Dispatch the given `ctx`.
	   *
	   * @param {Context} ctx
	   * @api private
	   */
	  page.dispatch = function(ctx) {
	    var prev = prevContext,
	      i = 0,
	      j = 0;
	
	    prevContext = ctx;
	
	    function nextExit() {
	      var fn = page.exits[j++];
	      if (!fn) return nextEnter();
	      fn(prev, nextExit);
	    }
	
	    function nextEnter() {
	      var fn = page.callbacks[i++];
	
	      if (ctx.path !== page.current) {
	        ctx.handled = false;
	        return;
	      }
	      if (!fn) return unhandled(ctx);
	      fn(ctx, nextEnter);
	    }
	
	    if (prev) {
	      nextExit();
	    } else {
	      nextEnter();
	    }
	  };
	
	  /**
	   * Unhandled `ctx`. When it's not the initial
	   * popstate then redirect. If you wish to handle
	   * 404s on your own use `page('*', callback)`.
	   *
	   * @param {Context} ctx
	   * @api private
	   */
	  function unhandled(ctx) {
	    if (ctx.handled) return;
	    var current;
	
	    if (hashbang) {
	      current = base + location.hash.replace('#!', '');
	    } else {
	      current = location.pathname + location.search;
	    }
	
	    if (current === ctx.canonicalPath) return;
	    page.stop();
	    ctx.handled = false;
	    location.href = ctx.canonicalPath;
	  }
	
	  /**
	   * Register an exit route on `path` with
	   * callback `fn()`, which will be called
	   * on the previous context when a new
	   * page is visited.
	   */
	  page.exit = function(path, fn) {
	    if (typeof path === 'function') {
	      return page.exit('*', path);
	    }
	
	    var route = new Route(path);
	    for (var i = 1; i < arguments.length; ++i) {
	      page.exits.push(route.middleware(arguments[i]));
	    }
	  };
	
	  /**
	   * Remove URL encoding from the given `str`.
	   * Accommodates whitespace in both x-www-form-urlencoded
	   * and regular percent-encoded form.
	   *
	   * @param {string} val - URL component to decode
	   */
	  function decodeURLEncodedURIComponent(val) {
	    if (typeof val !== 'string') { return val; }
	    return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
	  }
	
	  /**
	   * Initialize a new "request" `Context`
	   * with the given `path` and optional initial `state`.
	   *
	   * @constructor
	   * @param {string} path
	   * @param {Object=} state
	   * @api public
	   */
	
	  function Context(path, state) {
	    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;
	    var i = path.indexOf('?');
	
	    this.canonicalPath = path;
	    this.path = path.replace(base, '') || '/';
	    if (hashbang) this.path = this.path.replace('#!', '') || '/';
	
	    this.title = document.title;
	    this.state = state || {};
	    this.state.path = path;
	    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
	    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
	    this.params = {};
	
	    // fragment
	    this.hash = '';
	    if (!hashbang) {
	      if (!~this.path.indexOf('#')) return;
	      var parts = this.path.split('#');
	      this.path = parts[0];
	      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
	      this.querystring = this.querystring.split('#')[0];
	    }
	  }
	
	  /**
	   * Expose `Context`.
	   */
	
	  page.Context = Context;
	
	  /**
	   * Push state.
	   *
	   * @api private
	   */
	
	  Context.prototype.pushState = function() {
	    page.len++;
	    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
	  };
	
	  /**
	   * Save the context state.
	   *
	   * @api public
	   */
	
	  Context.prototype.save = function() {
	    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
	  };
	
	  /**
	   * Initialize `Route` with the given HTTP `path`,
	   * and an array of `callbacks` and `options`.
	   *
	   * Options:
	   *
	   *   - `sensitive`    enable case-sensitive routes
	   *   - `strict`       enable strict matching for trailing slashes
	   *
	   * @constructor
	   * @param {string} path
	   * @param {Object=} options
	   * @api private
	   */
	
	  function Route(path, options) {
	    options = options || {};
	    this.path = (path === '*') ? '(.*)' : path;
	    this.method = 'GET';
	    this.regexp = pathtoRegexp(this.path,
	      this.keys = [],
	      options);
	  }
	
	  /**
	   * Expose `Route`.
	   */
	
	  page.Route = Route;
	
	  /**
	   * Return route middleware with
	   * the given callback `fn()`.
	   *
	   * @param {Function} fn
	   * @return {Function}
	   * @api public
	   */
	
	  Route.prototype.middleware = function(fn) {
	    var self = this;
	    return function(ctx, next) {
	      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
	      next();
	    };
	  };
	
	  /**
	   * Check if this route matches `path`, if so
	   * populate `params`.
	   *
	   * @param {string} path
	   * @param {Object} params
	   * @return {boolean}
	   * @api private
	   */
	
	  Route.prototype.match = function(path, params) {
	    var keys = this.keys,
	      qsIndex = path.indexOf('?'),
	      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
	      m = this.regexp.exec(decodeURIComponent(pathname));
	
	    if (!m) return false;
	
	    for (var i = 1, len = m.length; i < len; ++i) {
	      var key = keys[i - 1];
	      var val = decodeURLEncodedURIComponent(m[i]);
	      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
	        params[key.name] = val;
	      }
	    }
	
	    return true;
	  };
	
	
	  /**
	   * Handle "populate" events.
	   */
	
	  var onpopstate = (function () {
	    var loaded = false;
	    if ('undefined' === typeof window) {
	      return;
	    }
	    if (document.readyState === 'complete') {
	      loaded = true;
	    } else {
	      window.addEventListener('load', function() {
	        setTimeout(function() {
	          loaded = true;
	        }, 0);
	      });
	    }
	    return function onpopstate(e) {
	      if (!loaded) return;
	      if (e.state) {
	        var path = e.state.path;
	        page.replace(path, e.state);
	      } else {
	        page.show(location.pathname + location.hash, undefined, undefined, false);
	      }
	    };
	  })();
	  /**
	   * Handle "click" events.
	   */
	
	  function onclick(e) {
	
	    if (1 !== which(e)) return;
	
	    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
	    if (e.defaultPrevented) return;
	
	
	
	    // ensure link
	    // use shadow dom when available
	    var el = e.path ? e.path[0] : e.target;
	    while (el && 'A' !== el.nodeName) el = el.parentNode;
	    if (!el || 'A' !== el.nodeName) return;
	
	
	
	    // Ignore if tag has
	    // 1. "download" attribute
	    // 2. rel="external" attribute
	    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;
	
	    // ensure non-hash for the same path
	    var link = el.getAttribute('href');
	    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;
	
	
	
	    // Check for mailto: in the href
	    if (link && link.indexOf('mailto:') > -1) return;
	
	    // check target
	    if (el.target) return;
	
	    // x-origin
	    if (!sameOrigin(el.href)) return;
	
	
	
	    // rebuild path
	    var path = el.pathname + el.search + (el.hash || '');
	
	    // strip leading "/[drive letter]:" on NW.js on Windows
	    if (typeof process !== 'undefined' && path.match(/^\/[a-zA-Z]:\//)) {
	      path = path.replace(/^\/[a-zA-Z]:\//, '/');
	    }
	
	    // same page
	    var orig = path;
	
	    if (path.indexOf(base) === 0) {
	      path = path.substr(base.length);
	    }
	
	    if (hashbang) path = path.replace('#!', '');
	
	    if (base && orig === path) return;
	
	    e.preventDefault();
	    page.show(orig);
	  }
	
	  /**
	   * Event button.
	   */
	
	  function which(e) {
	    e = e || window.event;
	    return null === e.which ? e.button : e.which;
	  }
	
	  /**
	   * Check if `href` is the same origin.
	   */
	
	  function sameOrigin(href) {
	    var origin = location.protocol + '//' + location.hostname;
	    if (location.port) origin += ':' + location.port;
	    return (href && (0 === href.indexOf(origin)));
	  }
	
	  page.sameOrigin = sameOrigin;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var isarray = __webpack_require__(17)
	
	/**
	 * Expose `pathToRegexp`.
	 */
	module.exports = pathToRegexp
	module.exports.parse = parse
	module.exports.compile = compile
	module.exports.tokensToFunction = tokensToFunction
	module.exports.tokensToRegExp = tokensToRegExp
	
	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
	  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
	  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
	].join('|'), 'g')
	
	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {String} str
	 * @return {Array}
	 */
	function parse (str) {
	  var tokens = []
	  var key = 0
	  var index = 0
	  var path = ''
	  var res
	
	  while ((res = PATH_REGEXP.exec(str)) != null) {
	    var m = res[0]
	    var escaped = res[1]
	    var offset = res.index
	    path += str.slice(index, offset)
	    index = offset + m.length
	
	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1]
	      continue
	    }
	
	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path)
	      path = ''
	    }
	
	    var prefix = res[2]
	    var name = res[3]
	    var capture = res[4]
	    var group = res[5]
	    var suffix = res[6]
	    var asterisk = res[7]
	
	    var repeat = suffix === '+' || suffix === '*'
	    var optional = suffix === '?' || suffix === '*'
	    var delimiter = prefix || '/'
	    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
	
	    tokens.push({
	      name: name || key++,
	      prefix: prefix || '',
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      pattern: escapeGroup(pattern)
	    })
	  }
	
	  // Match any characters still remaining.
	  if (index < str.length) {
	    path += str.substr(index)
	  }
	
	  // If the path exists, push it onto the end.
	  if (path) {
	    tokens.push(path)
	  }
	
	  return tokens
	}
	
	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {String}   str
	 * @return {Function}
	 */
	function compile (str) {
	  return tokensToFunction(parse(str))
	}
	
	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length)
	
	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^' + tokens[i].pattern + '$')
	    }
	  }
	
	  return function (obj) {
	    var path = ''
	    var data = obj || {}
	
	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i]
	
	      if (typeof token === 'string') {
	        path += token
	
	        continue
	      }
	
	      var value = data[token.name]
	      var segment
	
	      if (value == null) {
	        if (token.optional) {
	          continue
	        } else {
	          throw new TypeError('Expected "' + token.name + '" to be defined')
	        }
	      }
	
	      if (isarray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
	        }
	
	        if (value.length === 0) {
	          if (token.optional) {
	            continue
	          } else {
	            throw new TypeError('Expected "' + token.name + '" to not be empty')
	          }
	        }
	
	        for (var j = 0; j < value.length; j++) {
	          segment = encodeURIComponent(value[j])
	
	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	          }
	
	          path += (j === 0 ? token.prefix : token.delimiter) + segment
	        }
	
	        continue
	      }
	
	      segment = encodeURIComponent(value)
	
	      if (!matches[i].test(segment)) {
	        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	      }
	
	      path += token.prefix + segment
	    }
	
	    return path
	  }
	}
	
	/**
	 * Escape a regular expression string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
	}
	
	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {String} group
	 * @return {String}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$\/()])/g, '\\$1')
	}
	
	/**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {RegExp} re
	 * @param  {Array}  keys
	 * @return {RegExp}
	 */
	function attachKeys (re, keys) {
	  re.keys = keys
	  return re
	}
	
	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {String}
	 */
	function flags (options) {
	  return options.sensitive ? '' : 'i'
	}
	
	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {RegExp} path
	 * @param  {Array}  keys
	 * @return {RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g)
	
	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        pattern: null
	      })
	    }
	  }
	
	  return attachKeys(path, keys)
	}
	
	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {Array}  path
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = []
	
	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source)
	  }
	
	  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
	
	  return attachKeys(regexp, keys)
	}
	
	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {String} path
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  var tokens = parse(path)
	  var re = tokensToRegExp(tokens, options)
	
	  // Attach keys back to the regexp.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] !== 'string') {
	      keys.push(tokens[i])
	    }
	  }
	
	  return attachKeys(re, keys)
	}
	
	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {Array}  tokens
	 * @param  {Array}  keys
	 * @param  {Object} options
	 * @return {RegExp}
	 */
	function tokensToRegExp (tokens, options) {
	  options = options || {}
	
	  var strict = options.strict
	  var end = options.end !== false
	  var route = ''
	  var lastToken = tokens[tokens.length - 1]
	  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
	
	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i]
	
	    if (typeof token === 'string') {
	      route += escapeString(token)
	    } else {
	      var prefix = escapeString(token.prefix)
	      var capture = token.pattern
	
	      if (token.repeat) {
	        capture += '(?:' + prefix + capture + ')*'
	      }
	
	      if (token.optional) {
	        if (prefix) {
	          capture = '(?:' + prefix + '(' + capture + '))?'
	        } else {
	          capture = '(' + capture + ')?'
	        }
	      } else {
	        capture = prefix + '(' + capture + ')'
	      }
	
	      route += capture
	    }
	  }
	
	  // In non-strict mode we allow a slash at the end of match. If the path to
	  // match already ends with a slash, we remove it for consistency. The slash
	  // is valid at the end of a path match, not in the middle. This is important
	  // in non-ending mode, where "/test/" shouldn't match "/test//route".
	  if (!strict) {
	    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
	  }
	
	  if (end) {
	    route += '$'
	  } else {
	    // In non-ending mode, we need the capturing groups to match as much as
	    // possible by using a positive lookahead to the end or next path segment.
	    route += strict && endsWithSlash ? '' : '(?=\\/|$)'
	  }
	
	  return new RegExp('^' + route, flags(options))
	}
	
	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(String|RegExp|Array)} path
	 * @param  {Array}                 [keys]
	 * @param  {Object}                [options]
	 * @return {RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  keys = keys || []
	
	  if (!isarray(keys)) {
	    options = keys
	    keys = []
	  } else if (!options) {
	    options = {}
	  }
	
	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, keys, options)
	  }
	
	  if (isarray(path)) {
	    return arrayToRegexp(path, keys, options)
	  }
	
	  return stringToRegexp(path, keys, options)
	}


/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(19)();
	// imports
	
	
	// module
	exports.push([module.id, "/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*=\"language-\"],\n\tpre[class*=\"language-\"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #a67f59;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n", ""]);
	
	// exports


/***/ },
/* 19 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 20 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/* **********************************************
	     Begin prism-core.js
	********************************************** */
	
	var _self = (typeof window !== 'undefined')
		? window   // if in browser
		: (
			(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
		);
	
	/**
	 * Prism: Lightweight, robust, elegant syntax highlighting
	 * MIT license http://www.opensource.org/licenses/mit-license.php/
	 * @author Lea Verou http://lea.verou.me
	 */
	
	var Prism = (function(){
	
	// Private helper vars
	var lang = /\blang(?:uage)?-(\w+)\b/i;
	var uniqueId = 0;
	
	var _ = _self.Prism = {
		util: {
			encode: function (tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
				} else if (_.util.type(tokens) === 'Array') {
					return tokens.map(_.util.encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},
	
			type: function (o) {
				return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
			},
	
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},
	
			// Deep clone a language definition (e.g. to extend it)
			clone: function (o) {
				var type = _.util.type(o);
	
				switch (type) {
					case 'Object':
						var clone = {};
	
						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = _.util.clone(o[key]);
							}
						}
	
						return clone;
	
					case 'Array':
						// Check for existence for IE8
						return o.map && o.map(function(v) { return _.util.clone(v); });
				}
	
				return o;
			}
		},
	
		languages: {
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);
	
				for (var key in redef) {
					lang[key] = redef[key];
				}
	
				return lang;
			},
	
			/**
			 * Insert a token before another token in a language literal
			 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
			 * we cannot just provide an object, we need anobject and a key.
			 * @param inside The key (or language id) of the parent
			 * @param before The key to insert before. If not provided, the function appends instead.
			 * @param insert Object with the key/value pairs to insert
			 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || _.languages;
				var grammar = root[inside];
	
				if (arguments.length == 2) {
					insert = arguments[1];
	
					for (var newToken in insert) {
						if (insert.hasOwnProperty(newToken)) {
							grammar[newToken] = insert[newToken];
						}
					}
	
					return grammar;
				}
	
				var ret = {};
	
				for (var token in grammar) {
	
					if (grammar.hasOwnProperty(token)) {
	
						if (token == before) {
	
							for (var newToken in insert) {
	
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}
	
						ret[token] = grammar[token];
					}
				}
	
				// Update references in other language definitions
				_.languages.DFS(_.languages, function(key, value) {
					if (value === root[inside] && key != inside) {
						this[key] = ret;
					}
				});
	
				return root[inside] = ret;
			},
	
			// Traverse a language definition with Depth First Search
			DFS: function(o, callback, type, visited) {
				visited = visited || {};
				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);
	
						if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, null, visited);
						}
						else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, i, visited);
						}
					}
				}
			}
		},
		plugins: {},
	
		highlightAll: function(async, callback) {
			var env = {
				callback: callback,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};
	
			_.hooks.run("before-highlightall", env);
	
			var elements = env.elements || document.querySelectorAll(env.selector);
	
			for (var i=0, element; element = elements[i++];) {
				_.highlightElement(element, async === true, env.callback);
			}
		},
	
		highlightElement: function(element, async, callback) {
			// Find language
			var language, grammar, parent = element;
	
			while (parent && !lang.test(parent.className)) {
				parent = parent.parentNode;
			}
	
			if (parent) {
				language = (parent.className.match(lang) || [,''])[1].toLowerCase();
				grammar = _.languages[language];
			}
	
			// Set language on the element, if not present
			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
	
			// Set language on the parent, for styling
			parent = element.parentNode;
	
			if (/pre/i.test(parent.nodeName)) {
				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
			}
	
			var code = element.textContent;
	
			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};
	
			_.hooks.run('before-sanity-check', env);
	
			if (!env.code || !env.grammar) {
				_.hooks.run('complete', env);
				return;
			}
	
			_.hooks.run('before-highlight', env);
	
			if (async && _self.Worker) {
				var worker = new Worker(_.filename);
	
				worker.onmessage = function(evt) {
					env.highlightedCode = evt.data;
	
					_.hooks.run('before-insert', env);
	
					env.element.innerHTML = env.highlightedCode;
	
					callback && callback.call(env.element);
					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
				};
	
				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			}
			else {
				env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
	
				_.hooks.run('before-insert', env);
	
				env.element.innerHTML = env.highlightedCode;
	
				callback && callback.call(element);
	
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			}
		},
	
		highlight: function (text, grammar, language) {
			var tokens = _.tokenize(text, grammar);
			return Token.stringify(_.util.encode(tokens), language);
		},
	
		tokenize: function(text, grammar, language) {
			var Token = _.Token;
	
			var strarr = [text];
	
			var rest = grammar.rest;
	
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}
	
				delete grammar.rest;
			}
	
			tokenloop: for (var token in grammar) {
				if(!grammar.hasOwnProperty(token) || !grammar[token]) {
					continue;
				}
	
				var patterns = grammar[token];
				patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];
	
				for (var j = 0; j < patterns.length; ++j) {
					var pattern = patterns[j],
						inside = pattern.inside,
						lookbehind = !!pattern.lookbehind,
						greedy = !!pattern.greedy,
						lookbehindLength = 0,
						alias = pattern.alias;
	
					pattern = pattern.pattern || pattern;
	
					for (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop
	
						var str = strarr[i];
	
						if (strarr.length > text.length) {
							// Something went terribly wrong, ABORT, ABORT!
							break tokenloop;
						}
	
						if (str instanceof Token) {
							continue;
						}
	
						pattern.lastIndex = 0;
	
						var match = pattern.exec(str),
						    delNum = 1;
	
						// Greedy patterns can override/remove up to two previously matched tokens
						if (!match && greedy && i != strarr.length - 1) {
							// Reconstruct the original text using the next two tokens
							var nextToken = strarr[i + 1].matchedStr || strarr[i + 1],
							    combStr = str + nextToken;
	
							if (i < strarr.length - 2) {
								combStr += strarr[i + 2].matchedStr || strarr[i + 2];
							}
	
							// Try the pattern again on the reconstructed text
							pattern.lastIndex = 0;
							match = pattern.exec(combStr);
							if (!match) {
								continue;
							}
	
							var from = match.index + (lookbehind ? match[1].length : 0);
							// To be a valid candidate, the new match has to start inside of str
							if (from >= str.length) {
								continue;
							}
							var to = match.index + match[0].length,
							    len = str.length + nextToken.length;
	
							// Number of tokens to delete and replace with the new match
							delNum = 3;
	
							if (to <= len) {
								if (strarr[i + 1].greedy) {
									continue;
								}
								delNum = 2;
								combStr = combStr.slice(0, len);
							}
							str = combStr;
						}
	
						if (!match) {
							continue;
						}
	
						if(lookbehind) {
							lookbehindLength = match[1].length;
						}
	
						var from = match.index + lookbehindLength,
						    match = match[0].slice(lookbehindLength),
						    to = from + match.length,
						    before = str.slice(0, from),
						    after = str.slice(to);
	
						var args = [i, delNum];
	
						if (before) {
							args.push(before);
						}
	
						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);
	
						args.push(wrapped);
	
						if (after) {
							args.push(after);
						}
	
						Array.prototype.splice.apply(strarr, args);
					}
				}
			}
	
			return strarr;
		},
	
		hooks: {
			all: {},
	
			add: function (name, callback) {
				var hooks = _.hooks.all;
	
				hooks[name] = hooks[name] || [];
	
				hooks[name].push(callback);
			},
	
			run: function (name, env) {
				var callbacks = _.hooks.all[name];
	
				if (!callbacks || !callbacks.length) {
					return;
				}
	
				for (var i=0, callback; callback = callbacks[i++];) {
					callback(env);
				}
			}
		}
	};
	
	var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
		this.type = type;
		this.content = content;
		this.alias = alias;
		// Copy of the full string this token was created from
		this.matchedStr = matchedStr || null;
		this.greedy = !!greedy;
	};
	
	Token.stringify = function(o, language, parent) {
		if (typeof o == 'string') {
			return o;
		}
	
		if (_.util.type(o) === 'Array') {
			return o.map(function(element) {
				return Token.stringify(element, language, o);
			}).join('');
		}
	
		var env = {
			type: o.type,
			content: Token.stringify(o.content, language, parent),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language,
			parent: parent
		};
	
		if (env.type == 'comment') {
			env.attributes['spellcheck'] = 'true';
		}
	
		if (o.alias) {
			var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
			Array.prototype.push.apply(env.classes, aliases);
		}
	
		_.hooks.run('wrap', env);
	
		var attributes = '';
	
		for (var name in env.attributes) {
			attributes += (attributes ? ' ' : '') + name + '="' + (env.attributes[name] || '') + '"';
		}
	
		return '<' + env.tag + ' class="' + env.classes.join(' ') + '" ' + attributes + '>' + env.content + '</' + env.tag + '>';
	
	};
	
	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _self.Prism;
		}
	 	// In worker
		_self.addEventListener('message', function(evt) {
			var message = JSON.parse(evt.data),
			    lang = message.language,
			    code = message.code,
			    immediateClose = message.immediateClose;
	
			_self.postMessage(_.highlight(code, _.languages[lang], lang));
			if (immediateClose) {
				_self.close();
			}
		}, false);
	
		return _self.Prism;
	}
	
	//Get current script and highlight
	var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
	
	if (script) {
		_.filename = script.src;
	
		if (document.addEventListener && !script.hasAttribute('data-manual')) {
			if(document.readyState !== "loading") {
				requestAnimationFrame(_.highlightAll, 0);
			}
			else {
				document.addEventListener('DOMContentLoaded', _.highlightAll);
			}
		}
	}
	
	return _self.Prism;
	
	})();
	
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Prism;
	}
	
	// hack for components to work correctly in node.js
	if (typeof global !== 'undefined') {
		global.Prism = Prism;
	}
	
	
	/* **********************************************
	     Begin prism-markup.js
	********************************************** */
	
	Prism.languages.markup = {
		'comment': /<!--[\w\W]*?-->/,
		'prolog': /<\?[\w\W]+?\?>/,
		'doctype': /<!DOCTYPE[\w\W]+?>/,
		'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
		'tag': {
			pattern: /<\/?(?!\d)[^\s>\/=.$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
			inside: {
				'tag': {
					pattern: /^<\/?[^\s>\/]+/i,
					inside: {
						'punctuation': /^<\/?/,
						'namespace': /^[^\s>\/:]+:/
					}
				},
				'attr-value': {
					pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
					inside: {
						'punctuation': /[=>"']/
					}
				},
				'punctuation': /\/?>/,
				'attr-name': {
					pattern: /[^\s>\/]+/,
					inside: {
						'namespace': /^[^\s>\/:]+:/
					}
				}
	
			}
		},
		'entity': /&#?[\da-z]{1,8};/i
	};
	
	// Plugin to make entity title show the real entity, idea by Roman Komarov
	Prism.hooks.add('wrap', function(env) {
	
		if (env.type === 'entity') {
			env.attributes['title'] = env.content.replace(/&amp;/, '&');
		}
	});
	
	Prism.languages.xml = Prism.languages.markup;
	Prism.languages.html = Prism.languages.markup;
	Prism.languages.mathml = Prism.languages.markup;
	Prism.languages.svg = Prism.languages.markup;
	
	
	/* **********************************************
	     Begin prism-css.js
	********************************************** */
	
	Prism.languages.css = {
		'comment': /\/\*[\w\W]*?\*\//,
		'atrule': {
			pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
			inside: {
				'rule': /@[\w-]+/
				// See rest below
			}
		},
		'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
		'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
		'string': /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		'property': /(\b|\B)[\w-]+(?=\s*:)/i,
		'important': /\B!important\b/i,
		'function': /[-a-z0-9]+(?=\()/i,
		'punctuation': /[(){};:]/
	};
	
	Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'style': {
				pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
				lookbehind: true,
				inside: Prism.languages.css,
				alias: 'language-css'
			}
		});
		
		Prism.languages.insertBefore('inside', 'attr-value', {
			'style-attr': {
				pattern: /\s*style=("|').*?\1/i,
				inside: {
					'attr-name': {
						pattern: /^\s*style/i,
						inside: Prism.languages.markup.tag.inside
					},
					'punctuation': /^\s*=\s*['"]|['"]\s*$/,
					'attr-value': {
						pattern: /.+/i,
						inside: Prism.languages.css
					}
				},
				alias: 'language-css'
			}
		}, Prism.languages.markup.tag);
	}
	
	/* **********************************************
	     Begin prism-clike.js
	********************************************** */
	
	Prism.languages.clike = {
		'comment': [
			{
				pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
				lookbehind: true
			},
			{
				pattern: /(^|[^\\:])\/\/.*/,
				lookbehind: true
			}
		],
		'string': {
			pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		'class-name': {
			pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
			lookbehind: true,
			inside: {
				punctuation: /(\.|\\)/
			}
		},
		'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
		'boolean': /\b(true|false)\b/,
		'function': /[a-z0-9_]+(?=\()/i,
		'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
		'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
		'punctuation': /[{}[\];(),.:]/
	};
	
	
	/* **********************************************
	     Begin prism-javascript.js
	********************************************** */
	
	Prism.languages.javascript = Prism.languages.extend('clike', {
		'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
		'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
		// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
		'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i
	});
	
	Prism.languages.insertBefore('javascript', 'keyword', {
		'regex': {
			pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
			lookbehind: true,
			greedy: true
		}
	});
	
	Prism.languages.insertBefore('javascript', 'string', {
		'template-string': {
			pattern: /`(?:\\\\|\\?[^\\])*?`/,
			greedy: true,
			inside: {
				'interpolation': {
					pattern: /\$\{[^}]+\}/,
					inside: {
						'interpolation-punctuation': {
							pattern: /^\$\{|\}$/,
							alias: 'punctuation'
						},
						rest: Prism.languages.javascript
					}
				},
				'string': /[\s\S]+/
			}
		}
	});
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'script': {
				pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
				lookbehind: true,
				inside: Prism.languages.javascript,
				alias: 'language-javascript'
			}
		});
	}
	
	Prism.languages.js = Prism.languages.javascript;
	
	/* **********************************************
	     Begin prism-file-highlight.js
	********************************************** */
	
	(function () {
		if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
			return;
		}
	
		self.Prism.fileHighlight = function() {
	
			var Extensions = {
				'js': 'javascript',
				'py': 'python',
				'rb': 'ruby',
				'ps1': 'powershell',
				'psm1': 'powershell',
				'sh': 'bash',
				'bat': 'batch',
				'h': 'c',
				'tex': 'latex'
			};
	
			if(Array.prototype.forEach) { // Check to prevent error in IE8
				Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
					var src = pre.getAttribute('data-src');
	
					var language, parent = pre;
					var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
					while (parent && !lang.test(parent.className)) {
						parent = parent.parentNode;
					}
	
					if (parent) {
						language = (pre.className.match(lang) || [, ''])[1];
					}
	
					if (!language) {
						var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
						language = Extensions[extension] || extension;
					}
	
					var code = document.createElement('code');
					code.className = 'language-' + language;
	
					pre.textContent = '';
	
					code.textContent = 'Loading…';
	
					pre.appendChild(code);
	
					var xhr = new XMLHttpRequest();
	
					xhr.open('GET', src, true);
	
					xhr.onreadystatechange = function () {
						if (xhr.readyState == 4) {
	
							if (xhr.status < 400 && xhr.responseText) {
								code.textContent = xhr.responseText;
	
								Prism.highlightElement(code);
							}
							else if (xhr.status >= 400) {
								code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
							}
							else {
								code.textContent = '✖ Error: File does not exist or is empty';
							}
						}
					};
	
					xhr.send(null);
				});
			}
	
		};
	
		document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);
	
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Tab = undefined;
	
	var _skatejs = __webpack_require__(3);
	
	var _classnames = __webpack_require__(22);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _index = __webpack_require__(23);
	
	var _index2 = _interopRequireDefault(_index);
	
	var _tab = __webpack_require__(24);
	
	var _tab2 = _interopRequireDefault(_tab);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function onTabsChanged(elem) {
	  return function () {
	    return elem.tabs = [].concat(_toConsumableArray(elem.children));
	  };
	}
	
	function selectTab(tabs, tab) {
	  return function (e) {
	    tabs.forEach(function (cur) {
	      return cur.selected = cur === tab;
	    });
	    e.preventDefault();
	  };
	}
	
	exports.default = (0, _skatejs.define)('sk-tabs', {
	  props: {
	    tabs: _skatejs.prop.array()
	  },
	  updated: function updated(elem, prev) {
	    if (_skatejs.Component.updated(elem, prev)) {
	      return (0, _skatejs.emit)(elem, 'tab-changed', { detail: elem.selected });
	    }
	  },
	  render: function render(elem) {
	    return (0, _skatejs.h)(
	      'div',
	      null,
	      (0, _skatejs.h)(
	        'style',
	        null,
	        _index2.default.toString()
	      ),
	      (0, _skatejs.h)(
	        'div',
	        { 'class': _index2.default.locals.tabs },
	        elem.tabs.map(function (tab) {
	          var _cx;
	
	          return (0, _skatejs.h)(
	            'div',
	            { 'class': (0, _classnames2.default)((_cx = {}, _defineProperty(_cx, _index2.default.locals.tab, true), _defineProperty(_cx, _index2.default.locals.selected, tab.selected), _cx)) },
	            (0, _skatejs.h)(
	              'a',
	              { href: '#' + tab.name, 'on-click': selectTab(elem.tabs, tab) },
	              tab.name
	            )
	          );
	        })
	      ),
	      (0, _skatejs.h)('slot', { 'on-slotchange': onTabsChanged(elem) })
	    );
	  }
	});
	exports.Tab = _tab2.default;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(19)();
	// imports
	
	
	// module
	exports.push([module.id, ":host {\n  display: block;\n}\n\n._2Lx4fB9RrtyJZEybizTry_ {\n  background-color: #DAD6CE;\n}\n\n._3jX3hCKqKj9o6D_5Kx_JBv {\n  display: inline-block;\n}\n\n._3jX3hCKqKj9o6D_5Kx_JBv a {\n  color: #333;\n  display: inline-block;\n  font-size: 18px;\n  font-weight: 200;\n  padding: 20px;\n  text-decoration: none;\n}\n\n._3jX3hCKqKj9o6D_5Kx_JBv._1UoOCaJGOGhObV5161qk5M {\n  background-color: #F1EDE4;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"tabs": "_2Lx4fB9RrtyJZEybizTry_",
		"tabs": "_2Lx4fB9RrtyJZEybizTry_",
		"tab": "_3jX3hCKqKj9o6D_5Kx_JBv",
		"tab": "_3jX3hCKqKj9o6D_5Kx_JBv",
		"selected": "_1UoOCaJGOGhObV5161qk5M",
		"selected": "_1UoOCaJGOGhObV5161qk5M"
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _skatejs = __webpack_require__(3);
	
	var _classnames = __webpack_require__(22);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _tab = __webpack_require__(25);
	
	var _tab2 = _interopRequireDefault(_tab);
	
	var _debounce = __webpack_require__(26);
	
	var _debounce2 = _interopRequireDefault(_debounce);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function emitSlotChange(elem) {
	  if (!elem.__debouncedSlotChangeEvent) {
	    elem.__debouncedSlotChangeEvent = (0, _debounce2.default)(_skatejs.emit.bind(null, elem, 'slotchange'), 0);
	  }
	  return elem.__debouncedSlotChangeEvent();
	}
	
	exports.default = (0, _skatejs.define)('sk-tabs-tab', {
	  props: {
	    name: _skatejs.prop.string({ attribute: true }),
	    selected: _skatejs.prop.boolean({ attribute: true })
	  },
	  attached: function attached(elem) {
	    emitSlotChange(elem);
	  },
	  detached: function detached(elem) {
	    emitSlotChange(elem);
	  },
	  updated: function updated(elem, prev) {
	    emitSlotChange(elem);
	    return _skatejs.Component.updated(elem, prev);
	  },
	  render: function render(elem) {
	    var _cx;
	
	    return (0, _skatejs.h)(
	      'div',
	      { 'class': (0, _classnames2.default)((_cx = {}, _defineProperty(_cx, _tab2.default.locals.pane, true), _defineProperty(_cx, _tab2.default.locals.selected, elem.selected), _cx)) },
	      (0, _skatejs.h)(
	        'style',
	        null,
	        _tab2.default.toString()
	      ),
	      (0, _skatejs.h)('slot', null)
	    );
	  }
	});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(19)();
	// imports
	
	
	// module
	exports.push([module.id, ":host {\n  display: block;\n}\n\n._3WkQLUyd_5sA_re7EzYvMx {\n  background-color: #F1EDE4;\n  display: none;\n  margin: 0;\n  overflow: auto;\n  padding: 20px;\n}\n\n._3WkQLUyd_5sA_re7EzYvMx._2nRhrrYvmfuxu34UiGItXs {\n  display: block;\n}\n", ""]);
	
	// exports
	exports.locals = {
		"pane": "_3WkQLUyd_5sA_re7EzYvMx",
		"pane": "_3WkQLUyd_5sA_re7EzYvMx",
		"selected": "_2nRhrrYvmfuxu34UiGItXs",
		"selected": "_2nRhrrYvmfuxu34UiGItXs"
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var now = __webpack_require__(27);
	
	/**
	 * Returns a function, that, as long as it continues to be invoked, will not
	 * be triggered. The function will be called after it stops being called for
	 * N milliseconds. If `immediate` is passed, trigger the function on the
	 * leading edge, instead of the trailing.
	 *
	 * @source underscore.js
	 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
	 * @param {Function} function to wrap
	 * @param {Number} timeout in ms (`100`)
	 * @param {Boolean} whether to execute at the beginning (`false`)
	 * @api public
	 */
	
	module.exports = function debounce(func, wait, immediate){
	  var timeout, args, context, timestamp, result;
	  if (null == wait) wait = 100;
	
	  function later() {
	    var last = now() - timestamp;
	
	    if (last < wait && last > 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      if (!immediate) {
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      }
	    }
	  };
	
	  return function debounced() {
	    context = this;
	    args = arguments;
	    timestamp = now();
	    var callNow = immediate && !timeout;
	    if (!timeout) timeout = setTimeout(later, wait);
	    if (callNow) {
	      result = func.apply(context, args);
	      context = args = null;
	    }
	
	    return result;
	  };
	};


/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = Date.now || now
	
	function now() {
	    return new Date().getTime()
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _skatejs = __webpack_require__(3);
	
	var _helpers = __webpack_require__(6);
	
	var _glamor = __webpack_require__(7);
	
	var css = (0, _glamor.style)({
	  backgroundColor: '#fefefe',
	  color: '#333',
	  fontSize: 16,
	  padding: '60px 0 0 0'
	});
	
	exports.default = function (props, chren) {
	  return (0, _skatejs.h)(
	    'div',
	    css,
	    (0, _skatejs.h)(_helpers.Css, { 'for': css }),
	    chren
	  );
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _glamor = __webpack_require__(7);
	
	var _skatejs = __webpack_require__(3);
	
	var _helpers = __webpack_require__(6);
	
	var _logoGithub = __webpack_require__(30);
	
	var _logoGithub2 = _interopRequireDefault(_logoGithub);
	
	var _logoTwitter = __webpack_require__(31);
	
	var _logoTwitter2 = _interopRequireDefault(_logoTwitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var footerCss = (0, _glamor.style)({
	  color: '#eee',
	  fontSize: 12,
	  paddingBottom: 38,
	  textAlign: 'center'
	});
	
	var githubLogoStyle = (0, _glamor.style)({
	  marginBottom: 10
	});
	
	exports.default = function () {
	  return (0, _skatejs.h)(
	    'div',
	    footerCss,
	    (0, _skatejs.h)(_helpers.Css, { 'for': [footerCss, githubLogoStyle] }),
	    (0, _skatejs.h)(
	      _helpers.Link,
	      { rel: 'external', href: 'https://github.com/skatejs/skatejs' },
	      (0, _skatejs.h)('img', _extends({ src: _logoGithub2.default, height: '26' }, githubLogoStyle))
	    ),
	    (0, _skatejs.h)(
	      _helpers.Link,
	      { rel: 'external', href: 'https://twitter.com/skate_js' },
	      (0, _skatejs.h)('img', { src: _logoTwitter2.default, height: '48' })
	    )
	  );
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ef7a02b69836dc8b6a732a54c4200dcb.png";

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "dafae5807689cd295aaff4497fea706a.svg";

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _skatejs = __webpack_require__(3);
	
	var _helpers = __webpack_require__(6);
	
	var _glamor = __webpack_require__(7);
	
	var _logo = __webpack_require__(33);
	
	var _logo2 = _interopRequireDefault(_logo);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var css = {
	  header: (0, _glamor.style)({
	    backgroundColor: '#fefefe',
	    color: '#333',
	    position: 'fixed',
	    transition: 'box-shadow .3s ease',
	    width: '100%'
	  }),
	  item: (0, _glamor.style)({
	    display: 'inline-block',
	    margin: 0,
	    padding: 0
	  }),
	  link: (0, _glamor.merge)((0, _glamor.style)({
	    color: '#333',
	    display: 'inline-block',
	    fontSize: 18,
	    margin: 0,
	    padding: 20,
	    textDecoration: 'none',
	    transition: 'background-color .3s ease'
	  }), (0, _glamor.hover)({
	    backgroundColor: '#eee'
	  })),
	  list: (0, _glamor.style)({
	    display: 'inline-block',
	    listStyle: 'none',
	    margin: 0,
	    padding: 0
	  }),
	  scrolled: (0, _glamor.style)({
	    boxShadow: '0 0 15px 0 #333'
	  }),
	  title: (0, _glamor.style)({
	    display: 'inline-block',
	    margin: '0 20px 0 10px',
	    padding: 0,
	    position: 'relative',
	    left: 14,
	    top: 8
	  })
	};
	
	var allCss = Object.keys(css).map(function (k) {
	  return css[k];
	});
	
	exports.default = function (props, chren) {
	  return (0, _skatejs.h)(
	    'div',
	    null,
	    (0, _skatejs.h)(_helpers.Css, { 'for': allCss }),
	    (0, _skatejs.h)(
	      'div',
	      _extends({}, css.header, props.scrolled ? css.scrolled : {}),
	      (0, _skatejs.h)(
	        'h1',
	        css.title,
	        (0, _skatejs.h)(
	          _helpers.Link,
	          { href: '/' },
	          (0, _skatejs.h)('img', { alt: props.title, src: _logo2.default, width: '30' })
	        )
	      ),
	      (0, _skatejs.h)(
	        'ul',
	        css.list,
	        chren
	      )
	    )
	  );
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "cdcf8f64994df2f0ca865f88e17aaa59.png";

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _skatejs = __webpack_require__(3);
	
	exports.default = (0, _skatejs.define)('sk-module', {
	  props: {
	    args: {},
	    load: {},
	    done: {}
	  },
	  updated: function updated(elem, prev) {
	    if (typeof elem.load === 'function') {
	      elem.load(function (args) {
	        return elem.args = args;
	      });
	    }
	    return elem.args;
	  },
	  render: function render(elem) {
	    if (typeof elem.done === 'function') {
	      return elem.done(elem.args);
	    }
	  }
	});

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _skatejs = __webpack_require__(3);
	
	var _page = __webpack_require__(15);
	
	var _page2 = _interopRequireDefault(_page);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var registered = [];
	
	exports.default = (0, _skatejs.define)('sk-router-route', {
	  props: {
	    match: {},
	    matched: _skatejs.prop.boolean({ attribute: true }),
	    path: _skatejs.prop.string({ attribute: true })
	  },
	  updated: function updated(elem, prev) {
	    var path = elem.path;
	
	
	    if (registered.indexOf(path) === -1) {
	      registered.push(path);
	      (0, _page2.default)(path, function () {
	        elem.matched = true;
	      });
	      _page2.default.exit(path, function (args, next) {
	        elem.matched = false;
	        next();
	      });
	
	      if (path === window.location.pathname) {
	        (0, _page2.default)(path);
	      }
	    }
	
	    return true;
	  },
	  render: function render(elem) {
	    return elem.matched && elem.match();
	  }
	});

/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (title) {
	  document.title = title;
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(1, function(require) {
		data = __webpack_require__(38);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 38 */,
/* 39 */,
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(2, function(require) {
		data = __webpack_require__(41);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 41 */,
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(3, function(require) {
		data = __webpack_require__(43);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 43 */,
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(4, function(require) {
		data = __webpack_require__(45);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 45 */,
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(5, function(require) {
		data = __webpack_require__(47);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 47 */,
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(6, function(require) {
		data = __webpack_require__(49);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 49 */,
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(51);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(52)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js?modules&camelCase!./index.css", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js?modules&camelCase!./index.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(19)();
	// imports
	
	
	// module
	exports.push([module.id, "html {\n  font-family: Helvetica;\n  font-size: 14px;\n}\n\nbody {\n  margin: 0;\n}\n\na {\n  color: #333;\n}\n\n.gitter-open-chat-button {\n  background-color: #333333;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n  width: 200px;\n}", ""]);
	
	// exports


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }
/******/ ])
});
;
//# sourceMappingURL=bundle.min.js.map